diff -U 5 --new-file --recursive src.ori/advance.pat src/advance.pat
--- src.ori/advance.pat	1970-01-01 01:00:00.000000000 +0100
+++ src/advance.pat	2004-07-11 14:44:55.000000000 +0200
@@ -0,0 +1 @@
+These files are patched for the use with the Advance emulator.
diff -U 5 --new-file --recursive src.ori/common.c src/common.c
--- src.ori/common.c	2004-06-27 18:40:06.000000000 +0200
+++ src/common.c	2004-07-11 14:44:55.000000000 +0200
@@ -754,10 +754,11 @@
 	the given filename
 -------------------------------------------------*/
 
 void save_screen_snapshot_as(mame_file *fp, struct mame_bitmap *bitmap)
 {
+#if 0 /* AdvanceMAME has its snapshot code */
 	struct rectangle bounds;
 	struct mame_bitmap *osdcopy;
 	UINT32 saved_rgb_components[3];
 
 	/* allow the artwork system to override certain parameters */
@@ -852,20 +853,24 @@
 	memcpy(direct_rgb_components, saved_rgb_components, sizeof(saved_rgb_components));
 
 	/* if the OSD system allocated a bitmap; free it */
 	if (osdcopy)
 		bitmap_free(osdcopy);
+#endif
 }
 
 
 
 /*-------------------------------------------------
 	save_screen_snapshot - save a screen snapshot
 -------------------------------------------------*/
 
 void save_screen_snapshot(struct mame_bitmap *bitmap)
 {
+#if 1 /* AdvanceMAME has its snapshot code */
+	osd_save_snapshot();
+#else
 	char name[20];
 	mame_file *fp;
 
 	/* avoid overwriting existing files */
 	/* first of all try with "gamename.png" */
@@ -882,10 +887,11 @@
 	if ((fp = mame_fopen(Machine->gamedrv->name, name, FILETYPE_SCREENSHOT, 1)) != NULL)
 	{
 		save_screen_snapshot_as(fp, bitmap);
 		mame_fclose(fp);
 	}
+#endif
 }
 
 
 
 /***************************************************************************
@@ -1240,11 +1246,11 @@
 		}
 		else
 			strcat(romdata->errorbuf, "WARNING: the game might not run correctly.\n");
 
 		/* display the result */
-		printf("%s", romdata->errorbuf);
+		osd_display_loading_rom_message(romdata->errorbuf, 0);
 
 		/* if we're not getting out of here, wait for a keypress */
 		if (!options.gui_host && !options.skip_warnings && !bailing)
 		{
 			int k;
diff -U 5 --new-file --recursive src.ori/cpu/i8085/i8085.c src/cpu/i8085/i8085.c
--- src.ori/cpu/i8085/i8085.c	2004-06-27 18:40:06.000000000 +0200
+++ src/cpu/i8085/i8085.c	2004-07-11 14:44:55.000000000 +0200
@@ -110,10 +110,16 @@
  * 
  *****************************************************************************/
 
 /*int survival_prot = 0; */
 
+#if defined(__GNUC__) && __GNUC__ >= 3
+/* Disable all the asm macro and the big switch */
+#undef X86_ASM
+#define BIG_SWITCH 0
+#endif
+
 #define VERBOSE 0
 
 #include "driver.h"
 #include "state.h"
 #include "osd_cpu.h"
diff -U 5 --new-file --recursive src.ori/cpu/m68000/make68k.c src/cpu/m68000/make68k.c
--- src.ori/cpu/m68000/make68k.c	2004-05-06 18:22:10.000000000 +0200
+++ src/cpu/m68000/make68k.c	2004-07-11 14:44:55.000000000 +0200
@@ -191,11 +191,11 @@
 
 
 #define NORMAL 0
 #define PCREL  1
 
-#ifdef __ELF__
+#if defined(USE_OBJ_ELF)
 #define PREF ""
 #else
 #define PREF "_"
 #endif
 
@@ -252,17 +252,17 @@
 
 
 
 /* External register preservation */
 
-#ifdef DOS
+#if defined(USE_COMPILER_GNUC)
 
 /* Registers normally saved around C routines anyway */
 /* GCC 2.9.1 (dos) seems to preserve EBX,EDI and EBP */
 static char SavedRegs[] = "-B--SDB";
 
-#elif defined(WIN32)
+#elif defined(USE_COMPILER_VISUALC)
 
 /* visual C++, win32, says it preserves ebx, edi, esi, and ebp */
 /* ---------- VC++ deosn't preserve EDI? (Kenjo, 110399) ---------- */
 static char SavedRegs[] = "-B--S-B";
 
@@ -8040,11 +8040,11 @@
 	fprintf(fp, "\t\tDW   0,0,0\n\n");
 
 
 /* If Win32, put the table area in .data section (Kenjo) */
 
-#ifdef WIN32
+#if defined(USE_OS_WINDOWS)
 
 	fprintf(fp, "%s_OPCODETABLE\tTIMES  65536  DD 0\n\n", CPUtype);
 
 #else
 
diff -U 5 --new-file --recursive src.ori/cpu/z80/z80.c src/cpu/z80/z80.c
--- src.ori/cpu/z80/z80.c	2004-06-27 18:40:08.000000000 +0200
+++ src/cpu/z80/z80.c	2004-07-11 14:44:55.000000000 +0200
@@ -82,10 +82,16 @@
 #include "cpuintrf.h"
 #include "state.h"
 #include "mamedbg.h"
 #include "z80.h"
 
+#if defined(__GNUC__) && __GNUC__ >= 3
+/* Disable all the asm macro and the big switch */
+#undef X86_ASM
+#define BIG_SWITCH 0
+#endif
+
 #define VERBOSE 0
 
 #if VERBOSE
 #define LOG(x)	logerror x
 #else
diff -U 5 --new-file --recursive src.ori/cpuexec.c src/cpuexec.c
--- src.ori/cpuexec.c	2004-06-27 18:40:08.000000000 +0200
+++ src/cpuexec.c	2004-07-11 14:44:55.000000000 +0200
@@ -307,10 +307,13 @@
 	watchdog_counter = -1;
 
 	/* reset sound chips */
 	sound_reset();
 
+	/* reset the osd level */
+	osd_reset();
+
 	/* first pass over CPUs */
 	for (cpunum = 0; cpunum < cpu_gettotalcpu(); cpunum++)
 	{
 		/* enable all CPUs (except for audio CPUs if the sound is off) */
 		if (!(Machine->drv->cpu[cpunum].cpu_flags & CPU_AUDIO_CPU) || Machine->sample_rate != 0)
diff -U 5 --new-file --recursive src.ori/drivers/multi32.c src/drivers/multi32.c
--- src.ori/drivers/multi32.c	2004-07-11 14:44:03.000000000 +0200
+++ src/drivers/multi32.c	2004-07-11 14:44:55.000000000 +0200
@@ -711,11 +711,11 @@
 	MDRV_NVRAM_HANDLER(system32)
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES(VIDEO_TYPE_RASTER | VIDEO_NEEDS_6BITS_PER_GUN | VIDEO_UPDATE_AFTER_VBLANK | VIDEO_RGB_DIRECT | VIDEO_HAS_SHADOWS ) // RGB_DIRECT will be needed for alpha
 	MDRV_SCREEN_SIZE(52*8*2, 28*8*2)
-	MDRV_VISIBLE_AREA(0*8, 52*8*2-1, 0*8, 28*8*2-1)
+	MDRV_VISIBLE_AREA(0, 320-1, 0, 224-1)
 
 	MDRV_GFXDECODE(gfxdecodeinfo)
 	MDRV_PALETTE_LENGTH(32768)
 
 	MDRV_VIDEO_START(system32)
diff -U 5 --new-file --recursive src.ori/drivers/namcos11.c src/drivers/namcos11.c
--- src.ori/drivers/namcos11.c	2004-07-11 14:44:03.000000000 +0200
+++ src/drivers/namcos11.c	2004-07-11 14:44:55.000000000 +0200
@@ -654,11 +654,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 8, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type1 )
 	MDRV_VIDEO_UPDATE( psx )
diff -U 5 --new-file --recursive src.ori/drivers/namcos12.c src/drivers/namcos12.c
--- src.ori/drivers/namcos12.c	2004-07-11 14:44:03.000000000 +0200
+++ src/drivers/namcos12.c	2004-07-11 14:44:55.000000000 +0200
@@ -263,11 +263,11 @@
 	MDRV_NVRAM_HANDLER( generic_0fill )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 480-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
diff -U 5 --new-file --recursive src.ori/drivers/psikyo4.c src/drivers/psikyo4.c
--- src.ori/drivers/psikyo4.c	2004-07-11 14:44:03.000000000 +0200
+++ src/drivers/psikyo4.c	2004-07-11 14:44:55.000000000 +0200
@@ -412,13 +412,13 @@
 	MDRV_NVRAM_HANDLER(93C56)
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES(VIDEO_TYPE_RASTER | VIDEO_NEEDS_6BITS_PER_GUN | VIDEO_DUAL_MONITOR)
 #if DUAL_SCREEN
-	MDRV_ASPECT_RATIO(8,3)
+	MDRV_ASPECT_RATIO(4,3)
 	MDRV_SCREEN_SIZE(80*8, 32*8)
-	MDRV_VISIBLE_AREA(0, 80*8-1, 0, 28*8-1)
+	MDRV_VISIBLE_AREA(0, 320-1, 0, 28*8-1)
 #else
 	MDRV_ASPECT_RATIO(4,3)
 	MDRV_SCREEN_SIZE(64*8, 32*8)
 	MDRV_VISIBLE_AREA(0, 40*8-1, 0, 28*8-1)
 #endif
@@ -437,11 +437,11 @@
 static MACHINE_DRIVER_START( ps4small )
 	/* basic machine hardware */
 	MDRV_IMPORT_FROM(ps4big)
 
 #if DUAL_SCREEN
-	MDRV_VISIBLE_AREA(0, 80*8-1, 0, 30*8-1)
+	MDRV_VISIBLE_AREA(0, 320-1, 0, 30*8-1)
 #else
 	MDRV_VISIBLE_AREA(0, 40*8-1, 0, 30*8-1)
 #endif
 MACHINE_DRIVER_END
 
diff -U 5 --new-file --recursive src.ori/drivers/stv.c src/drivers/stv.c
--- src.ori/drivers/stv.c	2004-07-11 14:44:03.000000000 +0200
+++ src/drivers/stv.c	2004-07-11 14:44:55.000000000 +0200
@@ -3670,11 +3670,11 @@
 	MDRV_NVRAM_HANDLER(93C46) /* Actually 93c45 */
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES(VIDEO_TYPE_RASTER | VIDEO_UPDATE_AFTER_VBLANK | VIDEO_RGB_DIRECT )
 	MDRV_SCREEN_SIZE(1024, 1024)
-	MDRV_VISIBLE_AREA(0*8, 703, 0*8, 479) // we need to use a resolution as high as the max size it can change to
+	MDRV_VISIBLE_AREA(0*8, 320-1, 0*8, 224-1)
 	MDRV_PALETTE_LENGTH(2048+(2048*2))//standard palette + extra memory for rgb brightness.
 	MDRV_GFXDECODE(gfxdecodeinfo)
 
 	MDRV_VIDEO_START(stv_vdp2)
 	MDRV_VIDEO_UPDATE(stv_vdp2)
diff -U 5 --new-file --recursive src.ori/drivers/zn.c src/drivers/zn.c
--- src.ori/drivers/zn.c	2004-07-11 14:44:04.000000000 +0200
+++ src/drivers/zn.c	2004-07-11 14:44:55.000000000 +0200
@@ -611,11 +611,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 512 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -646,11 +646,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -847,11 +847,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -1264,11 +1264,11 @@
 	MDRV_NVRAM_HANDLER( coh1000ta )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 512 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -1357,11 +1357,11 @@
 	MDRV_NVRAM_HANDLER( coh1000tb )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -1525,11 +1525,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -1735,11 +1735,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -1979,11 +1979,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 320-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -2312,11 +2312,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -2559,11 +2559,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -2826,11 +2826,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -2859,11 +2859,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 320-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -2891,11 +2891,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 320-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
diff -U 5 --new-file --recursive src.ori/info.c src/info.c
--- src.ori/info.c	2004-07-11 14:44:04.000000000 +0200
+++ src/info.c	2004-07-11 20:18:51.000000000 +0200
@@ -670,15 +670,31 @@
 	struct InternalMachineDriver driver;
 
 	expand_machine_driver(game->drv, &driver);
 
 	fprintf(out, "\t\t<driver");
-	if (game->flags & GAME_NOT_WORKING)
+
+	/* The status entry is an hint for frontend authors */
+	/* to select working and not working games without */
+	/* the need to know all the other status entries. */
+	/* Games marked as status=good are perfectly emulated, games */
+	/* marked as status=imperfect are emulated with only */
+	/* some minor issues, games marked as status=preliminary */
+	/* don't work or have major emulation problems. */
+
+	if (game->flags & (GAME_NOT_WORKING | GAME_UNEMULATED_PROTECTION | GAME_NO_SOUND | GAME_WRONG_COLORS))
 		fprintf(out, " status=\"preliminary\"");
+	else if (game->flags & (GAME_IMPERFECT_COLORS | GAME_IMPERFECT_SOUND | GAME_IMPERFECT_GRAPHICS))
+		fprintf(out, " status=\"imperfect\"");
 	else
 		fprintf(out, " status=\"good\"");
 
+	if (game->flags & GAME_NOT_WORKING)
+		fprintf(out, " emulation=\"preliminary\"");
+	else
+		fprintf(out, " emulation=\"good\"");
+
 	if (game->flags & GAME_WRONG_COLORS)
 		fprintf(out, " color=\"preliminary\"");
 	else if (game->flags & GAME_IMPERFECT_COLORS)
 		fprintf(out, " color=\"imperfect\"");
 	else
@@ -690,13 +706,13 @@
 		fprintf(out, " sound=\"imperfect\"");
 	else
 		fprintf(out, " sound=\"good\"");
 
 	if (game->flags & GAME_IMPERFECT_GRAPHICS)
-		fprintf(out, " graphic=\"preliminary\"");
+		fprintf(out, " graphics=\"imperfect\"");
 	else
-		fprintf(out, " graphic=\"good\"");
+		fprintf(out, " graphics=\"good\"");
 
 	if (game->flags & GAME_NO_COCKTAIL)
 		fprintf(out, " cocktail=\"preliminary\"");
 
 	if (game->flags & GAME_UNEMULATED_PROTECTION)
@@ -754,11 +770,11 @@
 	fprintf(out, ">\n");
 
 	if (game->description)
 		fprintf(out, "\t\t<description>%s</description>\n", normalize_string(game->description));
 
-	/* print the year only if is a number */
+	/* print the year only if it's a number */
 	if (game->year && strspn(game->year,"0123456789")==strlen(game->year))
 		fprintf(out, "\t\t<year>%s</year>\n", normalize_string(game->year) );
 
 	if (game->manufacturer)
 		fprintf(out, "\t\t<manufacturer>%s</manufacturer>\n", normalize_string(game->manufacturer));
@@ -782,10 +798,15 @@
 
 #if !defined(MESS) && !defined(TINY_COMPILE) && !defined(MMSND)
 /* Print the resource info */
 static void print_resource_info(FILE* out, const struct GameDriver* game)
 {
+	/* The runnable entry is an hint for frontend authors */
+	/* to easily know which game can be started. */
+	/* Games marked as runnable=yes can be started putting */
+	/* the game name as argument in the program command line, */
+	/* games marked as runnable=no cannot be started. */
 	fprintf(out, "\t<" XML_TOP " runnable=\"no\"");
 
 	fprintf(out, " name=\"%s\"", normalize_string(game->name) );
 
 	fprintf(out, ">\n");
@@ -932,16 +953,17 @@
 		"\t\t\t<!ATTLIST dipswitch name CDATA #REQUIRED>\n"
 		"\t\t\t<!ELEMENT dipvalue EMPTY>\n"
 		"\t\t\t\t<!ATTLIST dipvalue name CDATA #REQUIRED>\n"
 		"\t\t\t\t<!ATTLIST dipvalue default (yes|no) \"no\">\n"
 		"\t\t<!ELEMENT driver EMPTY>\n"
-		"\t\t\t<!ATTLIST driver status (good|preliminary|test) #REQUIRED>\n"
+		"\t\t\t<!ATTLIST driver status (good|imperfect|preliminary) #REQUIRED>\n"
+		"\t\t\t<!ATTLIST driver emulation (good|imperfect|preliminary) #REQUIRED>\n"
 		"\t\t\t<!ATTLIST driver color (good|imperfect|preliminary) #REQUIRED>\n"
 		"\t\t\t<!ATTLIST driver sound (good|imperfect|preliminary) #REQUIRED>\n"
-		"\t\t\t<!ATTLIST driver graphic (good|imperfect) #REQUIRED>\n"
-		"\t\t\t<!ATTLIST driver cocktail (preliminary) #IMPLIED>\n"
-		"\t\t\t<!ATTLIST driver protection (preliminary) #IMPLIED>\n"
+		"\t\t\t<!ATTLIST driver graphics (good|imperfect|preliminary) #REQUIRED>\n"
+		"\t\t\t<!ATTLIST driver cocktail (good|imperfect|preliminary) #IMPLIED>\n"
+		"\t\t\t<!ATTLIST driver protection (good|imperfect|preliminary) #IMPLIED>\n"
 		"\t\t\t<!ATTLIST driver palettesize CDATA #REQUIRED>\n"
 #ifdef MESS
 		"\t\t<!ELEMENT device (extension*)>\n"
 		"\t\t\t<!ATTLIST device name CDATA #REQUIRED>\n"
 		"\t\t\t<!ELEMENT extension EMPTY>\n"
diff -U 5 --new-file --recursive src.ori/inptport.c src/inptport.c
--- src.ori/inptport.c	2004-07-11 14:44:04.000000000 +0200
+++ src/inptport.c	2004-07-11 16:35:10.000000000 +0200
@@ -184,10 +184,18 @@
 	{ IPT_UI_SHOW_PROFILER,		0, "Show Profiler",		{ SEQ_DEF_2(KEYCODE_F11, KEYCODE_LSHIFT) } },
 #ifdef MESS
 	{ IPT_UI_TOGGLE_UI,			0, "UI Toggle",			{ SEQ_DEF_1(KEYCODE_SCRLOCK) } },
 #endif
 	{ IPT_UI_SNAPSHOT,			0, "Save Snapshot",		{ SEQ_DEF_1(KEYCODE_F12) } },
+	{ IPT_UI_RECORD_START,			0, "Record Start", { SEQ_DEF_2(KEYCODE_ENTER,KEYCODE_LCONTROL) } },
+	{ IPT_UI_RECORD_STOP,			0, "Record Stop", { SEQ_DEF_3(KEYCODE_ENTER,CODE_NOT,KEYCODE_LCONTROL) } },
+	{ IPT_UI_TURBO,				0, "Turbo", { SEQ_DEF_1(KEYCODE_ASTERISK) } },
+	{ IPT_UI_COCKTAIL,			0, "Cocktail", { SEQ_DEF_1(KEYCODE_SLASH_PAD) } },
+	{ IPT_UI_HELP,				0, "Help", { SEQ_DEF_1(KEYCODE_F1_REAL) } },
+	{ IPT_UI_STARTUP_END,			0, "Startup End", { SEQ_DEF_1(KEYCODE_MINUS_PAD) } },
+	{ IPT_UI_MODE_NEXT,			0, "Mode Next", { SEQ_DEF_1(KEYCODE_STOP) } },
+	{ IPT_UI_MODE_PRED,			0, "Mode Pred", { SEQ_DEF_1(KEYCODE_COMMA) } },
 	{ IPT_UI_TOGGLE_CHEAT,		0, "Toggle Cheat",		{ SEQ_DEF_1(KEYCODE_F6) } },
 	{ IPT_UI_UP,				0, "UI Up",				{ SEQ_DEF_3(KEYCODE_UP, CODE_OR, JOYCODE_1_UP) } },
 	{ IPT_UI_DOWN,				0, "UI Down",			{ SEQ_DEF_3(KEYCODE_DOWN, CODE_OR, JOYCODE_1_DOWN) } },
 	{ IPT_UI_LEFT,				0, "UI Left",			{ SEQ_DEF_3(KEYCODE_LEFT, CODE_OR, JOYCODE_1_LEFT) } },
 	{ IPT_UI_RIGHT,				0, "UI Right",			{ SEQ_DEF_3(KEYCODE_RIGHT, CODE_OR, JOYCODE_1_RIGHT) } },
@@ -1393,10 +1401,13 @@
 	config_file *cfg;
 
 	osd_customize_inputport_defaults(inputport_defaults);
 	memcpy(inputport_defaults_backup,inputport_defaults,sizeof(inputport_defaults));
 
+	/* AdvanceMAME: Load user defined customization */
+	osd_customize_inputport_pre_defaults(inputport_defaults);
+
 	cfg = config_open(NULL);
 	if (cfg)
 	{
 		config_read_default_ports(cfg, inputport_defaults);
 		config_close(cfg);
@@ -1446,10 +1457,13 @@
 
 getout:
 		config_close(cfg);
 	}
 
+	/* AdvanceMAME: Load user defined customization */
+	osd_customize_inputport_pre_game(Machine->input_ports);
+
 	/* All analog ports need initialization */
 	{
 		int i;
 		for (i = 0; i < MAX_INPUT_PORTS; i++)
 			input_analog_init[i] = 1;
@@ -1689,14 +1703,16 @@
 		int new, prev;
 
 		/* center stick */
 		if ((delta == 0) && (in->u.analog.center))
 		{
-			if (current > default_value)
-			delta = -100 / sensitivity;
-			if (current < default_value)
-			delta = 100 / sensitivity;
+			/* AdvanceMAME: Return backward at middle keyboard speed */
+			delta = default_value - current;
+			if (delta < -(keydelta+1)/2)
+				delta = -(keydelta+1)/2;
+			if (delta > (keydelta+1)/2)
+				delta = (keydelta+1)/2;
 		}
 
 		/* An analog joystick which is not at zero position (or has just */
 		/* moved there) takes precedence over all other computations */
 		/* analog_x/y holds values from -128 to 128 (yes, 128, not 127) */
@@ -2035,11 +2051,11 @@
 				}
 				else
 				{
 					InputSeq* seq;
 					seq = input_port_seq(in, 0);
-					if (seq_pressed(seq))
+					if (osd_input_port_filter(seq_pressed(seq), in->type, in->player + 1, 0))
 					{
 #ifdef MESS
 						if ((in->type == IPT_KEYBOARD) && osd_keyboard_disabled())
 							continue;
 #endif
diff -U 5 --new-file --recursive src.ori/inptport.h src/inptport.h
--- src.ori/inptport.h	2004-07-11 14:44:04.000000000 +0200
+++ src/inptport.h	2004-07-11 14:52:30.000000000 +0200
@@ -135,10 +135,18 @@
 	IPT_OSD_4,
 
 	IPT_EXTENSION,
 
 	/* the following are special codes for user interface handling - not to be used by drivers! */
+	IPT_UI_MODE_NEXT,
+	IPT_UI_MODE_PRED,
+	IPT_UI_RECORD_START,
+	IPT_UI_RECORD_STOP,
+	IPT_UI_TURBO,
+	IPT_UI_COCKTAIL,
+	IPT_UI_HELP,
+	IPT_UI_STARTUP_END,
 	IPT_UI_CONFIGURE,
 	IPT_UI_ON_SCREEN_DISPLAY,
 	IPT_UI_PAUSE,
 	IPT_UI_RESET_MACHINE,
 	IPT_UI_SHOW_GFX,
diff -U 5 --new-file --recursive src.ori/input.c src/input.c
--- src.ori/input.c	2004-07-11 14:44:04.000000000 +0200
+++ src/input.c	2004-07-11 16:39:42.000000000 +0200
@@ -12,15 +12,10 @@
 #include <assert.h>
 
 /***************************************************************************/
 /* Codes */
 
-/* Subtype of codes */
-#define CODE_TYPE_NONE 0U /* code not assigned */
-#define CODE_TYPE_KEYBOARD 1U /* keyboard code */
-#define CODE_TYPE_JOYSTICK 2U /* joystick code */
-
 /* Informations for every input code */
 struct code_info {
 	int memory; /* boolean memory */
 	unsigned oscode; /* os dependant code */
 	unsigned type; /* subtype: CODE_TYPE_KEYBOARD or CODE_TYPE_JOYSTICK */
@@ -195,12 +190,11 @@
 		}
 	}
 	return 0;
 }
 
-/* Check if a code is pressed */
-static int internal_code_pressed(InputCode code)
+unsigned code_to_oscode(InputCode code, unsigned* type)
 {
 	const struct KeyboardInfo *keyinfo;
 	const struct JoystickInfo *joyinfo;
 
 	assert( code < code_mac );
@@ -209,28 +203,52 @@
 	{
 		switch (code_map[code].type)
 		{
 			case CODE_TYPE_KEYBOARD :
 				keyinfo = internal_code_find_keyboard(code);
-				if (keyinfo)
-					return osd_is_key_pressed(keyinfo->code);
+				if (keyinfo) {
+					*type = CODE_TYPE_KEYBOARD;
+					return keyinfo->code;
+				}
 				break;
 			case CODE_TYPE_JOYSTICK :
 				joyinfo = internal_code_find_joystick(code);
-				if (joyinfo)
-					return osd_is_joy_pressed(joyinfo->code);
+				if (joyinfo) {
+					*type = CODE_TYPE_JOYSTICK;
+					return joyinfo->code;
+				}
 				break;
 		}
 	} else {
 		switch (code_map[code].type)
 		{
 			case CODE_TYPE_KEYBOARD :
-				return osd_is_key_pressed(code_map[code].oscode);
+				*type = CODE_TYPE_KEYBOARD;
+				return code_map[code].oscode;
 			case CODE_TYPE_JOYSTICK :
-				return osd_is_joy_pressed(code_map[code].oscode);
+				*type = CODE_TYPE_JOYSTICK;
+				return code_map[code].oscode;
 		}
 	}
+
+	*type = CODE_TYPE_NONE;
+	return 0;
+}
+
+/* Check if a code is pressed */
+static int internal_code_pressed(InputCode code)
+{
+	unsigned oscode;
+	unsigned type;
+
+	oscode = code_to_oscode(code, &type);
+
+	switch (type) {
+	case CODE_TYPE_KEYBOARD : return osd_is_key_pressed(oscode);
+	case CODE_TYPE_JOYSTICK : return osd_is_joy_pressed(oscode);
+	}
+
 	return 0;
 }
 
 /* Return the name of the code */
 static const char* internal_code_name(InputCode code)
@@ -812,11 +830,11 @@
 {
 	int pressed;
 
 	profiler_mark(PROFILER_INPUT);
 
-	pressed = seq_pressed(input_port_type_seq(code,0));
+	pressed = osd_input_port_filter(seq_pressed(input_port_type_seq(code,0)), code, 0, 0);
 
 	if (pressed)
 	{
 		if (ui_map[code].memory == 0)
 		{
@@ -836,11 +854,11 @@
 	static int counter,inputdelay;
 	int pressed;
 
 	profiler_mark(PROFILER_INPUT);
 
-	pressed = seq_pressed(input_port_type_seq(code,0));
+	pressed = osd_input_port_filter(seq_pressed(input_port_type_seq(code,0)), code, 0, 0);
 
 	if (pressed)
 	{
 		if (ui_map[code].memory == 0)
 		{
diff -U 5 --new-file --recursive src.ori/input.h src/input.h
--- src.ori/input.h	2004-06-27 18:40:24.000000000 +0200
+++ src/input.h	2004-07-11 14:44:55.000000000 +0200
@@ -121,18 +121,33 @@
 #define KEYCODE_OTHER CODE_OTHER
 #define JOYCODE_OTHER CODE_OTHER
 #define KEYCODE_NONE CODE_NONE
 #define JOYCODE_NONE CODE_NONE
 
+/* AdvanceMAME: Remap the F1 key used by some debug code to an unused key. */
+#ifdef MESS
+#define KEYCODE_F1_REAL KEYCODE_F1
+#else
+#define KEYCODE_F1_REAL (KEYCODE_F2-1)
+#define KEYCODE_F1 KEYCODE_NUMLOCK
+#endif
+
 /***************************************************************************/
 /* Single code functions */
 
 int code_init(void);
 void code_close(void);
 
+/* Subtype of codes */
+#define CODE_TYPE_NONE 0U /* code not assigned */
+#define CODE_TYPE_KEYBOARD 1U /* keyboard code */
+#define CODE_TYPE_JOYSTICK 2U /* joystick code */
+
 InputCode keyoscode_to_code(unsigned oscode);
 InputCode joyoscode_to_code(unsigned oscode);
+unsigned code_to_oscode(InputCode code, unsigned* type);
+
 InputCode savecode_to_code(unsigned savecode);
 unsigned code_to_savecode(InputCode code);
 
 const char *code_name(InputCode code);
 int code_pressed(InputCode code);
diff -U 5 --new-file --recursive src.ori/mame.c src/mame.c
--- src.ori/mame.c	2004-07-01 06:35:24.000000000 +0200
+++ src/mame.c	2004-07-11 14:44:55.000000000 +0200
@@ -990,26 +990,20 @@
 	to a given resolution
 -------------------------------------------------*/
 
 static void scale_vectorgames(int gfx_width, int gfx_height, int *width, int *height)
 {
-	double x_scale, y_scale, scale;
-
-	/* compute the scale values */
-	x_scale = (double)gfx_width / (double)(*width);
-	y_scale = (double)gfx_height / (double)(*height);
-
-	/* pick the smaller scale factor */
-	scale = (x_scale < y_scale) ? x_scale : y_scale;
-
-	/* compute the new size */
-	*width = (int)((double)*width * scale);
-	*height = (int)((double)*height * scale);
-
-	/* round to the nearest 4 pixel value */
-	*width &= ~3;
-	*height &= ~3;
+	if (Machine->orientation & ORIENTATION_SWAP_XY)
+	{
+		*width = gfx_height;
+		*height = gfx_width*9/16;
+	}
+	else
+	{
+		*width = gfx_width;
+		*height = gfx_height;
+	}
 }
 
 
 
 /*-------------------------------------------------
diff -U 5 --new-file --recursive src.ori/mamedbg.c src/mamedbg.c
--- src.ori/mamedbg.c	2004-07-11 14:44:04.000000000 +0200
+++ src/mamedbg.c	2004-07-11 14:44:55.000000000 +0200
@@ -2329,11 +2329,11 @@
 		win_create(WIN_CMDS(i), 1,
 			cmds.min_x,cmds.min_y,
 			cmds.max_x+1-cmds.min_x,cmds.max_y+1-cmds.min_y,
 			cur_col[E_CMDS], cur_col[E_FRAME], ' ', flags );
 
-		win_set_title(WIN_CMDS(i), "Command (press F1 for help)");
+		win_set_title(WIN_CMDS(i), "Command (press NUMLOCK for help)");
 	}
 }
 
 /**************************************************************************
  * dbg_close_windows
@@ -3311,11 +3311,11 @@
 		win_set_title( WIN_CMDS(active_cpu), "%s%s", dbg_info_once, hist_info );
 		dbg_info_once = NULL;
 	}
 	else
 	{
-		win_set_title( WIN_CMDS(active_cpu), "Command (press F1 for help)%s", hist_info );
+		win_set_title( WIN_CMDS(active_cpu), "Command (press NUMLOCK for help)%s", hist_info );
 	}
 	return INVALID;
 }
 
 /**************************************************************************
diff -U 5 --new-file --recursive src.ori/osdepend.h src/osdepend.h
--- src.ori/osdepend.h	2004-06-27 18:40:42.000000000 +0200
+++ src/osdepend.h	2004-07-11 16:39:57.000000000 +0200
@@ -384,10 +384,45 @@
       __attribute__ ((format (printf, 1, 2)));
 #else
 void CLIB_DECL logerror(const char *text,...);
 #endif
 
+/* called then the game is reset */
+void osd_reset(void);
+
+/* execute the specified menu (0,1,...) */
+int osd_menu(struct mame_bitmap *bitmap, int sel);
+
+/* filter the main exit request */
+int osd_input_exit_filter(int result);
+
+/* filter the input port state */
+int osd_input_port_filter(int result, unsigned type, unsigned player, unsigned index);
+
+/* snapshot saving */
+void osd_save_snapshot(void);
+
+/* start and stop the video/sound recording. */
+void osd_record_start(void);
+void osd_record_stop(void);
+
+void osd_ui_menu(const char** items,const char** subitems, char* flag, int selected, int arrowize_subitem);
+void osd_ui_message(const char* text, int second);
+void osd_ui_osd(const char *text, int percentage, int default_percentage);
+void osd_ui_scroll(const char* text, int* pos);
+
+/* customize the inputport */
+void osd_customize_inputport_pre_game(struct InputPort* current);
+void osd_customize_inputport_pre_defaults(struct ipd* current);
+void osd_customize_inputport_post_game(struct InputPort* def, struct InputPort* current, unsigned index);
+void osd_customize_inputport_post_defaults(struct ipd* def, struct ipd* current, unsigned index);
+void osd_customize_switchport_post_game(struct InputPort* def, struct InputPort* current);
+void osd_customize_analogport_post_game(struct InputPort* def, struct InputPort* current);
+
+/* handle the specific user interface */
+int osd_handle_user_interface(struct mame_bitmap *bitmap, int is_menu_active);
+
 #ifdef __cplusplus
 }
 #endif
 
 #endif
diff -U 5 --new-file --recursive src.ori/rules.mak src/rules.mak
--- src.ori/rules.mak	2004-06-27 18:40:48.000000000 +0200
+++ src/rules.mak	2004-07-11 14:44:55.000000000 +0200
@@ -1143,16 +1143,16 @@
 CPUOBJS += $(OBJ)/$(G6D)/g65816o1.o
 CPUOBJS += $(OBJ)/$(G6D)/g65816o2.o
 CPUOBJS += $(OBJ)/$(G6D)/g65816o3.o
 CPUOBJS += $(OBJ)/$(G6D)/g65816o4.o
 DBGOBJS += $(OBJ)/$(G6D)/g65816ds.o
-$(OBJ)/$(G6D)/g65816.o: $(G6D)/g65816.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
-$(OBJ)/$(G6D)/g65816o0.o: $(G6D)/g65816o0.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
-$(OBJ)/$(G6D)/g65816o1.o: $(G6D)/g65816o0.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
-$(OBJ)/$(G6D)/g65816o2.o: $(G6D)/g65816o0.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
-$(OBJ)/$(G6D)/g65816o3.o: $(G6D)/g65816o0.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
-$(OBJ)/$(G6D)/g65816o4.o: $(G6D)/g65816o0.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
+$(OBJ)/$(G6D)/g65816.o: g65816.c g65816.h g65816cm.h g65816op.h
+$(OBJ)/$(G6D)/g65816o0.o: g65816o0.c g65816.h g65816cm.h g65816op.h
+$(OBJ)/$(G6D)/g65816o1.o: g65816o0.c g65816.h g65816cm.h g65816op.h
+$(OBJ)/$(G6D)/g65816o2.o: g65816o0.c g65816.h g65816cm.h g65816op.h
+$(OBJ)/$(G6D)/g65816o3.o: g65816o0.c g65816.h g65816cm.h g65816op.h
+$(OBJ)/$(G6D)/g65816o4.o: g65816o0.c g65816.h g65816cm.h g65816op.h
 else
 CPUDEFS += -DHAS_G65816=0
 endif
 
 CPU=$(strip $(findstring SPC700@,$(CPUS)))
@@ -1160,11 +1160,11 @@
 SPCD = cpu/spc700
 OBJDIRS += $(OBJ)/$(SPCD)
 CPUDEFS += -DHAS_SPC700=1
 CPUOBJS += $(OBJ)/$(SPCD)/spc700.o
 DBGOBJS += $(OBJ)/$(SPCD)/spc700ds.o
-$(OBJ)/$(SPCD)/spc700/spc700.o: $(SPCD)/spc700.c $(SPCD)/spc700.h
+$(OBJ)/$(SPCD)/spc700.o: spc700.c spc700.h
 else
 CPUDEFS += -DHAS_SPC700=0
 endif
 
 CPU=$(strip $(findstring E132XS@,$(CPUS)))
@@ -1230,13 +1230,13 @@
 
 SOUND=$(strip $(findstring DISCRETE@,$(SOUNDS)))
 ifneq ($(SOUND),)
 SOUNDDEFS += -DHAS_DISCRETE=1
 SOUNDOBJS += $(OBJ)/sound/discrete.o
-$(OBJ)/sound/discrete.o: src/sound/discrete.c src/sound/discrete.h \
-		src/sound/disc_dev.c src/sound/disc_flt.c src/sound/disc_inp.c \
-		src/sound/disc_mth.c src/sound/disc_wav.c
+$(OBJ)/sound/discrete.o: discrete.c discrete.h \
+		disc_dev.c disc_flt.c disc_inp.c \
+		disc_mth.c disc_wav.c
 else
 SOUNDDEFS += -DHAS_DISCRETE=0
 endif
 
 SOUND=$(strip $(findstring AY8910@,$(SOUNDS)))
diff -U 5 --new-file --recursive src.ori/sound/mixer.c src/sound/mixer.c
--- src.ori/sound/mixer.c	2003-10-12 20:51:58.000000000 +0200
+++ src/sound/mixer.c	2004-07-11 14:44:55.000000000 +0200
@@ -690,10 +690,11 @@
 
 int mixer_sh_start(void)
 {
 	struct mixer_channel_data *channel;
 	int i;
+	int r;
 
 	/* reset all channels to their defaults */
 	memset(&mixer_channel, 0, sizeof(mixer_channel));
 	for (i = 0, channel = mixer_channel; i < MIXER_MAX_CHANNELS; i++, channel++)
 	{
@@ -713,11 +714,15 @@
 	/* clear the accumulators */
 	accum_base = 0;
 	memset(left_accum, 0, sizeof(left_accum));
 	memset(right_accum, 0, sizeof(right_accum));
 
-	samples_this_frame = osd_start_audio_stream(is_stereo);
+	r = osd_start_audio_stream(is_stereo);
+	if (r < 0)
+		return -1;
+
+	samples_this_frame = r;
 
 	mixer_sound_enabled = 1;
 
 	return 0;
 }
diff -U 5 --new-file --recursive src.ori/ui_text.c src/ui_text.c
--- src.ori/ui_text.c	2003-12-24 16:31:12.000000000 +0100
+++ src/ui_text.c	2004-07-11 14:44:55.000000000 +0200
@@ -199,10 +199,14 @@
 	"Restoration successful",
 	"Select a value",
 	"All values saved",
 	"One match found - added to list",
 
+	/* AdvanceMAME: Extra user interface commands */
+	"Center",
+	"Video",
+
 	NULL
 };
 
 
 
diff -U 5 --new-file --recursive src.ori/ui_text.h src/ui_text.h
--- src.ori/ui_text.h	2003-12-24 16:31:12.000000000 +0100
+++ src/ui_text.h	2004-07-11 14:44:55.000000000 +0200
@@ -168,10 +168,14 @@
 	UI_search_OK,
 	UI_search_select_value,
 	UI_search_all_values_saved,
 	UI_search_one_match_found_added,
 
+	/* AdvanceMAME: Extra user interface commands */
+	UI_center,
+	UI_osdmenu,
+
 	UI_last_mame_entry
 };
 
 #ifdef MESS
 #include "mui_text.h"
diff -U 5 --new-file --recursive src.ori/usrintrf.c src/usrintrf.c
--- src.ori/usrintrf.c	2004-07-11 14:44:04.000000000 +0200
+++ src/usrintrf.c	2004-07-11 17:24:22.000000000 +0200
@@ -826,10 +826,13 @@
 
 
 
 void ui_displaymenu(struct mame_bitmap *bitmap,const char **items,const char **subitems,char *flag,int selected,int arrowize_subitem)
 {
+#if 1 /* AdvanceMAME has its ui code */
+	osd_ui_menu(items, subitems, flag, selected, arrowize_subitem);
+#else
 	struct DisplayText dt[256];
 	int curr_dt;
 	const char *lefthilight = ui_getstring (UI_lefthilight);
 	const char *righthilight = ui_getstring (UI_righthilight);
 	const char *uparrow = ui_getstring (UI_uparrow);
@@ -996,15 +999,19 @@
 		if (long_y + long_dy > uirotheight)
 			long_y = topoffs + i * 3*uirotcharheight/2 - long_dy;
 
 		ui_multitextbox_ex(bitmap,subitems[selected],subitems[selected] + strlen(subitems[selected]), long_max, long_x,long_y,long_dx,long_dy, UI_COLOR_NORMAL);
 	}
+#endif
 }
 
 
 void ui_displaymessagewindow(struct mame_bitmap *bitmap,const char *text)
 {
+#if 1 /* AdvanceMAME has its ui code */
+	osd_ui_scroll(text, 0);
+#else
 	struct DisplayText dt[256];
 	int curr_dt;
 	char *c,*c2;
 	int i,len,maxlen,lines;
 	char textcopy[2048];
@@ -1099,10 +1106,11 @@
 	}
 
 	dt[curr_dt].text = 0;	/* terminate array */
 
 	displaytext(bitmap,dt);
+#endif
 }
 
 
 
 static void showcharset(struct mame_bitmap *bitmap)
@@ -1631,10 +1639,13 @@
 			{
 				if ((in+1)->type == switch_setting)
 					entry[sel]->default_value = (in+1)->default_value & entry[sel]->mask;
 			}
 
+			/* AdvanceMAME: Store the port changes */
+			osd_customize_switchport_post_game(Machine->input_ports_default + (entry[sel] - Machine->input_ports), entry[sel]);
+
 			/* tell updatescreen() to clean after us (in case the window changes size) */
 			schedule_full_refresh();
 		}
 	}
 
@@ -1654,10 +1665,13 @@
 			{
 				if ((in-1)->type == switch_setting)
 					entry[sel]->default_value = (in-1)->default_value & entry[sel]->mask;
 			}
 
+			/* AdvanceMAME: Store the port changes */
+			osd_customize_switchport_post_game(Machine->input_ports_default + (entry[sel] - Machine->input_ports), entry[sel]);
+
 			/* tell updatescreen() to clean after us (in case the window changes size) */
 			schedule_full_refresh();
 		}
 	}
 
@@ -1715,15 +1729,18 @@
 static int setdefcodesettings(struct mame_bitmap *bitmap,int selected)
 {
 	const char *menu_item[500];
 	const char *menu_subitem[500];
 	InputSeq *entry[500];
+	struct ipd* port[500];
+	unsigned char index[500];
 	char flag[500];
 	int i,sel;
 	struct ipd *in;
 	int total;
 	extern struct ipd inputport_defaults[];
+	extern struct ipd inputport_defaults_backup[];
 
 	sel = selected - 1;
 
 
 	if (Machine->input_ports == 0)
@@ -1738,10 +1755,12 @@
 		{
 			int seq_count = (in->type > IPT_ANALOG_START && in->type < IPT_ANALOG_END) ? 2 : 1;
 			int j;
 			for (j = 0; j < seq_count; j++)
 			{
+				port[total] = in;
+				index[total] = j;
 				entry[total] = &in->seq[j];
 				menu_item[total] = in->name;
 				if (j == 1 && in->type >= IPT_PEDAL && in->type <= IPT_PEDAL2)
 					menu_item[total] = "Auto Release <Y/N>";
 
@@ -1792,10 +1811,13 @@
 			schedule_full_refresh();
 
 			record_first_insert = ret != 0;
 		}
 
+		/* AdvanceMAME: Store the port changes */
+		osd_customize_inputport_post_defaults(inputport_defaults_backup + (port[sel & SEL_MASK] - inputport_defaults), port[sel & SEL_MASK], index[sel & SEL_MASK]);
+
 		init_analog_seq();
 
 		return sel + 1;
 	}
 
@@ -1850,10 +1872,12 @@
 static int setcodesettings(struct mame_bitmap *bitmap,int selected)
 {
 	const char *menu_item[500];
 	const char *menu_subitem[500];
 	InputSeq *seq[500];
+	struct InputPort* port[500];
+	unsigned char index[500];
 	char flag[500];
 	int i,sel;
 	struct InputPort *in;
 	int total;
 
@@ -1876,10 +1900,12 @@
 #ifdef MESS
 				&& ((in->category == 0) || input_category_active(in->category))
 #endif /* MESS */
 				&& in->type != IPT_OSD_RESERVED)
 			{
+				port[total] = in;
+				index[total] = i;
 				seq[total] = &in->seq[i];
 				menu_item[total] = input_port_name(in);
 				if (i == 1 && in->type >= IPT_PEDAL && in->type <= IPT_PEDAL2)
 					menu_item[total] = "Auto Release <Y/N>";
 
@@ -1929,10 +1955,13 @@
 			schedule_full_refresh();
 
 			record_first_insert = ret != 0;
 		}
 
+		/* AdvanceMAME: Store the port changes */
+		osd_customize_inputport_post_game(Machine->input_ports_default + (port[sel & SEL_MASK] - Machine->input_ports), port[sel & SEL_MASK], index[sel & SEL_MASK]);
+
 		init_analog_seq();
 
 		return sel + 1;
 	}
 
@@ -2074,13 +2103,13 @@
 		in++;
 	}
 
 	if (total == 0) return 0;
 
-	/* Each analog control has 3 entries - key & joy delta, reverse, sensitivity */
+	/* Each analog control has 4 entries - key & joy delta, reverse, sensitivity, center */
 
-#define ENTRIES 3
+#define ENTRIES 4
 
 	total2 = total * ENTRIES;
 
 	menu_item[total2] = ui_getstring (UI_returntomain);
 	menu_item[total2 + 1] = 0;	/* terminate array */
@@ -2093,15 +2122,17 @@
 		{
 			char label[30][40];
 			char setting[30][40];
 			int sensitivity,delta;
 			int reverse;
+			int center;
 
 			strcpy (label[i], input_port_name(entry[i/ENTRIES]));
 			sensitivity = entry[i/ENTRIES]->u.analog.sensitivity;
 			delta = entry[i/ENTRIES]->u.analog.delta;
 			reverse = entry[i/ENTRIES]->u.analog.reverse;
+			center = entry[i/ENTRIES]->u.analog.center;
 
 			strcat (label[i], " ");
 			switch (i%ENTRIES)
 			{
 				case 0:
@@ -2120,10 +2151,18 @@
 				case 2:
 					strcat (label[i], ui_getstring (UI_sensitivity));
 					sprintf(setting[i],"%3d%%",sensitivity);
 					if (i == sel) arrowize = 3;
 					break;
+				case 3:
+					strcat (label[i], ui_getstring (UI_center));
+					if (center)
+						strcpy(setting[i],ui_getstring (UI_on));
+					else
+						strcpy(setting[i],ui_getstring (UI_off));
+					if (i == sel) arrowize = 3;
+					break;
 			}
 
 			menu_item[i] = label[i];
 			menu_subitem[i] = setting[i];
 
@@ -2165,10 +2204,22 @@
 
 				val --;
 				if (val < 1) val = 1;
 				entry[sel/ENTRIES]->u.analog.sensitivity = val;
 			}
+			else if ((sel % ENTRIES) == 3)
+			{
+				/* center */
+				int val = entry[sel/ENTRIES]->u.analog.center;
+
+				val = !val;
+
+				entry[sel/ENTRIES]->u.analog.center = val;
+			}
+
+			/* AdvanceMAME: Store the port changes */
+			osd_customize_analogport_post_game(Machine->input_ports_default + (entry[sel/ENTRIES] - Machine->input_ports), entry[sel/ENTRIES]);
 		}
 	}
 
 	if (input_ui_pressed_repeat(IPT_UI_RIGHT,8))
 	{
@@ -2195,10 +2246,22 @@
 
 				val ++;
 				if (val > 255) val = 255;
 				entry[sel/ENTRIES]->u.analog.sensitivity = val;
 			}
+			else if ((sel % ENTRIES) == 3)
+			{
+				/* center */
+				int val = entry[sel/ENTRIES]->u.analog.center;
+
+				val = !val;
+
+				entry[sel/ENTRIES]->u.analog.center = val;
+			}
+
+			/* AdvanceMAME: Store the port changes */
+			osd_customize_analogport_post_game(Machine->input_ports_default + (entry[sel/ENTRIES] - Machine->input_ports), entry[sel/ENTRIES]);
 		}
 	}
 
 	if (input_ui_pressed(IPT_UI_SELECT))
 	{
@@ -2502,14 +2565,16 @@
 
 int showgamewarnings(struct mame_bitmap *bitmap)
 {
 	int i;
 	char buf[2048];
+	unsigned mask = GAME_NOT_WORKING | GAME_UNEMULATED_PROTECTION | GAME_WRONG_COLORS | GAME_NO_SOUND;
 
-	if (Machine->gamedrv->flags &
-			(GAME_NOT_WORKING | GAME_UNEMULATED_PROTECTION | GAME_WRONG_COLORS | GAME_IMPERFECT_COLORS |
-			  GAME_NO_SOUND | GAME_IMPERFECT_SOUND | GAME_IMPERFECT_GRAPHICS | GAME_NO_COCKTAIL))
+	if (!options.skip_gameinfo)
+		mask |= GAME_IMPERFECT_COLORS | GAME_IMPERFECT_SOUND | GAME_IMPERFECT_GRAPHICS | GAME_NO_COCKTAIL;
+
+	if ((Machine->gamedrv->flags & mask) != 0)
 	{
 		int done;
 
 		strcpy(buf, ui_getstring (UI_knownproblems));
 		strcat(buf, "\n\n");
@@ -2707,10 +2772,13 @@
 }
 
 /* Display lines from buffer, starting with line 'scroll', in a width x height text window */
 static void display_scroll_message (struct mame_bitmap *bitmap, int *scroll, int width, int height, char *buf)
 {
+#if 1 /* AdvanceMAME has its ui code */
+	osd_ui_scroll(buf, scroll);
+#else
 	struct DisplayText dt[256];
 	int curr_dt = 0;
 	const char *uparrow = ui_getstring (UI_uparrow);
 	const char *downarrow = ui_getstring (UI_downarrow);
 	char textcopy[2048];
@@ -2813,10 +2881,11 @@
 	}
 
 	dt[curr_dt].text = 0;	/* terminate array */
 
 	displaytext(bitmap,dt);
+#endif
 }
 
 
 /* Display text entry for current driver from history.dat and mameinfo.dat. */
 static int displayhistory (struct mame_bitmap *bitmap, int selected)
@@ -2844,11 +2913,13 @@
 		{
 			/* try to load entry */
 			if (load_driver_history (Machine->gamedrv, buf, bufsize) == 0)
 			{
 				scroll = 0;
+#if 0 /* AdvanceMAME: The text is internally wrapped */
 				wordwrap_text_buffer (buf, maxcols);
+#endif
 				strcat(buf,"\n\t");
 				strcat(buf,ui_getstring (UI_lefthilight));
 				strcat(buf," ");
 				strcat(buf,ui_getstring (UI_returntomain));
 				strcat(buf," ");
@@ -3067,16 +3138,16 @@
 
 
 #ifndef MESS
 enum { UI_SWITCH = 0,UI_DEFCODE,UI_CODE,UI_ANALOG,UI_CALIBRATE,
 		UI_STATS,UI_GAMEINFO, UI_HISTORY,
-		UI_CHEAT,UI_RESET,UI_MEMCARD,UI_EXIT };
+		UI_CHEAT,UI_RESET,UI_MEMCARD,UI_EXIT,UI_OSD };
 #else
 enum { UI_SWITCH = 0,UI_DEFCODE,UI_CODE,UI_ANALOG,UI_CALIBRATE,
 		UI_GAMEINFO, UI_IMAGEINFO,UI_FILEMANAGER,UI_TAPECONTROL,
 		UI_HISTORY,UI_CHEAT,UI_RESET,UI_MEMCARD,UI_EXIT,
-		UI_CONFIGURATION, UI_CATEGORIES };
+		UI_CONFIGURATION, UI_CATEGORIES,UI_OSD };
 #endif
 
 
 #define MAX_SETUPMENU_ITEMS 20
 static const char *menu_item[MAX_SETUPMENU_ITEMS];
@@ -3211,10 +3282,11 @@
 	}
 #endif
 #endif
 #endif
 
+	append_menu(UI_osdmenu, UI_OSD);
 	append_menu(UI_resetgame, UI_RESET);
 	append_menu(UI_returntogame, UI_EXIT);
 	menu_item[menu_total] = 0; /* terminate array */
 }
 
@@ -3279,10 +3351,13 @@
 				res = displayhistory(bitmap, sel >> SEL_BITS);
 				break;
 			case UI_CHEAT:
 				res = cheat_menu(bitmap, sel >> SEL_BITS);
 				break;
+			case UI_OSD :
+				res = osd_menu(bitmap, sel >> SEL_BITS);
+				break;
 #ifndef MESS
 #ifndef TINY_COMPILE
 #ifndef MMSND
 			case UI_MEMCARD:
 				res = memcard_menu(bitmap, sel >> SEL_BITS);
@@ -3333,10 +3408,11 @@
 			case UI_CATEGORIES:
 #endif /* !MESS */
 			case UI_HISTORY:
 			case UI_CHEAT:
 			case UI_MEMCARD:
+			case UI_OSD :
 				sel |= 1 << SEL_BITS;
 				schedule_full_refresh();
 				break;
 
 			case UI_RESET:
@@ -3373,10 +3449,13 @@
 
 *********************************************************************/
 
 static void displayosd(struct mame_bitmap *bitmap,const char *text,int percentage,int default_percentage)
 {
+#if 1 /* AdvanceMAME has its ui code */
+	osd_ui_osd(text, percentage, default_percentage);
+#else
 	struct DisplayText dt[2];
 	int avail;
 
 
 	avail = (uirotwidth / uirotcharwidth) * 19 / 20;
@@ -3398,10 +3477,11 @@
 	dt[0].color = UI_COLOR_NORMAL;
 	dt[0].x = (uirotwidth - uirotcharwidth * strlen(text)) / 2;
 	dt[0].y = (uirotheight - 2*uirotcharheight) + 2;
 	dt[1].text = 0; /* terminate array */
 	displaytext(bitmap,dt);
+#endif
 }
 
 static void onscrd_adjuster(struct mame_bitmap *bitmap,int increment,int arg)
 {
 	struct InputPort *in = &Machine->input_ports[arg];
@@ -3431,17 +3511,17 @@
 	if (increment)
 	{
 		attenuation = osd_get_mastervolume();
 		attenuation += increment;
 		if (attenuation > 0) attenuation = 0;
-		if (attenuation < -32) attenuation = -32;
+		if (attenuation < -40) attenuation = -40;
 		osd_set_mastervolume(attenuation);
 	}
 	attenuation = osd_get_mastervolume();
 
 	sprintf(buf,"%s %3ddB", ui_getstring (UI_volume), attenuation);
-	displayosd(bitmap,buf,100 * (attenuation + 32) / 32,100);
+	displayosd(bitmap,buf,100 * (attenuation + 40) / 40,100);
 }
 
 static void onscrd_mixervol(struct mame_bitmap *bitmap,int increment,int arg)
 {
 	static void *driver = 0;
@@ -3754,10 +3834,13 @@
 *********************************************************************/
 
 
 static void displaymessage(struct mame_bitmap *bitmap,const char *text)
 {
+#if 1 /* AdvanceMAME has its ui code */
+	osd_ui_message(text, 0);
+#else
 	struct DisplayText dt[2];
 	int avail;
 
 
 	if (uirotwidth < uirotcharwidth * strlen(text))
@@ -3777,10 +3860,11 @@
 	dt[0].color = UI_COLOR_NORMAL;
 	dt[0].x = (uirotwidth - uirotcharwidth * strlen(text)) / 2;
 	dt[0].y = uirotheight - 5*uirotcharheight/2;
 	dt[1].text = 0; /* terminate array */
 	displaytext(bitmap,dt);
+#endif
 }
 
 
 static char messagetext[200];
 static int messagecounter;
@@ -3902,10 +3986,11 @@
 	return show_profiler;
 }
 
 void ui_display_fps(struct mame_bitmap *bitmap)
 {
+#if 0 /* AdvanceMAME has its ui code */
 	const char *text, *end;
 	char textbuf[256];
 	int done = 0;
 	int y = 0;
 
@@ -3943,32 +4028,35 @@
 	{
 		showfpstemp--;
 		if (!showfps && showfpstemp == 0)
 			schedule_full_refresh();
 	}
+#endif
 }
 
 
 
 int handle_user_interface(struct mame_bitmap *bitmap)
 {
 #ifdef MESS
 	extern int mess_pause_for_ui;
 #endif
 
+	if (osd_handle_user_interface(bitmap, setup_selected != 0) != 0)
+		return 1;
+
 	/* if the user pressed F12, save the screen to a file */
 	if (input_ui_pressed(IPT_UI_SNAPSHOT))
 		save_screen_snapshot(bitmap);
+	if (input_ui_pressed(IPT_UI_RECORD_START))
+		osd_record_start();
+	if (input_ui_pressed(IPT_UI_RECORD_STOP))
+		osd_record_stop();
 
 	/* This call is for the cheat, it must be called once a frame */
 	if (options.cheat) DoCheat(bitmap);
 
-	/* if the user pressed ESC, stop the emulation */
-	/* but don't quit if the setup menu is on screen */
-	if (setup_selected == 0 && input_ui_pressed(IPT_UI_CANCEL))
-		return 1;
-
 	if (setup_selected == 0 && input_ui_pressed(IPT_UI_CONFIGURE))
 	{
 		setup_selected = -1;
 		if (osd_selected != 0)
 		{
@@ -4078,10 +4166,14 @@
 			profiler_mark(PROFILER_END);
 
 			if (input_ui_pressed(IPT_UI_SNAPSHOT))
 				save_screen_snapshot(bitmap);
 
+			if (input_ui_pressed(IPT_UI_RECORD_START))
+				osd_record_start();
+			if (input_ui_pressed(IPT_UI_RECORD_STOP))
+				osd_record_stop();
 
 			if (input_ui_pressed(IPT_UI_SAVE_STATE))
 				do_loadsave(bitmap, LOADSAVE_SAVE);
 
 			if (input_ui_pressed(IPT_UI_LOAD_STATE))
@@ -4090,11 +4182,11 @@
 			/* if the user pressed F4, show the character set */
 			if (input_ui_pressed(IPT_UI_SHOW_GFX))
 				showcharset(bitmap);
 
 			if (setup_selected == 0 && input_ui_pressed(IPT_UI_CANCEL))
-				return 1;
+				break;
 
 			if (setup_selected == 0 && input_ui_pressed(IPT_UI_CONFIGURE))
 			{
 				setup_selected = -1;
 				if (osd_selected != 0)
@@ -4173,16 +4265,18 @@
 	}
 
 	if (show_profiler) profiler_show(bitmap);
 
 
+#if 0 /* AdvanceMAME: The show_fps action is managed by the osd code */
 	/* show FPS display? */
 	if (input_ui_pressed(IPT_UI_SHOW_FPS))
 	{
 		/* toggle fps */
 		ui_show_fps_set(!ui_show_fps_get());
 	}
+#endif
 
 
 	/* if the user pressed F4, show the character set */
 	if (input_ui_pressed(IPT_UI_SHOW_GFX))
 	{
diff -U 5 --new-file --recursive src.ori/vidhrdw/voodoo.c src/vidhrdw/voodoo.c
--- src.ori/vidhrdw/voodoo.c	2004-06-27 18:40:46.000000000 +0200
+++ src/vidhrdw/voodoo.c	2004-07-11 14:44:56.000000000 +0200
@@ -11,11 +11,11 @@
 #include "cpu/mips/mips3.h"
 #include <math.h>
 
 
 /* math trickery */
-#ifndef _WIN32
+#if 1 /* AdvanceMAME: Use always the portable implementation */
 #define SETUP_FPU()
 #define RESTORE_FPU()
 #define TRUNC_TO_INT(f) (float) (floor(f))
 #else
 #include <float.h>
diff -U 5 --new-file --recursive src.ori/x86drc.c src/x86drc.c
--- src.ori/x86drc.c	2004-06-27 18:40:38.000000000 +0200
+++ src/x86drc.c	2004-07-11 14:44:56.000000000 +0200
@@ -677,10 +677,11 @@
 
 
 /*------------------------------------------------------------------
 	drc_x86_get_features()
 ------------------------------------------------------------------*/
+#if 0
 UINT32 drc_x86_get_features(void)
 {
 	UINT32 features = 0;
 #ifdef _MSC_VER
 	__asm 
@@ -706,10 +707,11 @@
 	: "%ebx", "%ecx", "%edx"	/* clobbers ebx, ecx and edx */
 	);
 #endif /* MSC_VER */
 	return features;
 }
+#endif
 
 
 
 /*------------------------------------------------------------------
 	log_dispatch
