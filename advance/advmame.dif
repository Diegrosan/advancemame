diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui src.ori/advance.pat src/advance.pat
--- src.ori/advance.pat	1970-01-01 01:00:00.000000000 +0100
+++ src/advance.pat	2002-11-15 22:19:50.000000000 +0100
@@ -0,0 +1 @@
+These files are patched for the use with the Advance emulator.
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui src.ori/common.c src/common.c
--- src.ori/common.c	2002-11-02 14:53:00.000000000 +0100
+++ src/common.c	2002-12-18 19:25:36.000000000 +0100
@@ -429,17 +429,11 @@
 	coin_counter_w - sets input for coin counter
 -------------------------------------------------*/
 
 void coin_counter_w(int num,int on)
 {
-	if (num >= COIN_COUNTERS) return;
-	/* Count it only if the data has changed from 0 to non-zero */
-	if (on && (lastcoin[num] == 0))
-	{
-		coins[num]++;
-	}
-	lastcoin[num] = on;
+	/* moved in update_input_ports */
 }
 
 
 /*-------------------------------------------------
 	coin_lockout_w - locks out one coin input
@@ -1134,11 +1128,11 @@
 		}
 		else
 			strcat(romdata->errorbuf, "WARNING: the game might not run correctly.\n");
 
 		/* display the result */
-		printf("%s", romdata->errorbuf);
+		osd_display_loading_rom_message(romdata->errorbuf, -1, -1);
 
 		/* if we're not getting out of here, wait for a keypress */
 		if (!options.gui_host && !bailing)
 		{
 			int k;
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui src.ori/common.h src/common.h
--- src.ori/common.h	2002-11-02 14:53:28.000000000 +0100
+++ src/common.h	2002-11-16 17:04:14.000000000 +0100
@@ -281,17 +281,19 @@
 #define ROM_REGION16_BE(length,type,flags)			ROM_REGION(length, type, (flags) | ROMREGION_16BIT | ROMREGION_BE)
 #define ROM_REGION32_LE(length,type,flags)			ROM_REGION(length, type, (flags) | ROMREGION_32BIT | ROMREGION_LE)
 #define ROM_REGION32_BE(length,type,flags)			ROM_REGION(length, type, (flags) | ROMREGION_32BIT | ROMREGION_BE)
 
 /* ----- core ROM loading macros ----- */
-#define ROMX_LOAD(name,offset,length,crc,flags)		{ name, offset, length, flags, crc },
+#define ROMX_LOAD_P(name,offset,length,crc,flags)		{ name, offset, length, flags, crc },
+#define ROMX_LOAD(name,offset,length,crc,flags)		{ name "\0", offset, length, flags, crc },
+#define ROM_LOAD_P(name,offset,length,crc)			ROMX_LOAD_P(name, offset, length, crc, 0)
 #define ROM_LOAD(name,offset,length,crc)			ROMX_LOAD(name, offset, length, crc, 0)
 #define ROM_LOAD_OPTIONAL(name,offset,length,crc)	ROMX_LOAD(name, offset, length, crc, ROM_OPTIONAL)
-#define ROM_CONTINUE(offset,length)					ROMX_LOAD(ROMENTRY_CONTINUE, offset, length, 0, ROM_INHERITFLAGS)
-#define ROM_RELOAD(offset,length)					ROMX_LOAD(ROMENTRY_RELOAD, offset, length, 0, ROM_INHERITFLAGS)
-#define ROM_FILL(offset,length,value)				ROM_LOAD(ROMENTRY_FILL, offset, length, value)
-#define ROM_COPY(rgn,srcoffset,offset,length)		ROMX_LOAD(ROMENTRY_COPY, offset, length, srcoffset, (rgn) << 24)
+#define ROM_CONTINUE(offset,length)					ROMX_LOAD_P(ROMENTRY_CONTINUE, offset, length, 0, ROM_INHERITFLAGS)
+#define ROM_RELOAD(offset,length)					ROMX_LOAD_P(ROMENTRY_RELOAD, offset, length, 0, ROM_INHERITFLAGS)
+#define ROM_FILL(offset,length,value)				ROM_LOAD_P(ROMENTRY_FILL, offset, length, value)
+#define ROM_COPY(rgn,srcoffset,offset,length)		ROMX_LOAD_P(ROMENTRY_COPY, offset, length, srcoffset, (rgn) << 24)
 
 /* ----- nibble loading macros ----- */
 #define ROM_LOAD_NIB_HIGH(name,offset,length,crc)	ROMX_LOAD(name, offset, length, crc, ROM_NIBBLE | ROM_SHIFT_NIBBLE_HI)
 #define ROM_LOAD_NIB_LOW(name,offset,length,crc)	ROMX_LOAD(name, offset, length, crc, ROM_NIBBLE | ROM_SHIFT_NIBBLE_LO)
 
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui src.ori/cpu/i8085/i8085.c src/cpu/i8085/i8085.c
--- src.ori/cpu/i8085/i8085.c	2002-08-25 00:51:26.000000000 +0200
+++ src/cpu/i8085/i8085.c	2002-11-15 22:19:50.000000000 +0100
@@ -61,10 +61,16 @@
  *
  *****************************************************************************/
 
 /*int survival_prot = 0; */
 
+#if defined(__GNUC__) && __GNUC__ >= 3
+/* Disable all the asm macro and the big switch */
+#undef X86_ASM
+#define BIG_SWITCH 0
+#endif
+
 #define VERBOSE 0
 
 #include "driver.h"
 #include "state.h"
 #include "osd_cpu.h"
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui src.ori/cpu/m68000/make68k.c src/cpu/m68000/make68k.c
--- src.ori/cpu/m68000/make68k.c	2002-10-28 21:48:50.000000000 +0100
+++ src/cpu/m68000/make68k.c	2002-11-15 22:19:50.000000000 +0100
@@ -188,11 +188,11 @@
 
 
 #define NORMAL 0
 #define PCREL  1
 
-#ifdef __ELF__
+#if defined(USE_OBJ_ELF)
 #define PREF ""
 #else
 #define PREF "_"
 #endif
 
@@ -249,17 +249,17 @@
 
 
 
 /* External register preservation */
 
-#ifdef DOS
+#if defined(USE_COMPILER_GNUC)
 
 /* Registers normally saved around C routines anyway */
 /* GCC 2.9.1 (dos) seems to preserve EBX,EDI and EBP */
 static char SavedRegs[] = "-B--SDB";
 
-#elif defined(WIN32)
+#elif defined(USE_COMPILER_VISUALC)
 
 /* visual C++, win32, says it preserves ebx, edi, esi, and ebp */
 /* ---------- VC++ deosn't preserve EDI? (Kenjo, 110399) ---------- */
 static char SavedRegs[] = "-B--S-B";
 
@@ -8038,11 +8038,11 @@
 	fprintf(fp, "\t\tDW   0,0,0\n\n");
 
 
 /* If Win32, put the table area in .data section (Kenjo) */
 
-#ifdef WIN32
+#if defined(USE_OS_WINDOWS)
 
 	fprintf(fp, "%s_OPCODETABLE\tTIMES  65536  DD 0\n\n", CPUtype);
 
 #else
 
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui src.ori/cpu/z80/z80.c src/cpu/z80/z80.c
--- src.ori/cpu/z80/z80.c	2002-10-01 22:09:34.000000000 +0200
+++ src/cpu/z80/z80.c	2002-11-15 22:19:50.000000000 +0100
@@ -80,10 +80,16 @@
 
 #ifdef Z80_MSX
 #include "z80_msx.h"
 #endif
 
+#if defined(__GNUC__) && __GNUC__ >= 3
+/* Disable all the asm macro and the big switch */
+#undef X86_ASM
+#define BIG_SWITCH 0
+#endif
+
 #define VERBOSE 0
 
 #if VERBOSE
 #define LOG(x)	logerror x
 #else
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui src.ori/cpuexec.c src/cpuexec.c
--- src.ori/cpuexec.c	2002-10-21 15:02:40.000000000 +0200
+++ src/cpuexec.c	2002-11-15 22:19:50.000000000 +0100
@@ -233,10 +233,13 @@
 	watchdog_counter = -1;
 
 	/* reset sound chips */
 	sound_reset();
 
+	/* reset the osd level */
+	osd_reset();
+
 	/* first pass over CPUs */
 	for (cpunum = 0; cpunum < cpu_gettotalcpu(); cpunum++)
 	{
 		/* enable all CPUs (except for audio CPUs if the sound is off) */
 		if (!(Machine->drv->cpu[cpunum].cpu_type & CPU_AUDIO_CPU) || Machine->sample_rate != 0)
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui src.ori/drivers/flower.c src/drivers/flower.c
--- src.ori/drivers/flower.c	2002-11-01 11:20:46.000000000 +0100
+++ src/drivers/flower.c	2002-11-15 23:32:20.000000000 +0100
@@ -35,11 +35,11 @@
 12       16E         "       "
 13       17E         "       "
 14       19E         "       "
 */
 
-#include "vidhrdw\generic.h"
+#include "vidhrdw/generic.h"
 
 data8_t *flower_sharedram;
 
 READ_HANDLER( flower_sharedram_r );
 WRITE_HANDLER( flower_sharedram_w );
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui src.ori/drivers/neogeo.c src/drivers/neogeo.c
--- src.ori/drivers/neogeo.c	2002-10-25 17:25:00.000000000 +0200
+++ src/drivers/neogeo.c	2002-11-15 22:19:58.000000000 +0100
@@ -289,11 +289,11 @@
 			}
 			fc++;
 		}
 
 		if (irq2control & IRQ2CTRL_ENABLE)
-			usrintf_showmessage("IRQ2 enabled, need raster driver");
+			/* usrintf_showmessage("IRQ2 enabled, need raster driver") */ ;
 
 		/* return a standard vblank interrupt */
 		vblank_int = 1;	   /* vertical blank */
 	}
 
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui src.ori/drivers/polyplay.c src/drivers/polyplay.c
--- src.ori/drivers/polyplay.c	2002-05-11 13:58:46.000000000 +0200
+++ src/drivers/polyplay.c	2003-01-06 13:57:38.000000000 +0100
@@ -1,37 +1,37 @@
 /***************************************************************************
 
-      Poly-Play
+	  Poly-Play
 	  (c) 1985 by VEB Polytechnik Karl-Marx-Stadt
 
-      driver by Martin Buchholz (buchholz@mail.uni-greifswald.de)
+	  driver by Martin Buchholz (buchholz@mail.uni-greifswald.de)
 
-      Very special thanks to the following people, each one of them spent
+	  Very special thanks to the following people, each one of them spent
 	  some of their spare time to make this driver working:
 	  - Juergen Oppermann and Volker Hann for electronical assistance,
 	    repair work and ROM dumping.
 	  - Jan-Ole Christian from the Videogamemuseum in Berlin, which houses
 	    one of the last existing Poly-Play arcade automatons. He also
-		provided me with schematics and service manuals.
+	    provided me with schematics and service manuals.
 
 
 memory map:
 
 0000 - 03ff OS ROM
 0400 - 07ff Game ROM (used for Abfahrtslauf)
 0800 - 0cff Menu Screen ROM
 
 0d00 - 0fff work RAM
 
-1000 - 4fff GAME ROM (pcb 2 - Abfahrtslauf          (1000 - 1bff),
-                              Hirschjagd            (1c00 - 27ff),
-							  Hase und Wolf         (2800 - 3fff),
+1000 - 4fff GAME ROM (pcb 2 - Abfahrtslauf          (1000 - 1bff)
+                              Hirschjagd            (1c00 - 27ff)
+                              Hase und Wolf         (2800 - 3fff)
                               Schmetterlingsfang    (4000 - 4fff)
 5000 - 8fff GAME ROM (pcb 1 - Schiessbude           (5000 - 5fff)
                               Autorennen            (6000 - 73ff)
-							  opto-akust. Merkspiel (7400 - 7fff)
-							  Wasserrohrbruch       (8000 - 8fff)
+                              opto-akust. Merkspiel (7400 - 7fff)
+                              Wasserrohrbruch       (8000 - 8fff)
 
 e800 - ebff character ROM (chr 00..7f) 1 bit per pixel
 ec00 - f7ff character RAM (chr 80..ff) 3 bit per pixel
 f800 - ffff video RAM
 
@@ -52,11 +52,11 @@
           bit 6 = Summe Spiele
           bit 7 = coinage (+IRQ to make the game acknowledge it)
 
 85        bit 0-4 = light organ (unemulated :)) )
           bit 5-7 = sound parameter (unemulated, it's very difficult to
-		            figure out how those work)
+                    figure out how those work)
 
 86        ???
 
 87        PIO Control register
 
@@ -80,46 +80,40 @@
 
 #include "driver.h"
 #include "vidhrdw/generic.h"
 #include "cpu/z80/z80.h"
 
-static unsigned char *polyplay_ram;
-
-void polyplay_reset(void);
-
 /* video hardware access */
 extern unsigned char *polyplay_characterram;
 PALETTE_INIT( polyplay );
 VIDEO_UPDATE( polyplay );
 READ_HANDLER( polyplay_characterram_r );
 WRITE_HANDLER( polyplay_characterram_w );
 
 /* I/O Port handling */
-READ_HANDLER( polyplay_input_read );
-READ_HANDLER( polyplay_random_read );
+static READ_HANDLER( polyplay_random_read );
 
 /* sound handling */
-void poly_sound(void);
 void set_channel1(int active);
 void set_channel2(int active);
-int prescale1, prescale2;
+static int prescale1;
+static int prescale2;
 static int channel1_active;
 static int channel1_const;
 static int channel2_active;
 static int channel2_const;
-static DRIVER_INIT( polyplay_sound );
 void play_channel1(int data);
 void play_channel2(int data);
 int  polyplay_sh_start(const struct MachineSound *msound);
 void polyplay_sh_stop(void);
 void polyplay_sh_update(void);
 
 /* timer handling */
-static void polyplay_timer(int param);
-int timer2_active;
-WRITE_HANDLER( polyplay_start_timer2 );
-WRITE_HANDLER( polyplay_sound_channel );
+static void timer_callback(int param);
+static void* polyplay_timer;
+static WRITE_HANDLER( polyplay_start_timer2 );
+static WRITE_HANDLER( polyplay_sound_channel );
 
 
 /* Polyplay Sound Interface */
 static struct CustomSound_interface custom_interface =
 {
@@ -127,59 +121,75 @@
 	polyplay_sh_stop,
 	polyplay_sh_update
 };
 
 
-MACHINE_INIT( polyplay )
+static MACHINE_INIT( polyplay )
 {
 	channel1_active = 0;
 	channel1_const = 0;
 	channel2_active = 0;
 	channel2_const = 0;
+
 	set_channel1(0);
 	play_channel1(0);
 	set_channel2(0);
 	play_channel2(0);
+
+	polyplay_timer = timer_alloc(timer_callback);
 }
 
 
-/* work RAM access */
-WRITE_HANDLER( polyplay_ram_w )
+static INTERRUPT_GEN( periodic_interrupt )
 {
-	polyplay_ram[offset] = data;
+	cpu_set_irq_line_and_vector(0, 0, HOLD_LINE, 0x4e);
 }
 
-READ_HANDLER( polyplay_ram_r )
+
+static INTERRUPT_GEN( coin_interrupt )
 {
-	return polyplay_ram[offset];
+	static int last = 0;
+
+	if (readinputport(0) & 0x80)
+	{
+		last = 0;
+	}
+	else
+	{
+		if (last == 0)    /* coin inserted */
+		{
+			cpu_set_irq_line_and_vector(0, 0, HOLD_LINE, 0x50);
+		}
+
+		last = 1;
+	}
 }
 
+
 /* memory mapping */
 static MEMORY_READ_START( polyplay_readmem )
 	{ 0x0000, 0x0bff, MRA_ROM },
-	{ 0x0c00, 0x0fff, polyplay_ram_r },
+	{ 0x0c00, 0x0fff, MRA_RAM },
 	{ 0x1000, 0x8fff, MRA_ROM },
-
-	{ 0xe800, 0xebff, MRA_ROM},
+	{ 0xe800, 0xebff, MRA_ROM },
 	{ 0xec00, 0xf7ff, polyplay_characterram_r },
 	{ 0xf800, 0xffff, videoram_r },
 MEMORY_END
 
 static MEMORY_WRITE_START( polyplay_writemem )
 	{ 0x0000, 0x0bff, MWA_ROM },
-	{ 0x0c00, 0x0fff, polyplay_ram_w, &polyplay_ram },
+	{ 0x0c00, 0x0fff, MWA_RAM },
 	{ 0x1000, 0x8fff, MWA_ROM },
-
 	{ 0xe800, 0xebff, MWA_ROM },
 	{ 0xec00, 0xf7ff, polyplay_characterram_w, &polyplay_characterram },
 	{ 0xf800, 0xffff, videoram_w, &videoram, &videoram_size },
 MEMORY_END
 
 
 /* port mapping */
 static PORT_READ_START( readport_polyplay )
-	{ 0x84, 0x84, polyplay_input_read },
+	{ 0x84, 0x84, input_port_0_r },
 	{ 0x83, 0x83, polyplay_random_read },
 PORT_END
 
 static PORT_WRITE_START( writeport_polyplay )
 	{ 0x80, 0x81, polyplay_sound_channel },
@@ -193,15 +203,15 @@
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT  | IPF_8WAY )
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_UP    | IPF_8WAY )
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN  | IPF_8WAY )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BITX(0x40, IP_ACTIVE_LOW, IPT_SERVICE, "Bookkeeping Info", KEYCODE_F2, IP_JOY_NONE )
-	PORT_BIT_IMPULSE( 0x80, IP_ACTIVE_LOW, IPT_COIN1, 10)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_COIN1 )
 INPUT_PORTS_END
 
 
-WRITE_HANDLER( polyplay_sound_channel )
+static WRITE_HANDLER( polyplay_sound_channel )
 {
 	switch(offset) {
 	case 0x00:
 		if (channel1_const) {
 			if (data <= 1) {
@@ -245,56 +255,51 @@
 		}
 		break;
 	}
 }
 
-WRITE_HANDLER( polyplay_start_timer2 )
+static WRITE_HANDLER( polyplay_start_timer2 )
 {
-	if (data == 0x03) {
-		timer2_active = 0;
-	}
-	else {
-		if (data == 0xb5) {
-			timer_set(TIME_IN_HZ(40), 1, polyplay_timer);
-			timer2_active = 1;
-		}
-	}
+	if (data == 0x03) 
+		timer_adjust(polyplay_timer, TIME_NEVER, 0, 0);
+
+	if (data == 0xb5)
+		timer_adjust(polyplay_timer, TIME_IN_HZ(40), 0, TIME_IN_HZ(40));
 }
 
-/* random number generator */
-READ_HANDLER( polyplay_random_read )
+static READ_HANDLER( polyplay_random_read )
 {
-	return rand() % 0xff;
+	return rand() & 0xff;
 }
 
-/* graphic sturctures */
+/* graphic structures */
 static struct GfxLayout charlayout_1_bit =
 {
 	8,8,	/* 8*8 characters */
 	128,	/* 128 characters */
-	1,	    /* 1 bit per pixel */
+	1,  	/* 1 bit per pixel */
 	{ 0 },
-	{ 0, 1, 2, 3, 4, 5, 6, 7 },	/* pretty straightforward layout */
+	{ 0, 1, 2, 3, 4, 5, 6, 7 },
 	{ 0*8, 1*8, 2*8, 3*8, 4*8, 5*8, 6*8, 7*8 },
 	8*8	/* every char takes 8 consecutive bytes */
 };
 
 static struct GfxLayout charlayout_3_bit =
 {
 	8,8,	/* 8*8 characters */
 	128,	/* 128 characters */
-	3,	    /* 3 bit per pixel */
+	3,  	/* 3 bit per pixel */
 	{ 0, 128*8*8, 128*8*8 + 128*8*8 },    /* offset for each bitplane */
-	{ 0, 1, 2, 3, 4, 5, 6, 7 },	/* pretty straightforward layout */
+	{ 0, 1, 2, 3, 4, 5, 6, 7 },
 	{ 0*8, 1*8, 2*8, 3*8, 4*8, 5*8, 6*8, 7*8 },
 	8*8	/* every char takes 8 consecutive bytes */
 };
 
 static struct GfxDecodeInfo gfxdecodeinfo[] =
 {
-	{ 0, 0xe800, &charlayout_1_bit, 0, 1 },
-	{ 0, 0xec00, &charlayout_3_bit, 2, 1 },
+	{ REGION_CPU1, 0xe800, &charlayout_1_bit, 0, 1 },
+	{ REGION_CPU1, 0xec00, &charlayout_3_bit, 2, 1 },
 	{ -1 }	/* end of array */
 };
 
 
 /* the machine driver */
@@ -303,13 +308,14 @@
 
 	/* basic machine hardware */
 	MDRV_CPU_ADD(Z80, 9830400/4)
 	MDRV_CPU_MEMORY(polyplay_readmem,polyplay_writemem)
 	MDRV_CPU_PORTS(readport_polyplay,writeport_polyplay)
+	MDRV_CPU_PERIODIC_INT(periodic_interrupt,75)
+	MDRV_CPU_VBLANK_INT(coin_interrupt,1)
 
 	MDRV_FRAMES_PER_SECOND(50)
-	MDRV_VBLANK_DURATION(0)	/* frames per second, vblank duration */
 
 	MDRV_MACHINE_INIT(polyplay)
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES(VIDEO_TYPE_RASTER)
@@ -325,11 +331,10 @@
 	/* sound hardware */
 	MDRV_SOUND_ADD(CUSTOM, custom_interface)
 MACHINE_DRIVER_END
 
 
-
 /* ROM loading and mapping */
 ROM_START( polyplay )
 	ROM_REGION( 0x10000, REGION_CPU1, 0 )	/* 64k for code */
 	ROM_LOAD( "cpu_0000.37",       0x0000, 0x0400, 0x87884c5f )
 	ROM_LOAD( "cpu_0400.36",       0x0400, 0x0400, 0xd5c84829 )
@@ -368,46 +373,12 @@
 	ROM_LOAD( "1_-_8c00.21",       0x8c00, 0x0400, 0x0c7dec2d )
 	ROM_LOAD( "char.1",            0xe800, 0x0400, 0x5242dd6b )
 ROM_END
 
 
-/* interrupt handling, the game runs in IM 2 */
-READ_HANDLER( polyplay_input_read )
-{
-	int inp = input_port_0_r(offset);
-
-	if ((inp & 0x80) == 0) {    /* Coin inserted */
-		cpu_set_irq_line_and_vector(0, 0, HOLD_LINE, 0x50);
-		coin_counter_w(0, 1);
-		timer_set(TIME_IN_SEC(1), 2, polyplay_timer);
-	}
-
-	return inp;
-}
-
-static void polyplay_timer(int param)
-{
-	switch(param) {
-	case 0:
-		cpu_set_irq_line_and_vector(0, 0, HOLD_LINE, 0x4e);
-		break;
-	case 1:
-		if (timer2_active) {
-			timer_set(TIME_IN_HZ(40), 1, polyplay_timer);
-			cpu_set_irq_line_and_vector(0, 0, HOLD_LINE, 0x4c);
-		}
-		break;
-	case 2:
-		coin_counter_w(0, 0);
-		break;
-	}
-}
-
-/* initialization */
-static DRIVER_INIT( polyplay_sound )
+static void timer_callback(int param)
 {
-	timer_pulse(TIME_IN_HZ(75), 0, polyplay_timer);
-	timer2_active = 0;
+	cpu_set_irq_line_and_vector(0, 0, HOLD_LINE, 0x4c);
 }
 
 /* game driver */
-GAME( 1985, polyplay, 0, polyplay, polyplay, polyplay_sound, ROT0, "VEB Polytechnik Karl-Marx-Stadt", "Poly-Play" )
+GAME( 1985, polyplay, 0, polyplay, polyplay, 0, ROT0, "VEB Polytechnik Karl-Marx-Stadt", "Poly-Play" )
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui src.ori/inptport.c src/inptport.c
--- src.ori/inptport.c	2002-07-22 11:41:32.000000000 +0200
+++ src/inptport.c	2003-01-05 14:56:42.000000000 +0100
@@ -147,10 +147,13 @@
 	{ IPT_UI_SHOW_PROFILER,     "Show Profiler",		SEQ_DEF_2(KEYCODE_F11, KEYCODE_LSHIFT) },
 #ifdef MESS
 	{ IPT_UI_TOGGLE_UI,         "UI Toggle",			SEQ_DEF_1(KEYCODE_SCRLOCK) },
 #endif
 	{ IPT_UI_SNAPSHOT,          "Save Snapshot",		SEQ_DEF_1(KEYCODE_F12) },
+	{ IPT_UI_RECORD_START,      "Record Start", SEQ_DEF_2(KEYCODE_ENTER,KEYCODE_LCONTROL) },
+	{ IPT_UI_RECORD_STOP,       "Record Stop", SEQ_DEF_3(KEYCODE_ENTER,CODE_NOT,KEYCODE_LCONTROL) },
+	{ IPT_UI_TURBO,             "Turbo", SEQ_DEF_1(KEYCODE_ASTERISK) },
 	{ IPT_UI_TOGGLE_CHEAT,      "Toggle Cheat",			SEQ_DEF_1(KEYCODE_F6) },
 	{ IPT_UI_UP,                "UI Up",				SEQ_DEF_3(KEYCODE_UP, CODE_OR, JOYCODE_1_UP) },
 	{ IPT_UI_DOWN,              "UI Down",				SEQ_DEF_3(KEYCODE_DOWN, CODE_OR, JOYCODE_1_DOWN) },
 	{ IPT_UI_LEFT,              "UI Left",				SEQ_DEF_3(KEYCODE_LEFT, CODE_OR, JOYCODE_1_LEFT) },
 	{ IPT_UI_RIGHT,             "UI Right",				SEQ_DEF_3(KEYCODE_RIGHT, CODE_OR, JOYCODE_1_RIGHT) },
@@ -158,10 +161,12 @@
 	{ IPT_UI_CANCEL,            "UI Cancel",			SEQ_DEF_1(KEYCODE_ESC) },
 	{ IPT_UI_PAN_UP,            "Pan Up",				SEQ_DEF_3(KEYCODE_PGUP, CODE_NOT, KEYCODE_LSHIFT) },
 	{ IPT_UI_PAN_DOWN,          "Pan Down",				SEQ_DEF_3(KEYCODE_PGDN, CODE_NOT, KEYCODE_LSHIFT) },
 	{ IPT_UI_PAN_LEFT,          "Pan Left",				SEQ_DEF_2(KEYCODE_PGUP, KEYCODE_LSHIFT) },
 	{ IPT_UI_PAN_RIGHT,         "Pan Right",			SEQ_DEF_2(KEYCODE_PGDN, KEYCODE_LSHIFT) },
+	{ IPT_UI_MODE_NEXT,         "Mode Next",         SEQ_DEF_1(KEYCODE_STOP) },
+	{ IPT_UI_MODE_PRED,         "Mode Pred",         SEQ_DEF_1(KEYCODE_COMMA) },
 	{ IPT_UI_TOGGLE_DEBUG,      "Toggle Debugger",		SEQ_DEF_1(KEYCODE_F5) },
 	{ IPT_UI_SAVE_STATE,        "Save State",			SEQ_DEF_2(KEYCODE_F7, KEYCODE_LSHIFT) },
 	{ IPT_UI_LOAD_STATE,        "Load State",			SEQ_DEF_3(KEYCODE_F7, CODE_NOT, KEYCODE_LSHIFT) },
 	{ IPT_UI_ADD_CHEAT,			"Add Cheat",			SEQ_DEF_1(KEYCODE_A) },
 	{ IPT_UI_DELETE_CHEAT,		"Delete Cheat",			SEQ_DEF_1(KEYCODE_D) },
@@ -1151,10 +1156,12 @@
 		if (readint(f,&dispensed_tickets) != 0)
 			goto getout;
 
 		mixer_read_config(f);
 
+		osd_customize_inputport_current(Machine->input_ports);
+
 getout:
 		osd_fclose(f);
 	}
 
 	/* All analog ports need initialization */
@@ -1694,14 +1701,16 @@
 		int new, prev;
 
 		/* center stick */
 		if ((delta == 0) && (in->type & IPF_CENTER))
 		{
-			if (current > default_value)
-			delta = -100 / sensitivity;
-			if (current < default_value)
-			delta = 100 / sensitivity;
+			/* return backward at middle speed */
+			delta = default_value - current;
+			if (delta < -(keydelta+1)/2)
+				delta = -(keydelta+1)/2;
+			if (delta > (keydelta+1)/2)
+				delta = (keydelta+1)/2;
 		}
 
 		/* An analog joystick which is not at zero position (or has just */
 		/* moved there) takes precedence over all other computations */
 		/* analog_x/y holds values from -128 to 128 (yes, 128, not 127) */
@@ -1959,16 +1968,23 @@
 #define MAX_INPUT_BITS 1024
 	static int impulsecount[MAX_INPUT_BITS];
 	static int waspressed[MAX_INPUT_BITS];
 	static int pbwaspressed[MAX_INPUT_BITS];
 
+	unsigned newcoin[COIN_COUNTERS];
+	unsigned coin;
+
 #ifdef MAME_NET
 	int player;
 #endif /* MAME_NET */
 
 
 profiler_mark(PROFILER_INPUT);
+	
+	/* clear the new coin status */
+	for(coin=0;coin<4;++coin)
+		newcoin[coin] = 0;
 
 	/* clear all the values before proceeding */
 	for (port = 0;port < MAX_INPUT_PORTS;port++)
 	{
 		input_port_value[port] = 0;
@@ -2057,18 +2073,20 @@
 				}
 				else
 				{
 					InputSeq* seq;
 					seq = input_port_seq(in);
-					if (seq_pressed(seq))
+
+					if (osd_input_port_filter(seq_pressed(seq), in->type & (IPF_PLAYERMASK | ~IPF_MASK)))
 					{
-						/* skip if coin input and it's locked out */
-						if ((in->type & ~IPF_MASK) >= IPT_COIN1 &&
-							(in->type & ~IPF_MASK) <= IPT_COIN4 &&
-                            coinlockedout[(in->type & ~IPF_MASK) - IPT_COIN1])
-						{
-							continue;
+						if ((in->type & ~IPF_MASK) >= IPT_COIN1 && (in->type & ~IPF_MASK) <= IPT_COIN4) {
+							unsigned ncoin = (in->type & ~IPF_MASK) - IPT_COIN1;
+							if (coinlockedout[ncoin])
+								continue;
+							if (!lastcoin[ncoin])
+								++coins[ncoin];
+							newcoin[ncoin] = 1;
 						}
 
 						/* if IPF_RESET set, reset the first CPU */
 						if ((in->type & IPF_RESETCPU) && waspressed[ib] == 0 && !playback)
 						{
@@ -2196,10 +2214,14 @@
 #ifdef MAME_NET
 	if ( net_active() && (default_player != NET_SPECTATOR) )
 		net_input_sync((unsigned char *) input_port_value, (unsigned char *) input_port_defaults, MAX_INPUT_PORTS);
 #endif /* MAME_NET */
 
+	/* set the last coin status */
+	for(coin=0;coin<4;++coin)
+		lastcoin[coin] = newcoin[coin];
+	
 profiler_mark(PROFILER_END);
 }
 
 
 
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui src.ori/inptport.h src/inptport.h
--- src.ori/inptport.h	2002-06-30 20:57:44.000000000 +0200
+++ src/inptport.h	2002-11-15 22:19:58.000000000 +0100
@@ -81,10 +81,15 @@
 	IPT_OSD_4,
 	IPT_EXTENSION,	/* this is an extension on the previous InputPort, not a real inputport. */
 					/* It is used to store additional parameters for analog inputs */
 
 	/* the following are special codes for user interface handling - not to be used by drivers! */
+	IPT_UI_MODE_NEXT,
+	IPT_UI_MODE_PRED,
+	IPT_UI_RECORD_START,
+	IPT_UI_RECORD_STOP,
+	IPT_UI_TURBO,
 	IPT_UI_CONFIGURE,
 	IPT_UI_ON_SCREEN_DISPLAY,
 	IPT_UI_PAUSE,
 	IPT_UI_RESET_MACHINE,
 	IPT_UI_SHOW_GFX,
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui src.ori/input.c src/input.c
--- src.ori/input.c	2002-06-30 20:57:54.000000000 +0200
+++ src/input.c	2002-11-15 22:19:58.000000000 +0100
@@ -782,11 +782,11 @@
 {
 	int pressed;
 
 	profiler_mark(PROFILER_INPUT);
 
-	pressed = seq_pressed(input_port_type_seq(code));
+	pressed = osd_input_ui_filter(seq_pressed(input_port_type_seq(code)),code);
 
 	if (pressed)
 	{
 		if (ui_map[code].memory == 0)
 		{
@@ -806,11 +806,11 @@
 	static int counter,inputdelay;
 	int pressed;
 
 	profiler_mark(PROFILER_INPUT);
 
-	pressed = seq_pressed(input_port_type_seq(code));
+	pressed = osd_input_ui_filter(seq_pressed(input_port_type_seq(code)),code);
 
 	if (pressed)
 	{
 		if (ui_map[code].memory == 0)
 		{
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui src.ori/mame.c src/mame.c
--- src.ori/mame.c	2002-11-02 14:54:30.000000000 +0100
+++ src/mame.c	2002-11-15 22:23:02.000000000 +0100
@@ -950,26 +950,20 @@
 	to a given resolution
 -------------------------------------------------*/
 
 static void scale_vectorgames(int gfx_width, int gfx_height, int *width, int *height)
 {
-	double x_scale, y_scale, scale;
-
-	/* compute the scale values */
-	x_scale = (double)gfx_width / (double)(*width);
-	y_scale = (double)gfx_height / (double)(*height);
-
-	/* pick the smaller scale factor */
-	scale = (x_scale < y_scale) ? x_scale : y_scale;
-
-	/* compute the new size */
-	*width = (int)((double)*width * scale);
-	*height = (int)((double)*height * scale);
-
-	/* round to the nearest 4 pixel value */
-	*width &= ~3;
-	*height &= ~3;
+	if (Machine->orientation & ORIENTATION_SWAP_XY)
+	{
+		*width = gfx_height;
+		*height = gfx_width*9/16;
+	}
+	else
+	{
+		*width = gfx_width;
+		*height = gfx_height;
+	}
 }
 
 
 
 /*-------------------------------------------------
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui src.ori/memory.c src/memory.c
--- src.ori/memory.c	2002-10-04 16:28:34.000000000 +0200
+++ src/memory.c	2002-12-18 21:24:16.000000000 +0100
@@ -149,10 +149,11 @@
 
 offs_t						mem_amask;						/* memory address mask */
 static offs_t				port_amask;						/* port address mask */
 
 UINT8 *						cpu_bankbase[STATIC_COUNT];		/* array of bank bases */
+int ext_entries = 0;										/* number of entries ext_memory[] entries used */
 struct ExtMemory			ext_memory[MAX_EXT_MEMORY];		/* externally-allocated memory */
 
 static data32_t				unmap_value;					/* unmapped memory value */
 
 static opbase_handler		opbasefunc;						/* opcode base override */
@@ -269,10 +270,11 @@
 -------------------------------------------------*/
 
 void memory_shutdown(void)
 {
 	struct ExtMemory *ext;
+	int ext_entry;
 	int cpunum;
 
 	/* free all the tables */
 	for (cpunum = 0; cpunum < MAX_CPU; cpunum++ )
 	{
@@ -286,13 +288,18 @@
 			free(cpudata[cpunum].port.write.table);
 	}
 	memset(&cpudata, 0, sizeof(cpudata));
 
 	/* free all the external memory */
-	for (ext = ext_memory; ext->data; ext++)
-		free(ext->data);
+	ext = ext_memory;
+	for( ext_entry = 0; ext_entry < ext_entries; ext_entry++ )
+	{
+		free( ext->data );
+		ext++;
+	}
 	memset(ext_memory, 0, sizeof(ext_memory));
+	ext_entries = 0;
 }
 
 
 /*-------------------------------------------------
 	memory_set_opcode_base - set the base of
@@ -721,17 +728,24 @@
 	and offset
 -------------------------------------------------*/
 
 void *memory_find_base(int cpunum, offs_t offset)
 {
+	int ext_entry;
 	int region = REGION_CPU1 + cpunum;
 	struct ExtMemory *ext;
 
 	/* look in external memory first */
-	for (ext = ext_memory; ext->data; ext++)
+	ext = ext_memory;
+	for( ext_entry = 0; ext_entry < ext_entries; ext_entry++ )
+	{
 		if (ext->region == region && ext->start <= offset && ext->end >= offset)
+		{
 			return (void *)((UINT8 *)ext->data + (offset - ext->start));
+		}
+		ext++;
+	}
 
 	return (UINT8 *)cpudata[cpunum].rambase + offset;
 }
 
 
@@ -1243,10 +1257,12 @@
 static int allocate_memory(void)
 {
 	struct ExtMemory *ext = ext_memory;
 	int cpunum;
 
+	ext_entries = 0;
+
 	/* don't do it for drivers that don't have ROM (MESS needs this) */
 	if (Machine->gamedrv->rom == 0)
 		return 1;
 
 	/* loop over all CPUs */
@@ -1295,10 +1311,16 @@
 					if (!IS_MEMPORT_MARKER(mwa))
 						if (mwa->start <= end+1 && mwa->end > end && (mwa->base || needs_ram(cpunum, (void *)mwa->handler)))
 							end = mwa->end;
 			}
 
+			ext_entries++;
+			if( ext_entries > MAX_EXT_MEMORY )
+			{
+				return fatalerror("MAX_EXT_MEMORY too small (%d)\n", ext_entries);
+			}
+
 			/* fill in the data structure */
 			ext->start = lowest;
 			ext->end = end;
 			ext->region = region;
 
@@ -1310,15 +1332,16 @@
 			/* reset the memory */
 			memset(ext->data, 0, end+1 - lowest);
 
 			/* prepare for the next loop */
 			size = ext->end + 1;
-			ext++;
 
 			/* check for wraparound */
 			if (size < ext->end)
 				break;
+
+			ext++;
 		}
 	}
 	return 1;
 }
 
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui src.ori/neomame.mak src/neomame.mak
--- src.ori/neomame.mak	2001-02-16 16:13:54.000000000 +0100
+++ src/neomame.mak	2002-11-15 22:20:08.000000000 +0100
@@ -8,17 +8,19 @@
 EMULATOR_EXE = neomame.exe
 
 # CPUs
 CPUS+=Z80@
 CPUS+=M68000@
+CPUS+=M68020@
 
 # SOUNDs
 SOUNDS+=AY8910@
 SOUNDS+=YM2610@
 
 DRVLIBS = $(OBJ)/neogeo.a
 
 $(OBJ)/neogeo.a: \
 	$(OBJ)/machine/neogeo.o $(OBJ)/machine/pd4990a.o $(OBJ)/vidhrdw/neogeo.o $(OBJ)/drivers/neogeo.o \
+	$(OBJ)/machine/neocrypt.o
 
 # MAME specific core objs
 COREOBJS += $(OBJ)/driver.o $(OBJ)/cheat.o
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui src.ori/osdepend.h src/osdepend.h
--- src.ori/osdepend.h	2002-06-30 20:58:46.000000000 +0200
+++ src/osdepend.h	2003-01-05 14:57:38.000000000 +0100
@@ -400,10 +400,37 @@
 #include "osd_dir.h"
 #endif
 
 void CLIB_DECL logerror(const char *text,...);
 
+/******************************************************************************
+
+  Additions
+
+******************************************************************************/
+
+/* called then the game is reset */
+void osd_reset(void);
+
+/* execute the specified menu (0,1,...) */
+int osd_menu(struct mame_bitmap *bitmap, int sel);
+
+/* filter the user interface input state */
+int osd_input_ui_filter(int result, int type);
+
+/* filter the main exit request */
+int osd_input_exit_filter(int result);
+
+/* filter the input port state */
+int osd_input_port_filter(int result, int type);
+
+/* start and stop the video/sound recording. */
+void osd_record_start(void);
+void osd_record_stop(void);
+
+void osd_customize_inputport_current(struct InputPort* current);
+
 #ifdef __cplusplus
 }
 #endif
 
 #endif
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui src.ori/sound/fm.c src/sound/fm.c
--- src.ori/sound/fm.c	2002-01-01 22:15:36.000000000 +0100
+++ src/sound/fm.c	2002-11-15 22:20:08.000000000 +0100
@@ -160,11 +160,11 @@
 #define LFO_RATE 0x10000
 #define PMS_RATE 0x400
 /* LFO runtime work */
 static UINT32 lfo_amd;
 static INT32 lfo_pmd;
-#if BUILD_YM2610B
+#if BUILD_YM2610B || BUILD_OPNB
 static UINT32 LFOCnt,LFOIncr;	/* LFO Phase Generator */
 #endif
 /* OPN LFO waveform table */
 static INT32 OPN_LFO_wave[LFO_ENT];
 
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui src.ori/ui_text.c src/ui_text.c
--- src.ori/ui_text.c	2001-09-30 10:27:00.000000000 +0200
+++ src/ui_text.c	2002-11-15 22:20:08.000000000 +0100
@@ -202,10 +202,14 @@
 	"Restoration successful",
 	"Select a value",
 	"All values saved",
 	"One match found - added to list",
 
+	/* addendum */
+	"Center",
+	"Video",
+
 	NULL
 };
 
 int uistring_init (void *langfile)
 {
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui src.ori/ui_text.h src/ui_text.h
--- src.ori/ui_text.h	2001-09-30 10:27:04.000000000 +0200
+++ src/ui_text.h	2002-11-15 22:20:08.000000000 +0100
@@ -169,10 +169,14 @@
 	UI_search_OK,
 	UI_search_select_value,
 	UI_search_all_values_saved,
 	UI_search_one_match_found_added,
 
+	/* addendum */
+	UI_center,
+	UI_osdmenu,
+
 	UI_last_entry
 };
 
 struct lang_struct
 {
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui src.ori/usrintrf.c src/usrintrf.c
--- src.ori/usrintrf.c	2002-08-24 18:43:14.000000000 +0200
+++ src/usrintrf.c	2002-11-15 22:26:00.000000000 +0100
@@ -843,12 +843,16 @@
 	while (items[i])
 	{
 		len = 3 + strlen(items[i]);
 		if (subitems && subitems[i])
 			len += 2 + strlen(subitems[i]);
-		if (len > maxlen && len <= highlen)
-			maxlen = len;
+		if (len > maxlen) {
+			if (len <= highlen)
+				maxlen = len;
+			else
+				maxlen = highlen;
+		}
 		i++;
 	}
 	count = i;
 
 	visible = uirotheight / (3 * uirotcharheight / 2) - 1;
@@ -916,15 +920,27 @@
 				dt[curr_dt].y = topoffs + (3*i+1)*uirotcharheight/2;
 				curr_dt++;
 			}
 			else
 			{
-				dt[curr_dt].text = items[item];
-				dt[curr_dt].color = UI_COLOR_NORMAL;
-				dt[curr_dt].x = (uirotwidth - uirotcharwidth * strlen(items[item])) / 2;
-				dt[curr_dt].y = topoffs + (3*i+1)*uirotcharheight/2;
-				curr_dt++;
+				unsigned y = topoffs + (3*i+1)*uirotcharheight/2;
+				int color = (flag && flag[item]) ? UI_COLOR_INVERSE : UI_COLOR_NORMAL;
+				len = strlen(items[item]);
+				if (len > maxlen - 3) {
+					unsigned x;
+					const char* dot = "...";
+					len = maxlen - 3;
+					x = (uirotwidth - uirotcharwidth * len) / 2;
+					ui_text_ex(bitmap,items[item],items[item] + len - 3,x,y,color);
+					ui_text_ex(bitmap,dot,dot+3,x + uirotcharwidth * (len - 3),y,color);
+				} else {
+					dt[curr_dt].text = items[item];
+					dt[curr_dt].color = color;
+					dt[curr_dt].x = (uirotwidth - uirotcharwidth * len) / 2;
+					dt[curr_dt].y = y;
+					curr_dt++;
+				}
 			}
 		}
 	}
 
 	i = selected - topitem;
@@ -2041,13 +2057,13 @@
 		in++;
 	}
 
 	if (total == 0) return 0;
 
-	/* Each analog control has 3 entries - key & joy delta, reverse, sensitivity */
+	/* Each analog control has 4 entries - key & joy delta, reverse, sensitivity */
 
-#define ENTRIES 3
+#define ENTRIES 4
 
 	total2 = total * ENTRIES;
 
 	menu_item[total2] = ui_getstring (UI_returntomain);
 	menu_item[total2 + 1] = 0;	/* terminate array */
@@ -2060,15 +2076,17 @@
 		{
 			char label[30][40];
 			char setting[30][40];
 			int sensitivity,delta;
 			int reverse;
+			int center;
 
 			strcpy (label[i], input_port_name(entry[i/ENTRIES]));
 			sensitivity = IP_GET_SENSITIVITY(entry[i/ENTRIES]);
 			delta = IP_GET_DELTA(entry[i/ENTRIES]);
 			reverse = (entry[i/ENTRIES]->type & IPF_REVERSE);
+			center = (entry[i/ENTRIES]->type & IPF_CENTER);
 
 			strcat (label[i], " ");
 			switch (i%ENTRIES)
 			{
 				case 0:
@@ -2087,10 +2105,18 @@
 				case 2:
 					strcat (label[i], ui_getstring (UI_sensitivity));
 					sprintf(setting[i],"%3d%%",sensitivity);
 					if (i == sel) arrowize = 3;
 					break;
+				case 3:
+					strcat (label[i], ui_getstring (UI_center));
+					if (center)
+						sprintf(setting[i],ui_getstring (UI_on));
+					else
+						sprintf(setting[i],ui_getstring (UI_off));
+					if (i == sel) arrowize = 3;
+					break;
 			}
 
 			menu_item[i] = label[i];
 			menu_subitem[i] = setting[i];
 
@@ -2138,10 +2164,21 @@
 
 				val --;
 				if (val < 1) val = 1;
 				IP_SET_SENSITIVITY(entry[sel/ENTRIES],val);
 			}
+			else if ((sel % ENTRIES) == 3)
+			/* center */
+			{
+				int center = entry[sel/ENTRIES]->type & IPF_CENTER;
+				if (center)
+					center=0;
+				else
+					center=IPF_CENTER;
+				entry[sel/ENTRIES]->type &= ~IPF_CENTER;
+				entry[sel/ENTRIES]->type |= center;
+			}
 		}
 	}
 
 	if (input_ui_pressed_repeat(IPT_UI_RIGHT,8))
 	{
@@ -2174,10 +2211,21 @@
 
 				val ++;
 				if (val > 255) val = 255;
 				IP_SET_SENSITIVITY(entry[sel/ENTRIES],val);
 			}
+			else if ((sel % ENTRIES) == 3)
+			/* center */
+			{
+				int center = entry[sel/ENTRIES]->type & IPF_CENTER;
+				if (center)
+					center=0;
+				else
+					center=IPF_CENTER;
+				entry[sel/ENTRIES]->type &= ~IPF_CENTER;
+				entry[sel/ENTRIES]->type |= center;
+			}
 		}
 	}
 
 	if (input_ui_pressed(IPT_UI_SELECT))
 	{
@@ -3024,15 +3072,15 @@
 
 
 #ifndef MESS
 enum { UI_SWITCH = 0,UI_DEFCODE,UI_CODE,UI_ANALOG,UI_CALIBRATE,
 		UI_STATS,UI_GAMEINFO, UI_HISTORY,
-		UI_CHEAT,UI_RESET,UI_MEMCARD,UI_EXIT };
+		UI_CHEAT,UI_RESET,UI_MEMCARD,UI_EXIT,UI_OSD };
 #else
 enum { UI_SWITCH = 0,UI_DEFCODE,UI_CODE,UI_ANALOG,UI_CALIBRATE,
 		UI_GAMEINFO, UI_IMAGEINFO,UI_FILEMANAGER,UI_TAPECONTROL,
-		UI_HISTORY,UI_CHEAT,UI_RESET,UI_MEMCARD,UI_EXIT };
+		UI_HISTORY,UI_CHEAT,UI_RESET,UI_MEMCARD,UI_EXIT,UI_OSD };
 #endif
 
 
 #define MAX_SETUPMENU_ITEMS 20
 static const char *menu_item[MAX_SETUPMENU_ITEMS];
@@ -3105,10 +3153,11 @@
 #endif
 #endif
 #endif
 #endif
 
+	menu_item[menu_total] = ui_getstring (UI_osdmenu); menu_action[menu_total++] = UI_OSD;
 	menu_item[menu_total] = ui_getstring (UI_resetgame); menu_action[menu_total++] = UI_RESET;
 	menu_item[menu_total] = ui_getstring (UI_returntogame); menu_action[menu_total++] = UI_EXIT;
 	menu_item[menu_total] = 0; /* terminate array */
 }
 
@@ -3165,10 +3214,13 @@
 				res = displayhistory(bitmap, sel >> SEL_BITS);
 				break;
 			case UI_CHEAT:
 				res = cheat_menu(bitmap, sel >> SEL_BITS);
 				break;
+			case UI_OSD :
+				res = osd_menu(bitmap, sel >> SEL_BITS);
+				break;
 #ifndef MESS
 #ifndef TINY_COMPILE
 #ifndef CPSMAME
 #ifndef MMSND
 			case UI_MEMCARD:
@@ -3219,10 +3271,11 @@
 			case UI_TAPECONTROL:
 			#endif
 			case UI_HISTORY:
 			case UI_CHEAT:
 			case UI_MEMCARD:
+			case UI_OSD :
 				sel |= 1 << SEL_BITS;
 				schedule_full_refresh();
 				break;
 
 			case UI_RESET:
@@ -3660,10 +3713,63 @@
 	vsprintf(messagetext,text,arg);
 	va_end(arg);
 	messagecounter = seconds * Machine->drv->frames_per_second;
 }
 
+int on_exit_menu(struct mame_bitmap* bitmap, int selected)
+{
+	const char * exit_menu_item[8];
+	char flag[8];
+
+	int sel;
+	int total;
+
+	sel = selected - 1;
+
+	total = 0;
+
+	exit_menu_item[total] = "Continue";
+	flag[total] = 0;
+	++total;
+
+	exit_menu_item[total] = "Exit";
+	flag[total] = 0;
+	++total;
+
+	exit_menu_item[total] = 0;
+	flag[total] = 0;
+
+	ui_displaymenu(bitmap,exit_menu_item,0,flag,sel,0);
+
+	if (input_ui_pressed_repeat(IPT_UI_DOWN,8)) {
+		sel = (sel + 1) % total;
+	}
+
+	if (input_ui_pressed_repeat(IPT_UI_UP,8)) {
+		sel = (sel + total - 1) % total;
+	}
+
+	if (input_ui_pressed(IPT_UI_SELECT)) {
+		if (sel == 1)
+			sel = -2;
+		if (sel == 0)
+			sel = -1;
+	}
+
+	if (input_ui_pressed(IPT_UI_CANCEL)) {
+		sel = -1;
+	}
+
+	if (sel == -1 || sel == -2)
+	{
+		/* tell updatescreen() to clean after us */
+		schedule_full_refresh();
+	}
+
+	return sel + 1;
+}
+
 void do_loadsave(struct mame_bitmap *bitmap, int request_loadsave)
 {
 	int file = 0;
 
 	mame_pause(1);
@@ -3841,17 +3947,42 @@
 
 	/* if the user pressed F12, save the screen to a file */
 	if (input_ui_pressed(IPT_UI_SNAPSHOT))
 		artwork_save_snapshot(bitmap);
 
+	/* save the sound to a file */
+	if (input_ui_pressed(IPT_UI_RECORD_START))
+		osd_record_start();
+	if (input_ui_pressed(IPT_UI_RECORD_STOP))
+		osd_record_stop();
+
 	/* This call is for the cheat, it must be called once a frame */
 	if (options.cheat) DoCheat(bitmap);
 
 	/* if the user pressed ESC, stop the emulation */
 	/* but don't quit if the setup menu is on screen */
-	if (setup_selected == 0 && input_ui_pressed(IPT_UI_CANCEL))
-		return 1;
+	if (setup_selected == 0) {
+		int res = osd_input_exit_filter(input_ui_pressed(IPT_UI_CANCEL));
+		if (res > 1)
+			return 1;
+		if (res != 0) {
+			osd_sound_enable(0);
+			osd_pause(1);
+
+			res = 1;
+			while (res > 0) {
+				res = on_exit_menu(bitmap,res);
+				update_video_and_audio();
+			}
+
+			osd_pause(0);
+			osd_sound_enable(1);
+
+			if (res < 0)
+				return 1;
+		}
+	}
 
 	if (setup_selected == 0 && input_ui_pressed(IPT_UI_CONFIGURE))
 	{
 		setup_selected = -1;
 		if (osd_selected != 0)
@@ -3954,10 +4085,14 @@
 			profiler_mark(PROFILER_END);
 
 			if (input_ui_pressed(IPT_UI_SNAPSHOT))
 				artwork_save_snapshot(bitmap);
 
+			if (input_ui_pressed(IPT_UI_RECORD_START))
+				osd_record_start();
+			if (input_ui_pressed(IPT_UI_RECORD_STOP))
+				osd_record_stop();
 
 			if (input_ui_pressed(IPT_UI_SAVE_STATE))
 				do_loadsave(bitmap, LOADSAVE_SAVE);
 
 			if (input_ui_pressed(IPT_UI_LOAD_STATE))
@@ -3966,11 +4101,11 @@
 			/* if the user pressed F4, show the character set */
 			if (input_ui_pressed(IPT_UI_SHOW_GFX))
 				showcharset(bitmap);
 
 			if (setup_selected == 0 && input_ui_pressed(IPT_UI_CANCEL))
-				return 1;
+				break;
 
 			if (setup_selected == 0 && input_ui_pressed(IPT_UI_CONFIGURE))
 			{
 				setup_selected = -1;
 				if (osd_selected != 0)
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui src.ori/vidhrdw/cave.c src/vidhrdw/cave.c
--- src.ori/vidhrdw/cave.c	2002-05-25 12:32:48.000000000 +0200
+++ src/vidhrdw/cave.c	2002-11-15 22:20:08.000000000 +0100
@@ -1532,10 +1532,13 @@
 {
 	int pri, pri2;
 	int layers_ctrl = -1;
 	int background_color;
 
+	/* Set the correct destination if SMP is active */
+	blit.baseaddr = Machine->scrbitmap->line[0];
+
 	/* Choose the tilemap to display (8x8 tiles or 16x16 tiles) */
 	if (tilemap_0)
 	{	tiledim_0 = cave_vctrl_0[ 1 ] & 0x2000;
 		if (tiledim_0 != old_tiledim_0)	tilemap_mark_all_tiles_dirty(tilemap_0);
 		old_tiledim_0 = tiledim_0;		}
