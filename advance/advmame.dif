diff -U 5 --new-file --recursive src.ori/advance.pat src/advance.pat
--- src.ori/advance.pat	1970-01-01 01:00:00.000000000 +0100
+++ src/advance.pat	2003-11-12 20:58:44.000000000 +0100
@@ -0,0 +1 @@
+These files are patched for the use with the Advance emulator.
diff -U 5 --new-file --recursive src.ori/common.c src/common.c
--- src.ori/common.c	2003-11-11 22:25:54.000000000 +0100
+++ src/common.c	2003-11-12 20:58:44.000000000 +0100
@@ -414,17 +414,11 @@
 	coin_counter_w - sets input for coin counter
 -------------------------------------------------*/
 
 void coin_counter_w(int num,int on)
 {
-	if (num >= COIN_COUNTERS) return;
-	/* Count it only if the data has changed from 0 to non-zero */
-	if (on && (lastcoin[num] == 0))
-	{
-		coins[num]++;
-	}
-	lastcoin[num] = on;
+	/* moved in update_input_ports */
 }
 
 
 /*-------------------------------------------------
 	coin_lockout_w - locks out one coin input
@@ -733,10 +727,11 @@
 /*-------------------------------------------------
 	save_screen_snapshot_as - save a snapshot to
 	the given filename
 -------------------------------------------------*/
 
+#if 0 /* AdvanceMAME has its snapshot code */
 void save_screen_snapshot_as(mame_file *fp, struct mame_bitmap *bitmap)
 {
 	struct rectangle bounds;
 	struct mame_bitmap *osdcopy;
 	UINT32 saved_rgb_components[3];
@@ -824,17 +819,19 @@
 
 	/* if the OSD system allocated a bitmap; free it */
 	if (osdcopy)
 		bitmap_free(osdcopy);
 }
+#endif
 
 
 
 /*-------------------------------------------------
 	save_screen_snapshot - save a screen snapshot
 -------------------------------------------------*/
 
+#if 0 /* AdvanceMAME has its snapshot code */
 void save_screen_snapshot(struct mame_bitmap *bitmap)
 {
 	char name[20];
 	mame_file *fp;
 
@@ -854,10 +851,11 @@
 	{
 		save_screen_snapshot_as(fp, bitmap);
 		mame_fclose(fp);
 	}
 }
+#endif
 
 
 
 /***************************************************************************
 
@@ -1211,11 +1209,11 @@
 		}
 		else
 			strcat(romdata->errorbuf, "WARNING: the game might not run correctly.\n");
 
 		/* display the result */
-		printf("%s", romdata->errorbuf);
+		osd_display_loading_rom_message(romdata->errorbuf, 0);
 
 		/* if we're not getting out of here, wait for a keypress */
 		if (!options.gui_host && !bailing)
 		{
 			int k;
diff -U 5 --new-file --recursive src.ori/cpmame.mak src/cpmame.mak
--- src.ori/cpmame.mak	2003-05-15 04:59:00.000000000 +0200
+++ src/cpmame.mak	2003-11-12 20:58:44.000000000 +0100
@@ -15,10 +15,11 @@
 
 # SOUNDs
 SOUNDS+=YM2151_ALT@
 SOUNDS+=OKIM6295@
 SOUNDS+=QSOUND@
+SOUNDS+=DISCRETE@
 
 DRVLIBS = $(OBJ)/cps.a
 
 $(OBJ)/cps.a: \
 	$(OBJ)/machine/kabuki.o \
diff -U 5 --new-file --recursive src.ori/cpu/i8085/i8085.c src/cpu/i8085/i8085.c
--- src.ori/cpu/i8085/i8085.c	2003-10-12 20:51:58.000000000 +0200
+++ src/cpu/i8085/i8085.c	2003-11-12 20:58:44.000000000 +0100
@@ -85,10 +85,16 @@
  * 
  *****************************************************************************/
 
 /*int survival_prot = 0; */
 
+#if defined(__GNUC__) && __GNUC__ >= 3
+/* Disable all the asm macro and the big switch */
+#undef X86_ASM
+#define BIG_SWITCH 0
+#endif
+
 #define VERBOSE 0
 
 #include "driver.h"
 #include "state.h"
 #include "osd_cpu.h"
diff -U 5 --new-file --recursive src.ori/cpu/m68000/make68k.c src/cpu/m68000/make68k.c
--- src.ori/cpu/m68000/make68k.c	2003-06-09 20:34:00.000000000 +0200
+++ src/cpu/m68000/make68k.c	2003-11-12 20:58:44.000000000 +0100
@@ -188,11 +188,11 @@
 
 
 #define NORMAL 0
 #define PCREL  1
 
-#ifdef __ELF__
+#if defined(USE_OBJ_ELF)
 #define PREF ""
 #else
 #define PREF "_"
 #endif
 
@@ -249,17 +249,17 @@
 
 
 
 /* External register preservation */
 
-#ifdef DOS
+#if defined(USE_COMPILER_GNUC)
 
 /* Registers normally saved around C routines anyway */
 /* GCC 2.9.1 (dos) seems to preserve EBX,EDI and EBP */
 static char SavedRegs[] = "-B--SDB";
 
-#elif defined(WIN32)
+#elif defined(USE_COMPILER_VISUALC)
 
 /* visual C++, win32, says it preserves ebx, edi, esi, and ebp */
 /* ---------- VC++ deosn't preserve EDI? (Kenjo, 110399) ---------- */
 static char SavedRegs[] = "-B--S-B";
 
@@ -8037,11 +8037,11 @@
 	fprintf(fp, "\t\tDW   0,0,0\n\n");
 
 
 /* If Win32, put the table area in .data section (Kenjo) */
 
-#ifdef WIN32
+#if defined(USE_OS_WINDOWS)
 
 	fprintf(fp, "%s_OPCODETABLE\tTIMES  65536  DD 0\n\n", CPUtype);
 
 #else
 
diff -U 5 --new-file --recursive src.ori/cpu/z80/z80.c src/cpu/z80/z80.c
--- src.ori/cpu/z80/z80.c	2003-11-11 22:25:56.000000000 +0100
+++ src/cpu/z80/z80.c	2003-11-12 20:59:47.000000000 +0100
@@ -79,10 +79,16 @@
 #include "cpuintrf.h"
 #include "state.h"
 #include "mamedbg.h"
 #include "z80.h"
 
+#if defined(__GNUC__) && __GNUC__ >= 3
+/* Disable all the asm macro and the big switch */
+#undef X86_ASM
+#define BIG_SWITCH 0
+#endif
+
 #define VERBOSE 0
 
 #if VERBOSE
 #define LOG(x)	logerror x
 #else
diff -U 5 --new-file --recursive src.ori/cpuexec.c src/cpuexec.c
--- src.ori/cpuexec.c	2003-11-11 22:25:56.000000000 +0100
+++ src/cpuexec.c	2003-11-12 20:58:44.000000000 +0100
@@ -310,10 +310,13 @@
 	watchdog_counter = -1;
 
 	/* reset sound chips */
 	sound_reset();
 
+	/* reset the osd level */
+	osd_reset();
+
 	/* first pass over CPUs */
 	for (cpunum = 0; cpunum < cpu_gettotalcpu(); cpunum++)
 	{
 		/* enable all CPUs (except for audio CPUs if the sound is off) */
 		if (!(Machine->drv->cpu[cpunum].cpu_flags & CPU_AUDIO_CPU) || Machine->sample_rate != 0)
diff -U 5 --new-file --recursive src.ori/drivers/multi32.c src/drivers/multi32.c
--- src.ori/drivers/multi32.c	2003-09-14 13:53:06.000000000 +0200
+++ src/drivers/multi32.c	2003-11-12 20:58:44.000000000 +0100
@@ -711,11 +711,11 @@
 	MDRV_NVRAM_HANDLER(system32)
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES(VIDEO_TYPE_RASTER | VIDEO_NEEDS_6BITS_PER_GUN | VIDEO_UPDATE_AFTER_VBLANK | VIDEO_RGB_DIRECT | VIDEO_HAS_SHADOWS ) // RGB_DIRECT will be needed for alpha
 	MDRV_SCREEN_SIZE(52*8*2, 28*8*2)
-	MDRV_VISIBLE_AREA(0*8, 52*8*2-1, 0*8, 28*8*2-1)
+	MDRV_VISIBLE_AREA(0, 320-1, 0, 224-1)
 
 	MDRV_GFXDECODE(gfxdecodeinfo)
 	MDRV_PALETTE_LENGTH(32768)
 
 	MDRV_VIDEO_START(system32)
diff -U 5 --new-file --recursive src.ori/drivers/namcos11.c src/drivers/namcos11.c
--- src.ori/drivers/namcos11.c	2003-11-11 22:25:56.000000000 +0100
+++ src/drivers/namcos11.c	2003-11-16 17:28:02.000000000 +0100
@@ -655,11 +655,11 @@
 #if defined( MAME_DEBUG )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
 	MDRV_VISIBLE_AREA( 0, 1023, 0, 1023 )
 #else
 	MDRV_SCREEN_SIZE( 640, 480 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 8, 240-1 )
 #endif
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type1_1024x1024 )
diff -U 5 --new-file --recursive src.ori/drivers/neogeo.c src/drivers/neogeo.c
--- src.ori/drivers/neogeo.c	2003-11-11 22:25:56.000000000 +0100
+++ src/drivers/neogeo.c	2003-11-12 20:58:44.000000000 +0100
@@ -386,11 +386,11 @@
 			}
 			fc++;
 		}
 
 		if (irq2control & IRQ2CTRL_ENABLE)
-			usrintf_showmessage("IRQ2 enabled, need raster driver");
+			/* usrintf_showmessage("IRQ2 enabled, need raster driver") */ ;
 
 		/* return a standard vblank interrupt */
 		vblank_int = 1;	   /* vertical blank */
 	}
 
diff -U 5 --new-file --recursive src.ori/drivers/stv.c src/drivers/stv.c
--- src.ori/drivers/stv.c	2003-11-11 22:25:56.000000000 +0100
+++ src/drivers/stv.c	2003-11-17 19:37:09.000000000 +0100
@@ -518,16 +518,16 @@
 		case 0x05:
 				//open tray
 				logerror("CDBLOCK Command 0x%02x\n", (CR1>>8));
 				//NOT USED
 				break;
-		case 0x06:
+		case 0x06: {
 				//end data transfer
-				logerror("CDBLOCK Command 0x%02x\n", (CR1>>8));
-
 				UINT32 count;
 
+				logerror("CDBLOCK Command 0x%02x\n", (CR1>>8));
+
 				switch(CD_trans_type){
 				case -1:	count = 0xffffff; break;			// no transfer
 				case 0:	count = (CD_data_count + 1) >> 1; break;	// data transfer
 				default:	count = (CD_info_count + 1) >> 1; break;	// info transfer
 				}
@@ -540,19 +540,19 @@
 				CR1 = (CD_status << 8) | (count >> 16);
 				CR2 = count;
 				CR3 = 0;
 				CR4 = 0;
 
-				break;
-		case 0x10:
+				} break;
+		case 0x10: {
 				//play
+				UINT8 pm; // play mode
+
 				logerror("CDBLOCK Command 0x%02x\n", (CR1>>8));
 
 				// sthief: must be rewritten!
 
-				UINT8 pm; // play mode
-
 				pm = (CR3 >> 8);
 
 				if((CR1 & 0x80) != (CR3 & 0x80)){
 
 				}
@@ -699,11 +699,11 @@
 
 				CD_com_play = CD_com;
 
 				CDB_SEND_REPORT();
 
-				break;
+				} break;
 		case 0x11:
 				//seek
 				logerror("CDBLOCK Command 0x%02x\n", (CR1>>8));
 				if((CR1 & 0xff) == 0xff){
 
@@ -1028,12 +1028,14 @@
 				CR4 = 0;
 
 				CD_hirq |= HIRQ_CMOK | HIRQ_ESEL;
 
 				break;
-		case 0x48:
+		case 0x48: {
 				//reset selector
+				UINT32 rf;
+
 				logerror("CDBLOCK Command 0x%02x\n", (CR1>>8));
 
 				// reset flag:
 				//
 				// b7		init false output connectors
@@ -1043,11 +1045,11 @@
 				// b3		init partition output connectors	?
 				// b2		init partition data
 				// b1,0	unused
 				//
 				// if reset flag is zero, all selectors are completely reset
-				UINT32 rf;
+
 
 				rf = CR1 & 0xff;
 
 				if(rf == 0){
 
@@ -1126,11 +1128,11 @@
 				}
 
 				CD_hirq |= HIRQ_CMOK | HIRQ_ESEL;
 
 				CDB_SEND_REPORT();
-				break;
+				} break;
 		case 0x50:
 				//get block size
 				logerror("CDBLOCK Command 0x%02x\n", (CR1>>8));
 				CD_hirq |= HIRQ_CMOK | HIRQ_ESEL;
 
@@ -1161,16 +1163,16 @@
 				CR4 = 0x0001;//CD_part[pn].size; // sectors
 //HACK
 				logerror("get buffer %02i size = %03i sectors\n", pn, CD_part[pn].size);
 
 				break;
-		case 0x52:
+		case 0x52: {
 				//calc actual size
-				logerror("CDBLOCK Command 0x%02x\n", (CR1>>8));
-
 				int ii;
 
+				logerror("CDBLOCK Command 0x%02x\n", (CR1>>8));
+
 				CD_hirq |= HIRQ_CMOK | HIRQ_ESEL;
 
 				pn = (CR3 >> 8);
 				sp = CR2;
 				sn = CR4;
@@ -1190,11 +1192,11 @@
 
 				CD_actual_size = (CD_actual_size + 1) >> 1;
 
 				CDB_SEND_REPORT();
 
-				break;
+				} break;
 		case 0x53:
 				//get actual block size
 				logerror("CDBLOCK Command 0x%02x\n", (CR1>>8));
 
 				CD_hirq |= HIRQ_CMOK | HIRQ_ESEL;
@@ -1207,17 +1209,16 @@
 				CR3 = 0;
 				CR4 = 0;
 
 				logerror("get actual block size : %i words\n", CD_actual_size);
 				break;
-		case 0x54:
+		case 0x54: {
 				//get sector info
-				logerror("CDBLOCK Command 0x%02x\n", (CR1>>8));
-
-
 				sect_t * s;
 
+				logerror("CDBLOCK Command 0x%02x\n", (CR1>>8));
+
 				pn = CR3 >> 8;
 				sn = CR2 & 0xff;
 
 				if(pn >= CDB_SEL_NUM){
 					logerror("ERROR: invalid selector\n");
@@ -1229,18 +1230,18 @@
 				CR1 = (CD_status << 8) | (s->fad >> 16);
 				CR2 = s->fad;
 				CR3 = (s->fid << 8) | s->chan;
 				CR4 = (s->sub << 8) | s->cod;
 
-				break;
-		case 0x55:
+				} break;
+		case 0x55: {
 				//execute fad search
-				logerror("CDBLOCK Command 0x%02x\n", (CR1>>8));
-
 				UINT32  fad;
 				UINT32 i, j, nearest = 0, fad2 = 0;
 
+				logerror("CDBLOCK Command 0x%02x\n", (CR1>>8));
+
 				CD_hirq |= HIRQ_CMOK | HIRQ_ESEL;
 
 				pn = CR3 >> 8;
 				sp = CR2;
 				fad = ((CR3 & 0xff) << 8) | CR4;
@@ -1287,11 +1288,11 @@
 				CD_search_pn = pn;
 				CD_search_sp = nearest;
 				CD_search_fad = fad2;
 
 
-				break;
+				} break;
 		case 0x56:
 				//get fad search res
 				logerror("CDBLOCK Command 0x%02x\n", (CR1>>8));
 
 
@@ -1475,15 +1476,16 @@
 				CR2 = 0x0063;
 				CR3 = 0x0100;
 				CR4 = 0x0002;
 
 				break;
-		case 0x73:
+		case 0x73: {
 				//get file info
+				UINT32 size;
+
 				logerror("CDBLOCK Command 0x%02x\n", (CR1>>8));
 
-				UINT32 size;
 				// check if out of scope
 
 				fid = (CR3 << 16) | CR4;
 
 				if(fid >= 254){
@@ -1514,17 +1516,17 @@
 				CD_info_size	= size;
 				CD_info_count	= 0;
 
 				CD_trans_type	= 1; // INFO
 
-				break;
-		case 0x74:
+				} break;
+		case 0x74: {
 				//read file
-				logerror("CDBLOCK Command 0x%02x\n", (CR1>>8));
-
 				UINT32 off;
 
+				logerror("CDBLOCK Command 0x%02x\n", (CR1>>8));
+
 				CD_com_play = CD_com;
 
 				fn = (CR3 >> 8);
 				fid = ((CR3 & 0xff) << 16) | CR4;
 				off = ((CR1 & 0xff) << 16) | CR2;
@@ -1564,11 +1566,11 @@
 
 				CD_repeat = 0;
 
 				CDB_SEND_REPORT();
 
-				break;
+				} break;
 		case 0x75:
 				//abort file
 				logerror("CDBLOCK Command 0x%02x\n", (CR1>>8));
 
 				// stop file info hold
@@ -1623,12 +1625,12 @@
 
 
 
 static READ32_HANDLER ( cdregister_r ){
 
-	offset=offset*4;
 	UINT16 d;
+	offset=offset*4;
 
 	//logerror("read from cd block offset=%08x\n", offset);
 	switch(offset){
 
 		case 0x90008:
@@ -1915,13 +1917,13 @@
 }
 
 static void stv_SMPC_w8 (int offset, UINT8 data)
 {
 //	logerror ("8-bit SMPC Write to Offset %02x with Data %02x\n", offset, data);
-	smpc_ram[offset] = data;
 	time_t ltime;
 	struct tm *today;
+	smpc_ram[offset] = data;
 	time(&ltime);
 	today = localtime(&ltime);
 	if(offset == 0x75)
 	{
 		EEPROM_set_clock_line((data & 0x08) ? ASSERT_LINE : CLEAR_LINE);
@@ -4179,14 +4181,15 @@
 
 DRIVER_INIT ( stv )
 {
 	time_t ltime;
 	struct tm *today;
+	unsigned char *ROM = memory_region(REGION_USER1);
+
 	time(&ltime);
 	today = localtime(&ltime);
 
-	unsigned char *ROM = memory_region(REGION_USER1);
 	cpu_setbank(1,&ROM[0x000000]);
 
 	/* we allocate the memory here so its easier to share between cpus */
 	smpc_ram = auto_malloc (0x80);
 	stv_scu = auto_malloc (0x100);
@@ -4369,11 +4372,11 @@
 	MDRV_NVRAM_HANDLER(93C46) /* Actually 93c45 */
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES(VIDEO_TYPE_RASTER | VIDEO_UPDATE_AFTER_VBLANK | VIDEO_RGB_DIRECT )
 	MDRV_SCREEN_SIZE(1024, 1024)
-	MDRV_VISIBLE_AREA(0*8, 703, 0*8, 479) // we need to use a resolution as high as the max size it can change to
+	MDRV_VISIBLE_AREA(0*8, 320-1, 0*8, 240-1)
 	MDRV_PALETTE_LENGTH(2048)
 	MDRV_GFXDECODE(gfxdecodeinfo)
 
 	MDRV_VIDEO_START(stv_vdp2)
 	MDRV_VIDEO_UPDATE(stv_vdp2)
diff -U 5 --new-file --recursive src.ori/fileio.c src/fileio.c
--- src.ori/fileio.c	2003-11-11 22:25:56.000000000 +0100
+++ src/fileio.c	2003-11-12 20:58:44.000000000 +0100
@@ -72,10 +72,11 @@
 	UINT64 offset;
 	UINT64 length;
 	UINT8 eof;
 	UINT8 type;
 	char hash[HASH_BUF_SIZE];
+	int back_char; /* Buffered char for unget. EOF for empty. */
 };
 
 
 
 /***************************************************************************
@@ -353,10 +354,13 @@
 	mame_fread
 ***************************************************************************/
 
 UINT32 mame_fread(mame_file *file, void *buffer, UINT32 length)
 {
+	/* flush any buffered char */
+	file->back_char = EOF;
+
 	/* switch off the file type */
 	switch (file->type)
 	{
 		case PLAIN_FILE:
 			return osd_fread(file->file, buffer, length);
@@ -386,10 +390,13 @@
 	mame_fwrite
 ***************************************************************************/
 
 UINT32 mame_fwrite(mame_file *file, const void *buffer, UINT32 length)
 {
+	/* flush any buffered char */
+	file->back_char = EOF;
+
 	/* switch off the file type */
 	switch (file->type)
 	{
 		case PLAIN_FILE:
 			return osd_fwrite(file->file, buffer, length);
@@ -406,10 +413,13 @@
 
 int mame_fseek(mame_file *file, INT64 offset, int whence)
 {
 	int err = 0;
 
+	/* flush any buffered char */
+	file->back_char = EOF;
+
 	/* switch off the file type */
 	switch (file->type)
 	{
 		case PLAIN_FILE:
 			return osd_fseek(file->file, offset, whence);
@@ -508,10 +518,16 @@
 
 int mame_fgetc(mame_file *file)
 {
 	unsigned char buffer;
 
+	if (file->back_char != EOF) {
+		buffer = file->back_char;
+		file->back_char = EOF;
+		return buffer;
+	}
+
 	/* switch off the file type */
 	switch (file->type)
 	{
 		case PLAIN_FILE:
 			if (osd_fread(file->file, &buffer, 1) == 1)
@@ -535,38 +551,13 @@
 	mame_ungetc
 ***************************************************************************/
 
 int mame_ungetc(int c, mame_file *file)
 {
-	/* switch off the file type */
-	switch (file->type)
-	{
-		case PLAIN_FILE:
-			if (osd_feof(file->file))
-			{
-				if (osd_fseek(file->file, 0, SEEK_CUR))
-					return c;
-			}
-			else
-			{
-				if (osd_fseek(file->file, -1, SEEK_CUR))
-					return c;
-			}
-			return EOF;
-
-		case RAM_FILE:
-		case ZIPPED_FILE:
-			if (file->eof)
-				file->eof = 0;
-			else if (file->offset > 0)
-			{
-				file->offset--;
-				return c;
-			}
-			return EOF;
-	}
-	return EOF;
+	file->back_char = c;
+  
+	return c;
 }
 
 
 
 /***************************************************************************
@@ -624,10 +615,14 @@
 	mame_feof
 ***************************************************************************/
 
 int mame_feof(mame_file *file)
 {
+	/* check for buffered chars */
+	if (file->back_char != EOF)
+		return 0;
+
 	/* switch off the file type */
 	switch (file->type)
 	{
 		case PLAIN_FILE:
 			return osd_feof(file->file);
@@ -877,10 +872,12 @@
 	LOG(("generic_fopen(%d, %s, %s, %s, %X)\n", pathc, gamename, filename, extension, flags));
 
 	/* reset the file handle */
 	memset(&file, 0, sizeof(file));
 
+	file.back_char = EOF;
+
 	/* check for incompatible flags */
 	if ((flags & FILEFLAG_OPENWRITE) && (flags & FILEFLAG_HASH))
 		fprintf(stderr, "Can't use HASH option with WRITE option in generic_fopen!\n");
 
 	/* determine start/stop based on reverse search flag */
diff -U 5 --new-file --recursive src.ori/inptport.c src/inptport.c
--- src.ori/inptport.c	2003-10-18 21:49:02.000000000 +0200
+++ src/inptport.c	2003-11-12 20:58:44.000000000 +0100
@@ -201,10 +201,13 @@
 	{ IPT_UI_SHOW_PROFILER,     "Show Profiler",		SEQ_DEF_2(KEYCODE_F11, KEYCODE_LSHIFT) },
 #ifdef MESS
 	{ IPT_UI_TOGGLE_UI,         "UI Toggle",			SEQ_DEF_1(KEYCODE_SCRLOCK) },
 #endif
 	{ IPT_UI_SNAPSHOT,          "Save Snapshot",		SEQ_DEF_1(KEYCODE_F12) },
+	{ IPT_UI_RECORD_START,      "Record Start", SEQ_DEF_2(KEYCODE_ENTER,KEYCODE_LCONTROL) },
+	{ IPT_UI_RECORD_STOP,       "Record Stop", SEQ_DEF_3(KEYCODE_ENTER,CODE_NOT,KEYCODE_LCONTROL) },
+	{ IPT_UI_TURBO,             "Turbo", SEQ_DEF_1(KEYCODE_ASTERISK) },
 	{ IPT_UI_TOGGLE_CHEAT,      "Toggle Cheat",			SEQ_DEF_1(KEYCODE_F6) },
 	{ IPT_UI_UP,                "UI Up",				SEQ_DEF_3(KEYCODE_UP, CODE_OR, JOYCODE_1_UP) },
 	{ IPT_UI_DOWN,              "UI Down",				SEQ_DEF_3(KEYCODE_DOWN, CODE_OR, JOYCODE_1_DOWN) },
 	{ IPT_UI_LEFT,              "UI Left",				SEQ_DEF_3(KEYCODE_LEFT, CODE_OR, JOYCODE_1_LEFT) },
 	{ IPT_UI_RIGHT,             "UI Right",				SEQ_DEF_3(KEYCODE_RIGHT, CODE_OR, JOYCODE_1_RIGHT) },
@@ -212,10 +215,12 @@
 	{ IPT_UI_CANCEL,            "UI Cancel",			SEQ_DEF_1(KEYCODE_ESC) },
 	{ IPT_UI_PAN_UP,            "Pan Up",				SEQ_DEF_3(KEYCODE_PGUP, CODE_NOT, KEYCODE_LSHIFT) },
 	{ IPT_UI_PAN_DOWN,          "Pan Down",				SEQ_DEF_3(KEYCODE_PGDN, CODE_NOT, KEYCODE_LSHIFT) },
 	{ IPT_UI_PAN_LEFT,          "Pan Left",				SEQ_DEF_2(KEYCODE_PGUP, KEYCODE_LSHIFT) },
 	{ IPT_UI_PAN_RIGHT,         "Pan Right",			SEQ_DEF_2(KEYCODE_PGDN, KEYCODE_LSHIFT) },
+	{ IPT_UI_MODE_NEXT,         "Mode Next",         SEQ_DEF_1(KEYCODE_STOP) },
+	{ IPT_UI_MODE_PRED,         "Mode Pred",         SEQ_DEF_1(KEYCODE_COMMA) },
 	{ IPT_UI_TOGGLE_DEBUG,      "Toggle Debugger",		SEQ_DEF_1(KEYCODE_F5) },
 	{ IPT_UI_SAVE_STATE,        "Save State",			SEQ_DEF_2(KEYCODE_F7, KEYCODE_LSHIFT) },
 	{ IPT_UI_LOAD_STATE,        "Load State",			SEQ_DEF_3(KEYCODE_F7, CODE_NOT, KEYCODE_LSHIFT) },
 	{ IPT_UI_ADD_CHEAT,			"Add Cheat",			SEQ_DEF_1(KEYCODE_A) },
 	{ IPT_UI_DELETE_CHEAT,		"Delete Cheat",			SEQ_DEF_1(KEYCODE_D) },
@@ -1634,10 +1639,12 @@
 		if (err)
 			goto getout;
 
 		mixer_load_config(&mixercfg);
 
+		osd_customize_inputport_current(Machine->input_ports);
+
 getout:
 		config_close(cfg);
 	}
 
 	/* All analog ports need initialization */
@@ -2134,14 +2141,16 @@
 		int new, prev;
 
 		/* center stick */
 		if ((delta == 0) && (in->type & IPF_CENTER))
 		{
-			if (current > default_value)
-			delta = -100 / sensitivity;
-			if (current < default_value)
-			delta = 100 / sensitivity;
+			/* return backward at middle speed */
+			delta = default_value - current;
+			if (delta < -(keydelta+1)/2)
+				delta = -(keydelta+1)/2;
+			if (delta > (keydelta+1)/2)
+				delta = (keydelta+1)/2;
 		}
 
 		/* An analog joystick which is not at zero position (or has just */
 		/* moved there) takes precedence over all other computations */
 		/* analog_x/y holds values from -128 to 128 (yes, 128, not 127) */
@@ -2393,16 +2402,23 @@
 #define MAX_INPUT_BITS 1024
 	static int impulsecount[MAX_INPUT_BITS];
 	static int waspressed[MAX_INPUT_BITS];
 	static int pbwaspressed[MAX_INPUT_BITS];
 
+	unsigned newcoin[COIN_COUNTERS];
+	unsigned coin;
+
 #ifdef MAME_NET
 	int player;
 #endif /* MAME_NET */
 
 
 profiler_mark(PROFILER_INPUT);
+	
+	/* clear the new coin status */
+	for(coin=0;coin<COIN_COUNTERS;++coin)
+		newcoin[coin] = 0;
 
 	/* clear all the values before proceeding */
 	for (port = 0;port < MAX_INPUT_PORTS;port++)
 	{
 		input_port_value[port] = 0;
@@ -2497,29 +2513,35 @@
 				}
 				else
 				{
 					InputSeq* seq;
 					seq = input_port_seq(in);
-					if (seq_pressed(seq))
+					if (osd_input_port_filter(seq_pressed(seq), in->type & (IPF_PLAYERMASK | ~IPF_MASK)))
 					{
+						int ncoin;
 #ifdef MESS
 						if (((in->type & ~IPF_MASK) == IPT_KEYBOARD) && osd_keyboard_disabled())
 							continue;
 #endif
 
-						/* skip if coin input and it's locked out */
-						if ((in->type & ~IPF_MASK) >= IPT_COIN1 &&
-							(in->type & ~IPF_MASK) <= IPT_COIN4 &&
-                            coinlockedout[(in->type & ~IPF_MASK) - IPT_COIN1])
-						{
-							continue;
+						switch (in->type & ~IPF_MASK) {
+						case IPT_COIN1 : ncoin = 0; break;
+						case IPT_COIN2 : ncoin = 1; break;
+						case IPT_COIN3 : ncoin = 2; break;
+						case IPT_COIN4 : ncoin = 3; break;
+						case IPT_COIN5 : ncoin = 4; break;
+						case IPT_COIN6 : ncoin = 5; break;
+						case IPT_COIN7 : ncoin = 6; break;
+						case IPT_COIN8 : ncoin = 7; break;
+						default: ncoin = -1;
 						}
-						if ((in->type & ~IPF_MASK) >= IPT_COIN5 &&
-							(in->type & ~IPF_MASK) <= IPT_COIN8 &&
-                            coinlockedout[(in->type & ~IPF_MASK) - IPT_COIN5 + 4])
-						{
-							continue;
+						if (ncoin >= 0) {
+							if (coinlockedout[ncoin])
+								continue;
+							if (!lastcoin[ncoin])
+								++coins[ncoin];
+							newcoin[ncoin] = 1;
 						}
 
 						/* if IPF_RESET set, reset the first CPU */
 						if ((in->type & IPF_RESETCPU) && waspressed[ib] == 0 && !playback)
 						{
@@ -2650,10 +2672,14 @@
 #elif defined XMAME_NET
 	if ( osd_net_active() )
 		osd_net_sync(input_port_value, input_port_defaults);
 #endif /* MAME_NET */
 
+	/* set the last coin status */
+	for(coin=0;coin<COIN_COUNTERS;++coin)
+		lastcoin[coin] = newcoin[coin];
+
 profiler_mark(PROFILER_END);
 }
 
 
 
diff -U 5 --new-file --recursive src.ori/inptport.h src/inptport.h
--- src.ori/inptport.h	2003-09-03 22:06:04.000000000 +0200
+++ src/inptport.h	2003-11-12 20:58:44.000000000 +0100
@@ -87,10 +87,15 @@
 	IPT_OSD_4,
 	IPT_EXTENSION,	/* this is an extension on the previous InputPort, not a real inputport. */
 					/* It is used to store additional parameters for analog inputs */
 
 	/* the following are special codes for user interface handling - not to be used by drivers! */
+	IPT_UI_MODE_NEXT,
+	IPT_UI_MODE_PRED,
+	IPT_UI_RECORD_START,
+	IPT_UI_RECORD_STOP,
+	IPT_UI_TURBO,
 	IPT_UI_CONFIGURE,
 	IPT_UI_ON_SCREEN_DISPLAY,
 	IPT_UI_PAUSE,
 	IPT_UI_RESET_MACHINE,
 	IPT_UI_SHOW_GFX,
diff -U 5 --new-file --recursive src.ori/input.c src/input.c
--- src.ori/input.c	2003-09-03 22:06:04.000000000 +0200
+++ src/input.c	2003-11-12 20:58:44.000000000 +0100
@@ -812,11 +812,11 @@
 {
 	int pressed;
 
 	profiler_mark(PROFILER_INPUT);
 
-	pressed = seq_pressed(input_port_type_seq(code));
+	pressed = osd_input_ui_filter(seq_pressed(input_port_type_seq(code)),code);
 
 	if (pressed)
 	{
 		if (ui_map[code].memory == 0)
 		{
@@ -836,11 +836,11 @@
 	static int counter,inputdelay;
 	int pressed;
 
 	profiler_mark(PROFILER_INPUT);
 
-	pressed = seq_pressed(input_port_type_seq(code));
+	pressed = osd_input_ui_filter(seq_pressed(input_port_type_seq(code)),code);
 
 	if (pressed)
 	{
 		if (ui_map[code].memory == 0)
 		{
diff -U 5 --new-file --recursive src.ori/machine/stvcd.c src/machine/stvcd.c
--- src.ori/machine/stvcd.c	2003-11-11 22:25:56.000000000 +0100
+++ src/machine/stvcd.c	2003-11-17 19:37:44.000000000 +0100
@@ -666,15 +666,17 @@
 
 	logerror("leadout:  %02i:%02i:%02i (addr: %i)\n",
 	CD_toc.leadout.min, CD_toc.leadout.sec, CD_toc.leadout.fra, CD_toc.leadout.fad);
 
 	logerror("\n\nTOC DUMP\n\n");
+	{
 	int oo=0;
 	while (oo<408){
 	logerror("%2x %2x %2x %2x\n", CD_sat_toc[oo],CD_sat_toc[oo+1],CD_sat_toc[oo+2],CD_sat_toc[oo+3]);
 	oo+=4;
 	}
+	}
 
 }
 
 
 void cdb_build_ftree(void){
diff -U 5 --new-file --recursive src.ori/mame.c src/mame.c
--- src.ori/mame.c	2003-08-09 02:53:14.000000000 +0200
+++ src/mame.c	2003-11-12 20:58:44.000000000 +0100
@@ -983,26 +983,20 @@
 	to a given resolution
 -------------------------------------------------*/
 
 static void scale_vectorgames(int gfx_width, int gfx_height, int *width, int *height)
 {
-	double x_scale, y_scale, scale;
-
-	/* compute the scale values */
-	x_scale = (double)gfx_width / (double)(*width);
-	y_scale = (double)gfx_height / (double)(*height);
-
-	/* pick the smaller scale factor */
-	scale = (x_scale < y_scale) ? x_scale : y_scale;
-
-	/* compute the new size */
-	*width = (int)((double)*width * scale);
-	*height = (int)((double)*height * scale);
-
-	/* round to the nearest 4 pixel value */
-	*width &= ~3;
-	*height &= ~3;
+	if (Machine->orientation & ORIENTATION_SWAP_XY)
+	{
+		*width = gfx_height;
+		*height = gfx_width*9/16;
+	}
+	else
+	{
+		*width = gfx_width;
+		*height = gfx_height;
+	}
 }
 
 
 
 /*-------------------------------------------------
diff -U 5 --new-file --recursive src.ori/neomame.mak src/neomame.mak
--- src.ori/neomame.mak	2003-06-09 22:02:00.000000000 +0200
+++ src/neomame.mak	2003-11-12 20:58:44.000000000 +0100
@@ -8,10 +8,11 @@
 EMULATOR_EXE = neomame.exe
 
 # CPUs
 CPUS+=Z80@
 CPUS+=M68000@
+CPUS+=M68020@
 
 # SOUNDs
 SOUNDS+=AY8910@
 SOUNDS+=YM2610@
 
diff -U 5 --new-file --recursive src.ori/osdepend.h src/osdepend.h
--- src.ori/osdepend.h	2003-08-09 02:53:02.000000000 +0200
+++ src/osdepend.h	2003-11-12 20:58:44.000000000 +0100
@@ -391,10 +391,38 @@
       __attribute__ ((format (printf, 1, 2)));
 #else
 void CLIB_DECL logerror(const char *text,...);
 #endif
 
+/* called then the game is reset */
+void osd_reset(void);
+
+/* execute the specified menu (0,1,...) */
+int osd_menu(struct mame_bitmap *bitmap, int sel);
+
+/* filter the user interface input state */
+int osd_input_ui_filter(int result, int type);
+
+/* filter the main exit request */
+int osd_input_exit_filter(int result);
+
+/* filter the input port state */
+int osd_input_port_filter(int result, int type);
+
+/* snapshot saving */
+void osd_save_snapshot(void);
+
+/* start and stop the video/sound recording. */
+void osd_record_start(void);
+void osd_record_stop(void);
+
+/* customize the inputport after they are read from the .cfg file */
+void osd_customize_inputport_current(struct InputPort* current);
+
+/* handle the specific user interface */
+int osd_handle_user_interface(struct mame_bitmap *bitmap, int is_menu_active);
+
 #ifdef __cplusplus
 }
 #endif
 
 #endif
diff -U 5 --new-file --recursive src.ori/rules.mak src/rules.mak
--- src.ori/rules.mak	2003-11-11 22:25:56.000000000 +0100
+++ src/rules.mak	2003-11-12 20:58:44.000000000 +0100
@@ -1010,16 +1010,16 @@
 CPUOBJS += $(OBJ)/$(G6D)/g65816o1.o
 CPUOBJS += $(OBJ)/$(G6D)/g65816o2.o
 CPUOBJS += $(OBJ)/$(G6D)/g65816o3.o
 CPUOBJS += $(OBJ)/$(G6D)/g65816o4.o
 DBGOBJS += $(OBJ)/$(G6D)/g65816ds.o
-$(OBJ)/$(G6D)/g65816.o: $(G6D)/g65816.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
-$(OBJ)/$(G6D)/g65816o0.o: $(G6D)/g65816o0.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
-$(OBJ)/$(G6D)/g65816o1.o: $(G6D)/g65816o0.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
-$(OBJ)/$(G6D)/g65816o2.o: $(G6D)/g65816o0.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
-$(OBJ)/$(G6D)/g65816o3.o: $(G6D)/g65816o0.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
-$(OBJ)/$(G6D)/g65816o4.o: $(G6D)/g65816o0.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
+$(OBJ)/$(G6D)/g65816.o: g65816.c g65816.h g65816cm.h g65816op.h
+$(OBJ)/$(G6D)/g65816o0.o: g65816o0.c g65816.h g65816cm.h g65816op.h
+$(OBJ)/$(G6D)/g65816o1.o: g65816o0.c g65816.h g65816cm.h g65816op.h
+$(OBJ)/$(G6D)/g65816o2.o: g65816o0.c g65816.h g65816cm.h g65816op.h
+$(OBJ)/$(G6D)/g65816o3.o: g65816o0.c g65816.h g65816cm.h g65816op.h
+$(OBJ)/$(G6D)/g65816o4.o: g65816o0.c g65816.h g65816cm.h g65816op.h
 else
 CPUDEFS += -DHAS_G65816=0
 endif
 
 CPU=$(strip $(findstring SPC700@,$(CPUS)))
@@ -1027,11 +1027,11 @@
 SPCD = cpu/spc700
 OBJDIRS += $(OBJ)/$(SPCD)
 CPUDEFS += -DHAS_SPC700=1
 CPUOBJS += $(OBJ)/$(SPCD)/spc700.o
 DBGOBJS += $(OBJ)/$(SPCD)/spc700ds.o
-$(OBJ)/$(SPCD)/spc700/spc700.o: $(SPCD)/spc700.c $(SPCD)/spc700.h
+$(OBJ)/$(SPCD)/spc700.o: spc700.c spc700.h
 else
 CPUDEFS += -DHAS_SPC700=0
 endif
 
 CPU=$(strip $(findstring E132XS@,$(CPUS)))
@@ -1070,13 +1070,13 @@
 
 SOUND=$(strip $(findstring DISCRETE@,$(SOUNDS)))
 ifneq ($(SOUND),)
 SOUNDDEFS += -DHAS_DISCRETE=1
 SOUNDOBJS += $(OBJ)/sound/discrete.o
-$(OBJ)/sound/discrete.o: src/sound/discrete.c src/sound/discrete.h \
-		src/sound/disc_dev.c src/sound/disc_flt.c src/sound/disc_inp.c \
-		src/sound/disc_mth.c src/sound/disc_out.c src/sound/disc_wav.c
+$(OBJ)/sound/discrete.o: discrete.c discrete.h \
+		disc_dev.c disc_flt.c disc_inp.c \
+		disc_mth.c disc_out.c disc_wav.c
 else
 SOUNDDEFS += -DHAS_DISCRETE=0
 endif
 
 SOUND=$(strip $(findstring AY8910@,$(SOUNDS)))
diff -U 5 --new-file --recursive src.ori/ui_text.c src/ui_text.c
--- src.ori/ui_text.c	2003-09-03 22:06:06.000000000 +0200
+++ src/ui_text.c	2003-11-12 20:58:44.000000000 +0100
@@ -240,10 +240,14 @@
 	"Restoration successful",
 	"Select a value",
 	"All values saved",
 	"One match found - added to list",
 
+	/* addendum */
+	"Center",
+	"Video",
+
 	NULL
 };
 
 int uistring_init (mame_file *langfile)
 {
diff -U 5 --new-file --recursive src.ori/ui_text.h src/ui_text.h
--- src.ori/ui_text.h	2003-09-03 22:06:06.000000000 +0200
+++ src/ui_text.h	2003-11-12 20:58:44.000000000 +0100
@@ -206,10 +206,14 @@
 	UI_search_OK,
 	UI_search_select_value,
 	UI_search_all_values_saved,
 	UI_search_one_match_found_added,
 
+	/* addendum */
+	UI_center,
+	UI_osdmenu,
+
 	UI_last_entry
 };
 
 struct lang_struct
 {
diff -U 5 --new-file --recursive src.ori/usrintrf.c src/usrintrf.c
--- src.ori/usrintrf.c	2003-11-11 22:25:56.000000000 +0100
+++ src/usrintrf.c	2003-11-12 21:00:16.000000000 +0100
@@ -858,12 +858,16 @@
 	while (items[i])
 	{
 		len = 3 + strlen(items[i]);
 		if (subitems && subitems[i])
 			len += 2 + strlen(subitems[i]);
-		if (len > maxlen && len <= highlen)
-			maxlen = len;
+		if (len > maxlen) {
+			if (len <= highlen)
+				maxlen = len;
+			else
+				maxlen = highlen;
+		}
 		i++;
 	}
 	count = i;
 
 	visible = uirotheight / (3 * uirotcharheight / 2) - 1;
@@ -931,15 +935,27 @@
 				dt[curr_dt].y = topoffs + (3*i+1)*uirotcharheight/2;
 				curr_dt++;
 			}
 			else
 			{
-				dt[curr_dt].text = items[item];
-				dt[curr_dt].color = UI_COLOR_NORMAL;
-				dt[curr_dt].x = (uirotwidth - uirotcharwidth * strlen(items[item])) / 2;
-				dt[curr_dt].y = topoffs + (3*i+1)*uirotcharheight/2;
-				curr_dt++;
+				unsigned y = topoffs + (3*i+1)*uirotcharheight/2;
+				int color = (flag && flag[item]) ? UI_COLOR_INVERSE : UI_COLOR_NORMAL;
+				len = strlen(items[item]);
+				if (len > maxlen - 3) {
+					unsigned x;
+					const char* dot = "...";
+					len = maxlen - 3;
+					x = (uirotwidth - uirotcharwidth * len) / 2;
+					ui_text_ex(bitmap,items[item],items[item] + len - 3,x,y,color);
+					ui_text_ex(bitmap,dot,dot+3,x + uirotcharwidth * (len - 3),y,color);
+				} else {
+					dt[curr_dt].text = items[item];
+					dt[curr_dt].color = color;
+					dt[curr_dt].x = (uirotwidth - uirotcharwidth * len) / 2;
+					dt[curr_dt].y = y;
+					curr_dt++;
+				}
 			}
 		}
 	}
 
 	i = selected - topitem;
@@ -1518,11 +1534,11 @@
 				}
 			}
 		}
 
 		if (input_ui_pressed(IPT_UI_SNAPSHOT))
-			save_screen_snapshot(bitmap);
+			osd_save_snapshot();
 	} while (!input_ui_pressed(IPT_UI_SHOW_GFX) &&
 			!input_ui_pressed(IPT_UI_CANCEL));
 
 	schedule_full_refresh();
 }
@@ -2076,13 +2092,13 @@
 		in++;
 	}
 
 	if (total == 0) return 0;
 
-	/* Each analog control has 3 entries - key & joy delta, reverse, sensitivity */
+	/* Each analog control has 4 entries - key & joy delta, reverse, sensitivity */
 
-#define ENTRIES 3
+#define ENTRIES 4
 
 	total2 = total * ENTRIES;
 
 	menu_item[total2] = ui_getstring (UI_returntomain);
 	menu_item[total2 + 1] = 0;	/* terminate array */
@@ -2095,15 +2111,17 @@
 		{
 			char label[30][40];
 			char setting[30][40];
 			int sensitivity,delta;
 			int reverse;
+			int center;
 
 			strcpy (label[i], input_port_name(entry[i/ENTRIES]));
 			sensitivity = IP_GET_SENSITIVITY(entry[i/ENTRIES]);
 			delta = IP_GET_DELTA(entry[i/ENTRIES]);
 			reverse = (entry[i/ENTRIES]->type & IPF_REVERSE);
+			center = (entry[i/ENTRIES]->type & IPF_CENTER);
 
 			strcat (label[i], " ");
 			switch (i%ENTRIES)
 			{
 				case 0:
@@ -2122,10 +2140,18 @@
 				case 2:
 					strcat (label[i], ui_getstring (UI_sensitivity));
 					sprintf(setting[i],"%3d%%",sensitivity);
 					if (i == sel) arrowize = 3;
 					break;
+				case 3:
+					strcat (label[i], ui_getstring (UI_center));
+					if (center)
+						strcpy(setting[i],ui_getstring (UI_on));
+					else
+						strcpy(setting[i],ui_getstring (UI_off));
+					if (i == sel) arrowize = 3;
+					break;
 			}
 
 			menu_item[i] = label[i];
 			menu_subitem[i] = setting[i];
 
@@ -2173,10 +2199,21 @@
 
 				val --;
 				if (val < 1) val = 1;
 				IP_SET_SENSITIVITY(entry[sel/ENTRIES],val);
 			}
+			else if ((sel % ENTRIES) == 3)
+			/* center */
+			{
+				int center = entry[sel/ENTRIES]->type & IPF_CENTER;
+				if (center)
+					center=0;
+				else
+					center=IPF_CENTER;
+				entry[sel/ENTRIES]->type &= ~IPF_CENTER;
+				entry[sel/ENTRIES]->type |= center;
+			}
 		}
 	}
 
 	if (input_ui_pressed_repeat(IPT_UI_RIGHT,8))
 	{
@@ -2209,10 +2246,21 @@
 
 				val ++;
 				if (val > 255) val = 255;
 				IP_SET_SENSITIVITY(entry[sel/ENTRIES],val);
 			}
+			else if ((sel % ENTRIES) == 3)
+			/* center */
+			{
+				int center = entry[sel/ENTRIES]->type & IPF_CENTER;
+				if (center)
+					center=0;
+				else
+					center=IPF_CENTER;
+				entry[sel/ENTRIES]->type &= ~IPF_CENTER;
+				entry[sel/ENTRIES]->type |= center;
+			}
 		}
 	}
 
 	if (input_ui_pressed(IPT_UI_SELECT))
 	{
@@ -2516,14 +2564,16 @@
 
 int showgamewarnings(struct mame_bitmap *bitmap)
 {
 	int i;
 	char buf[2048];
+	unsigned mask = GAME_NOT_WORKING | GAME_UNEMULATED_PROTECTION | GAME_WRONG_COLORS | GAME_NO_SOUND;
+
+	if (!options.skip_gameinfo)
+		mask |= GAME_IMPERFECT_COLORS | GAME_IMPERFECT_SOUND | GAME_IMPERFECT_GRAPHICS | GAME_NO_COCKTAIL;
 
-	if (Machine->gamedrv->flags &
-			(GAME_NOT_WORKING | GAME_UNEMULATED_PROTECTION | GAME_WRONG_COLORS | GAME_IMPERFECT_COLORS |
-			  GAME_NO_SOUND | GAME_IMPERFECT_SOUND | GAME_IMPERFECT_GRAPHICS | GAME_NO_COCKTAIL))
+	if ((Machine->gamedrv->flags & mask) != 0)
 	{
 		int done;
 
 		strcpy(buf, ui_getstring (UI_knownproblems));
 		strcat(buf, "\n\n");
@@ -3083,16 +3133,16 @@
 
 
 #ifndef MESS
 enum { UI_SWITCH = 0,UI_DEFCODE,UI_CODE,UI_ANALOG,UI_CALIBRATE,
 		UI_STATS,UI_GAMEINFO, UI_HISTORY,
-		UI_CHEAT,UI_RESET,UI_MEMCARD,UI_RAPIDFIRE,UI_EXIT };
+		UI_CHEAT,UI_RESET,UI_MEMCARD,UI_RAPIDFIRE,UI_EXIT,UI_OSD };
 #else
 enum { UI_SWITCH = 0,UI_DEFCODE,UI_CODE,UI_ANALOG,UI_CALIBRATE,
 		UI_GAMEINFO, UI_IMAGEINFO,UI_FILEMANAGER,UI_TAPECONTROL,
 		UI_HISTORY,UI_CHEAT,UI_RESET,UI_MEMCARD,UI_RAPIDFIRE,UI_EXIT,
-		UI_CONFIGURATION };
+		UI_CONFIGURATION,UI_OSD };
 #endif
 
 
 #ifdef XMAME
 extern int setrapidfire(struct mame_bitmap *bitmap, int selected);
@@ -3208,10 +3258,11 @@
 #endif
 #endif
 #endif
 #endif
 
+	menu_item[menu_total] = ui_getstring (UI_osdmenu); menu_action[menu_total++] = UI_OSD;
 	menu_item[menu_total] = ui_getstring (UI_resetgame); menu_action[menu_total++] = UI_RESET;
 	menu_item[menu_total] = ui_getstring (UI_returntogame); menu_action[menu_total++] = UI_EXIT;
 	menu_item[menu_total] = 0; /* terminate array */
 }
 
@@ -3278,10 +3329,13 @@
 				res = displayhistory(bitmap, sel >> SEL_BITS);
 				break;
 			case UI_CHEAT:
 				res = cheat_menu(bitmap, sel >> SEL_BITS);
 				break;
+			case UI_OSD :
+				res = osd_menu(bitmap, sel >> SEL_BITS);
+				break;
 #ifndef MESS
 #ifndef TINY_COMPILE
 #ifndef CPSMAME
 #ifndef MMSND
 			case UI_MEMCARD:
@@ -3336,10 +3390,11 @@
 			case UI_CONFIGURATION:
 #endif /* !MESS */
 			case UI_HISTORY:
 			case UI_CHEAT:
 			case UI_MEMCARD:
+			case UI_OSD :
 				sel |= 1 << SEL_BITS;
 				schedule_full_refresh();
 				break;
 
 			case UI_RESET:
@@ -4025,22 +4080,23 @@
 {
 #ifdef MESS
 	extern int mess_pause_for_ui;
 #endif
 
-	/* if the user pressed F12, save the screen to a file */
+	if (osd_handle_user_interface(bitmap, setup_selected != 0) != 0)
+		return 1;
+
 	if (input_ui_pressed(IPT_UI_SNAPSHOT))
-		save_screen_snapshot(bitmap);
+		osd_save_snapshot();
+	if (input_ui_pressed(IPT_UI_RECORD_START))
+		osd_record_start();
+	if (input_ui_pressed(IPT_UI_RECORD_STOP))
+		osd_record_stop();
 
 	/* This call is for the cheat, it must be called once a frame */
 	if (options.cheat) DoCheat(bitmap);
 
-	/* if the user pressed ESC, stop the emulation */
-	/* but don't quit if the setup menu is on screen */
-	if (setup_selected == 0 && input_ui_pressed(IPT_UI_CANCEL))
-		return 1;
-
 	if (setup_selected == 0 && input_ui_pressed(IPT_UI_CONFIGURE))
 	{
 		setup_selected = -1;
 		if (osd_selected != 0)
 		{
@@ -4154,12 +4210,15 @@
 				draw_screen();
 			}
 			profiler_mark(PROFILER_END);
 
 			if (input_ui_pressed(IPT_UI_SNAPSHOT))
-				save_screen_snapshot(bitmap);
-
+				osd_save_snapshot();
+			if (input_ui_pressed(IPT_UI_RECORD_START))
+				osd_record_start();
+			if (input_ui_pressed(IPT_UI_RECORD_STOP))
+				osd_record_stop();
 
 			if (input_ui_pressed(IPT_UI_SAVE_STATE))
 				do_loadsave(bitmap, LOADSAVE_SAVE);
 
 			if (input_ui_pressed(IPT_UI_LOAD_STATE))
@@ -4168,11 +4227,11 @@
 			/* if the user pressed F4, show the character set */
 			if (input_ui_pressed(IPT_UI_SHOW_GFX))
 				showcharset(bitmap);
 
 			if (setup_selected == 0 && input_ui_pressed(IPT_UI_CANCEL))
-				return 1;
+				break;
 
 			if (setup_selected == 0 && input_ui_pressed(IPT_UI_CONFIGURE))
 			{
 				setup_selected = -1;
 				if (osd_selected != 0)
diff -U 5 --new-file --recursive src.ori/vidhrdw/cave.c src/vidhrdw/cave.c
--- src.ori/vidhrdw/cave.c	2003-08-09 02:53:14.000000000 +0200
+++ src/vidhrdw/cave.c	2003-11-12 20:58:44.000000000 +0100
@@ -1424,10 +1424,13 @@
 VIDEO_UPDATE( cave )
 {
 	int pri, pri2;
 	int layers_ctrl = -1;
 
+	/* Update the destination pointer. With SMP active it changes from one frame to another. */
+	blit.baseaddr = Machine->scrbitmap->line[0];
+
 	/* Choose the tilemap to display (8x8 tiles or 16x16 tiles) */
 	if (tilemap_0)
 	{	tiledim_0 = cave_vctrl_0[ 1 ] & 0x2000;
 		if (tiledim_0 != old_tiledim_0)	tilemap_mark_all_tiles_dirty(tilemap_0);
 		old_tiledim_0 = tiledim_0;		}
diff -U 5 --new-file --recursive src.ori/vidhrdw/voodoo.c src/vidhrdw/voodoo.c
--- src.ori/vidhrdw/voodoo.c	2003-11-11 22:25:56.000000000 +0100
+++ src/vidhrdw/voodoo.c	2003-11-17 19:47:17.000000000 +0100
@@ -11,11 +11,13 @@
 #include "cpu/mips/mips3.h"
 #include <math.h>
 
 
 /* math trickery */
-#ifndef _WIN32
+#if 1 /* this is the only portable implementation */
+#define floorf floor
+#define sqrtf sqrt
 #define SETUP_FPU()
 #define RESTORE_FPU()
 #define TRUNC_TO_INT(f) (floorf(f))
 #else
 #include <float.h>
