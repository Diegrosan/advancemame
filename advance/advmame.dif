diff -U 5 --new-file --recursive src.ori/advance.pat src/advance.pat
--- src.ori/advance.pat	1970-01-01 01:00:00.000000000 +0100
+++ src/advance.pat	2005-01-04 16:23:42.000000000 +0100
@@ -0,0 +1 @@
+These files are patched for the use with the Advance emulator.
diff -U 5 --new-file --recursive src.ori/common.c src/common.c
--- src.ori/common.c	2004-10-24 22:51:56.000000000 +0200
+++ src/common.c	2005-01-04 16:23:42.000000000 +0100
@@ -779,10 +779,11 @@
 	the given filename
 -------------------------------------------------*/
 
 void save_screen_snapshot_as(mame_file *fp, struct mame_bitmap *bitmap)
 {
+#if 0 /* AdvanceMAME has its snapshot code */
 	struct rectangle bounds;
 	struct mame_bitmap *osdcopy;
 	UINT32 saved_rgb_components[3];
 
 	/* allow the artwork system to override certain parameters */
@@ -877,20 +878,24 @@
 	memcpy(direct_rgb_components, saved_rgb_components, sizeof(saved_rgb_components));
 
 	/* if the OSD system allocated a bitmap; free it */
 	if (osdcopy)
 		bitmap_free(osdcopy);
+#endif
 }
 
 
 
 /*-------------------------------------------------
 	save_screen_snapshot - save a screen snapshot
 -------------------------------------------------*/
 
 void save_screen_snapshot(struct mame_bitmap *bitmap)
 {
+#if 1 /* AdvanceMAME has its snapshot code */
+	osd_save_snapshot();
+#else
 	char name[20];
 	mame_file *fp;
 
 	/* avoid overwriting existing files */
 	/* first of all try with "gamename.png" */
@@ -907,10 +912,11 @@
 	if ((fp = mame_fopen(Machine->gamedrv->name, name, FILETYPE_SCREENSHOT, 1)) != NULL)
 	{
 		save_screen_snapshot_as(fp, bitmap);
 		mame_fclose(fp);
 	}
+#endif
 }
 
 
 
 /***************************************************************************
@@ -1265,11 +1271,11 @@
 		}
 		else
 			strcat(romdata->errorbuf, "WARNING: the game might not run correctly.\n");
 
 		/* display the result */
-		printf("%s", romdata->errorbuf);
+		osd_display_loading_rom_message(romdata->errorbuf, 0);
 
 		/* if we're not getting out of here, wait for a keypress */
 		if (!options.gui_host && !options.skip_warnings && !bailing)
 		{
 			int k;
diff -U 5 --new-file --recursive src.ori/cpu/i8085/i8085.c src/cpu/i8085/i8085.c
--- src.ori/cpu/i8085/i8085.c	2004-10-24 22:51:56.000000000 +0200
+++ src/cpu/i8085/i8085.c	2005-01-04 16:23:42.000000000 +0100
@@ -110,10 +110,16 @@
  * 
  *****************************************************************************/
 
 /*int survival_prot = 0; */
 
+#if defined(__GNUC__) && __GNUC__ >= 3
+/* Disable all the asm macro and the big switch */
+#undef X86_ASM
+#define BIG_SWITCH 0
+#endif
+
 #define VERBOSE 0
 
 #include "driver.h"
 #include "state.h"
 #include "osd_cpu.h"
diff -U 5 --new-file --recursive src.ori/cpu/m68000/make68k.c src/cpu/m68000/make68k.c
--- src.ori/cpu/m68000/make68k.c	2004-05-06 18:22:10.000000000 +0200
+++ src/cpu/m68000/make68k.c	2005-01-04 16:23:42.000000000 +0100
@@ -191,11 +191,11 @@
 
 
 #define NORMAL 0
 #define PCREL  1
 
-#ifdef __ELF__
+#if defined(USE_OBJ_ELF)
 #define PREF ""
 #else
 #define PREF "_"
 #endif
 
@@ -252,17 +252,17 @@
 
 
 
 /* External register preservation */
 
-#ifdef DOS
+#if defined(USE_COMPILER_GNUC)
 
 /* Registers normally saved around C routines anyway */
 /* GCC 2.9.1 (dos) seems to preserve EBX,EDI and EBP */
 static char SavedRegs[] = "-B--SDB";
 
-#elif defined(WIN32)
+#elif defined(USE_COMPILER_VISUALC)
 
 /* visual C++, win32, says it preserves ebx, edi, esi, and ebp */
 /* ---------- VC++ deosn't preserve EDI? (Kenjo, 110399) ---------- */
 static char SavedRegs[] = "-B--S-B";
 
@@ -8040,11 +8040,11 @@
 	fprintf(fp, "\t\tDW   0,0,0\n\n");
 
 
 /* If Win32, put the table area in .data section (Kenjo) */
 
-#ifdef WIN32
+#if defined(USE_OS_WINDOWS)
 
 	fprintf(fp, "%s_OPCODETABLE\tTIMES  65536  DD 0\n\n", CPUtype);
 
 #else
 
diff -U 5 --new-file --recursive src.ori/cpu/z80/z80.c src/cpu/z80/z80.c
--- src.ori/cpu/z80/z80.c	2004-12-17 22:04:14.000000000 +0100
+++ src/cpu/z80/z80.c	2005-01-04 16:23:42.000000000 +0100
@@ -91,10 +91,16 @@
 #include "cpuintrf.h"
 #include "state.h"
 #include "mamedbg.h"
 #include "z80.h"
 
+#if defined(__GNUC__) && __GNUC__ >= 3
+/* Disable all the asm macro and the big switch */
+#undef X86_ASM
+#define BIG_SWITCH 0
+#endif
+
 #define VERBOSE 0
 
 #if VERBOSE
 #define LOG(x)	logerror x
 #else
diff -U 5 --new-file --recursive src.ori/cpuexec.c src/cpuexec.c
--- src.ori/cpuexec.c	2004-12-17 22:04:14.000000000 +0100
+++ src/cpuexec.c	2005-01-04 16:23:42.000000000 +0100
@@ -323,10 +323,13 @@
 	watchdog_setup();
 
 	/* reset sound chips */
 	sound_reset();
 
+	/* reset the osd level */
+	osd_reset();
+
 	/* first pass over CPUs */
 	for (cpunum = 0; cpunum < cpu_gettotalcpu(); cpunum++)
 	{
 		/* enable all CPUs (except for audio CPUs if the sound is off) */
 		if (!(Machine->drv->cpu[cpunum].cpu_flags & CPU_AUDIO_CPU) || Machine->sample_rate != 0)
diff -U 5 --new-file --recursive src.ori/drivers/multi32.c src/drivers/multi32.c
--- src.ori/drivers/multi32.c	2004-11-23 18:05:46.000000000 +0100
+++ src/drivers/multi32.c	2005-01-04 16:23:42.000000000 +0100
@@ -846,11 +846,11 @@
 	MDRV_NVRAM_HANDLER(system32)
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES(VIDEO_TYPE_RASTER | VIDEO_NEEDS_6BITS_PER_GUN | VIDEO_UPDATE_AFTER_VBLANK | VIDEO_RGB_DIRECT | VIDEO_HAS_SHADOWS ) // RGB_DIRECT will be needed for alpha
 	MDRV_SCREEN_SIZE(52*8*2, 28*8*2)
-	MDRV_VISIBLE_AREA(0*8, 52*8*2-1, 0*8, 28*8*2-1)
+	MDRV_VISIBLE_AREA(0, 320-1, 0, 224-1)
 
 	MDRV_GFXDECODE(gfxdecodeinfo)
 	MDRV_PALETTE_LENGTH(32768)
 
 	MDRV_VIDEO_START(system32)
diff -U 5 --new-file --recursive src.ori/drivers/namcos11.c src/drivers/namcos11.c
--- src.ori/drivers/namcos11.c	2004-08-05 21:50:16.000000000 +0200
+++ src/drivers/namcos11.c	2005-01-04 16:23:42.000000000 +0100
@@ -655,11 +655,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 8, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type1 )
 	MDRV_VIDEO_UPDATE( psx )
diff -U 5 --new-file --recursive src.ori/drivers/namcos12.c src/drivers/namcos12.c
--- src.ori/drivers/namcos12.c	2004-09-21 18:10:28.000000000 +0200
+++ src/drivers/namcos12.c	2005-01-04 16:23:42.000000000 +0100
@@ -469,11 +469,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 480-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
diff -U 5 --new-file --recursive src.ori/drivers/psikyo4.c src/drivers/psikyo4.c
--- src.ori/drivers/psikyo4.c	2004-09-21 18:10:28.000000000 +0200
+++ src/drivers/psikyo4.c	2005-01-04 16:23:42.000000000 +0100
@@ -412,13 +412,13 @@
 	MDRV_NVRAM_HANDLER(93C56)
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES(VIDEO_TYPE_RASTER | VIDEO_NEEDS_6BITS_PER_GUN | VIDEO_DUAL_MONITOR)
 #if DUAL_SCREEN
-	MDRV_ASPECT_RATIO(8,3)
+	MDRV_ASPECT_RATIO(4,3)
 	MDRV_SCREEN_SIZE(80*8, 32*8)
-	MDRV_VISIBLE_AREA(0, 80*8-1, 0, 28*8-1)
+	MDRV_VISIBLE_AREA(0, 320-1, 0, 28*8-1)
 #else
 	MDRV_ASPECT_RATIO(4,3)
 	MDRV_SCREEN_SIZE(64*8, 32*8)
 	MDRV_VISIBLE_AREA(0, 40*8-1, 0, 28*8-1)
 #endif
@@ -437,11 +437,11 @@
 static MACHINE_DRIVER_START( ps4small )
 	/* basic machine hardware */
 	MDRV_IMPORT_FROM(ps4big)
 
 #if DUAL_SCREEN
-	MDRV_VISIBLE_AREA(0, 80*8-1, 0, 30*8-1)
+	MDRV_VISIBLE_AREA(0, 320-1, 0, 30*8-1)
 #else
 	MDRV_VISIBLE_AREA(0, 40*8-1, 0, 30*8-1)
 #endif
 MACHINE_DRIVER_END
 
diff -U 5 --new-file --recursive src.ori/drivers/stv.c src/drivers/stv.c
--- src.ori/drivers/stv.c	2004-12-29 00:08:18.000000000 +0100
+++ src/drivers/stv.c	2005-01-04 16:23:42.000000000 +0100
@@ -3921,11 +3921,11 @@
 	MDRV_NVRAM_HANDLER(93C46) /* Actually 93c45 */
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES(VIDEO_TYPE_RASTER | VIDEO_UPDATE_AFTER_VBLANK | VIDEO_RGB_DIRECT )
 	MDRV_SCREEN_SIZE(1024, 1024)
-	MDRV_VISIBLE_AREA(0*8, 703, 0*8, 479) // we need to use a resolution as high as the max size it can change to
+	MDRV_VISIBLE_AREA(0*8, 320-1, 0*8, 224-1)
 	MDRV_PALETTE_LENGTH(2048+(2048*2))//standard palette + extra memory for rgb brightness.
 	MDRV_GFXDECODE(gfxdecodeinfo)
 
 	MDRV_VIDEO_START(stv_vdp2)
 	MDRV_VIDEO_UPDATE(stv_vdp2)
diff -U 5 --new-file --recursive src.ori/drivers/zn.c src/drivers/zn.c
--- src.ori/drivers/zn.c	2004-12-17 22:04:08.000000000 +0100
+++ src/drivers/zn.c	2005-01-04 16:23:42.000000000 +0100
@@ -620,11 +620,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 512 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -655,11 +655,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -856,11 +856,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -1281,11 +1281,11 @@
 	MDRV_NVRAM_HANDLER( coh1000ta )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 512 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -1374,11 +1374,11 @@
 	MDRV_NVRAM_HANDLER( coh1000tb )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -1560,11 +1560,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -1770,11 +1770,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -2014,11 +2014,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 320-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -2347,11 +2347,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -2594,11 +2594,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 320-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -2861,11 +2861,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 480-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -2894,11 +2894,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 320-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -2926,11 +2926,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 320-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
diff -U 5 --new-file --recursive src.ori/inptport.c src/inptport.c
--- src.ori/inptport.c	2004-11-23 18:05:40.000000000 +0100
+++ src/inptport.c	2005-01-16 13:52:45.000000000 +0100
@@ -868,26 +868,21 @@
 
 	/* start with the raw defaults and ask the OSD to customize them in the backup array */
 	memcpy(inputport_list_backup, inputport_list_defaults, sizeof(inputport_list_backup));
 	osd_customize_inputport_list(inputport_list_backup);
 
-	/* load the controller-specific info -- note that even though we are still modifying */
-	/* the inputport_list_backup, token_to_port_type relies on inputport_list being valid */
-	memcpy(inputport_list, inputport_list_backup, sizeof(inputport_list));
-	if (options.controller != NULL)
-	{
-		loaded = config_load_controller(options.controller, inputport_list_backup);
-		if (!loaded)
-			osd_die("Could not load controller file %s.cfg\n", options.controller);
-	}
-
 	/* propogate that forward to the live list and apply the config on top of that */
 	memcpy(inputport_list, inputport_list_backup, sizeof(inputport_list));
-	config_load_default(inputport_list_backup, inputport_list);
 
-	/* now load the game-specific info */
-	loaded = config_load(Machine->input_ports_default, Machine->input_ports);
+	/* AdvanceMAME: Load user defined customization */
+	osd_config_load_default(inputport_list_backup, inputport_list);
+
+	/* AdvanceMAME: Load user defined customization */
+	osd_config_load(Machine->input_ports_default, Machine->input_ports);
+
+	/* AdvanceMAME: Report no setting loaded, always show the disclaimer */
+	loaded = 0;
 
 	/* initialize the various port states */
 	inputport_init();
 
 	/* if we didn't find a saved config, return 0 so the main core knows that it */
@@ -897,12 +892,16 @@
 
 
 void save_input_port_settings(void)
 {
 	/* save the default config and the game-specific config */
-	config_save_default(inputport_list_backup, inputport_list);
-	config_save(Machine->input_ports_default, Machine->input_ports);
+
+	/* AdvanceMAME: Save user defined customization */
+	osd_config_save_default(inputport_list_backup, inputport_list);
+
+	/* AdvanceMAME: Save user defined customization */
+	osd_config_save(Machine->input_ports_default, Machine->input_ports);
 }
 
 
 
 /*************************************
@@ -1428,12 +1427,18 @@
 {
 	int listnum;
 
 	/* search the defaults for the type */
 	for (listnum = 0; inputport_list[listnum].type != IPT_END; listnum++)
-		if (inputport_list[listnum].type == type && inputport_list[listnum].player == player)
-			return seq_pressed(&inputport_list[listnum].defaultseq);
+		if (inputport_list[listnum].type == type && inputport_list[listnum].player == player) {
+			int pressed = seq_pressed(&inputport_list[listnum].defaultseq);
+
+			/* AdvanceMAME: Filter all the input ports */
+			pressed = osd_input_port_filter(pressed, inputport_list[listnum].type, inputport_list[listnum].player, SEQ_TYPE_STANDARD);
+
+			return pressed;
+		}
 
 	return 0;
 }
 
 
@@ -1444,10 +1449,13 @@
 profiler_mark(PROFILER_INPUT);
 
 	/* get the status of this key (assumed to be only in the defaults) */
 	pressed = seq_pressed(input_port_default_seq(code, 0, SEQ_TYPE_STANDARD));
 
+	/* AdvanceMAME: Filter all the input ports */
+	pressed = osd_input_port_filter(pressed, code, 0, SEQ_TYPE_STANDARD);
+
 	/* if pressed, handle it specially */
 	if (pressed)
 	{
 		/* if this is the first press, leave pressed = 1 */
 		if (ui_memory[code] == 0)
@@ -1477,10 +1485,13 @@
 profiler_mark(PROFILER_INPUT);
 
 	/* get the status of this key (assumed to be only in the defaults) */
 	pressed = seq_pressed(input_port_default_seq(code, 0, SEQ_TYPE_STANDARD));
 
+	/* AdvanceMAME: Filter all the input ports */
+	pressed = osd_input_port_filter(pressed, code, 0, SEQ_TYPE_STANDARD);
+
 	/* if so, handle it specially */
 	if (pressed)
 	{
 		/* if this is the first press, set a 3x delay and leave pressed = 1 */
 		if (ui_memory[code] == 0)
@@ -1549,10 +1560,13 @@
 void inputport_vblank_start(void)
 {
 	int ui_visible = setup_active() || onscrd_active();
 	int portnum, bitnum;
 
+	/* AdvanceMAME: Never disable the input port. */
+	ui_visible = 0;
+
 profiler_mark(PROFILER_INPUT);
 
 	/* update the digital joysticks first */
 	update_digital_joysticks();
 
@@ -1583,11 +1597,16 @@
 
 			/* handle non-analog types, but only when the UI isn't visible */
 			else if (!IS_ANALOG(port) && !ui_visible)
 			{
 				/* if the sequence for this port is currently pressed.... */
-				if (seq_pressed(input_port_seq(port, SEQ_TYPE_STANDARD)))
+				int pressed = seq_pressed(input_port_seq(port, SEQ_TYPE_STANDARD));
+
+				/* AdvanceMAME: Filter all the input ports */
+				pressed = osd_input_port_filter(pressed, port->type, port->player, SEQ_TYPE_STANDARD);
+
+				if (pressed)
 				{
 #ifdef MESS
 					/* (MESS-specific) check for disabled keyboard */
 					if (port->type == IPT_KEYBOARD && osd_keyboard_disabled())
 						continue;
@@ -1715,17 +1734,18 @@
 			{
 				info->previous = info->current;
 				info->current = 0;
 
 				/* read all the associated ports */
-				if (info->port[JOYDIR_UP] != NULL && seq_pressed(input_port_seq(info->port[JOYDIR_UP], SEQ_TYPE_STANDARD)))
+				/* AdvanceMAME: Filter all the input ports */
+				if (info->port[JOYDIR_UP] != NULL && osd_input_port_filter(seq_pressed(input_port_seq(info->port[JOYDIR_UP], SEQ_TYPE_STANDARD)), info->port[JOYDIR_UP]->type, info->port[JOYDIR_UP]->player, SEQ_TYPE_STANDARD))
 					info->current |= JOYDIR_UP_BIT;
-				if (info->port[JOYDIR_DOWN] != NULL && seq_pressed(input_port_seq(info->port[JOYDIR_DOWN], SEQ_TYPE_STANDARD)))
+				if (info->port[JOYDIR_DOWN] != NULL && osd_input_port_filter(seq_pressed(input_port_seq(info->port[JOYDIR_DOWN], SEQ_TYPE_STANDARD)), info->port[JOYDIR_DOWN]->type, info->port[JOYDIR_DOWN]->player, SEQ_TYPE_STANDARD))
 					info->current |= JOYDIR_DOWN_BIT;
-				if (info->port[JOYDIR_LEFT] != NULL && seq_pressed(input_port_seq(info->port[JOYDIR_LEFT], SEQ_TYPE_STANDARD)))
+				if (info->port[JOYDIR_LEFT] != NULL && osd_input_port_filter(seq_pressed(input_port_seq(info->port[JOYDIR_LEFT], SEQ_TYPE_STANDARD)), info->port[JOYDIR_LEFT]->type, info->port[JOYDIR_LEFT]->player, SEQ_TYPE_STANDARD))
 					info->current |= JOYDIR_LEFT_BIT;
-				if (info->port[JOYDIR_RIGHT] != NULL && seq_pressed(input_port_seq(info->port[JOYDIR_RIGHT], SEQ_TYPE_STANDARD)))
+				if (info->port[JOYDIR_RIGHT] != NULL && osd_input_port_filter(seq_pressed(input_port_seq(info->port[JOYDIR_RIGHT], SEQ_TYPE_STANDARD)), info->port[JOYDIR_RIGHT]->type, info->port[JOYDIR_RIGHT]->player, SEQ_TYPE_STANDARD))
 					info->current |= JOYDIR_RIGHT_BIT;
 
 				/* lock out opposing directions (left + right or up + down) */
 				if ((info->current & (JOYDIR_UP_BIT | JOYDIR_DOWN_BIT)) == (JOYDIR_UP_BIT | JOYDIR_DOWN_BIT))
 					info->current &= ~(JOYDIR_UP_BIT | JOYDIR_DOWN_BIT);
@@ -1836,12 +1856,12 @@
 		int analog_type, keypressed = 0;
 
 		/* clamp the previous value to the min/max range and remember it */
 		info->previous = info->accum = apply_analog_min_max(info, info->accum);
 
-		/* get the new raw analog value and its type */
-		rawvalue = seq_analog_value(input_port_seq(port, SEQ_TYPE_STANDARD), &analog_type);
+		/* AdvanceMAME: Get the analog input for different players from the osd core. */
+		rawvalue = osd_get_analog_value(port->type, port->player, &analog_type);
 
 		/* if we got it from a relative device, use that as the starting delta */
 		/* also note that the last input was not a digital one */
 		if (analog_type == ANALOG_TYPE_RELATIVE && rawvalue != 0)
 		{
@@ -1849,18 +1869,20 @@
 			info->lastdigital = 0;
 		}
 
 		/* if the decrement code sequence is pressed, add the key delta to */
 		/* the accumulated delta; also note that the last input was a digital one */
-		if (seq_pressed(input_port_seq(info->port, SEQ_TYPE_DECREMENT)))
+		/* AdvanceMAME: Filter all the input ports */
+		if (osd_input_port_filter(seq_pressed(input_port_seq(info->port, SEQ_TYPE_DECREMENT)), info->port->type, info->port->player, SEQ_TYPE_DECREMENT))
 		{
 			delta -= (INT32)(port->analog.delta * info->keyscale);
 			keypressed = info->lastdigital = 1;
 		}
 
 		/* same for the increment code sequence */
-		if (seq_pressed(input_port_seq(info->port, SEQ_TYPE_INCREMENT)))
+		/* AdvanceMAME: Filter all the input ports */
+		if (osd_input_port_filter(seq_pressed(input_port_seq(info->port, SEQ_TYPE_INCREMENT)), info->port->type, info->port->player, SEQ_TYPE_INCREMENT))
 		{
 			delta += (INT32)(port->analog.delta * info->keyscale);
 			keypressed = info->lastdigital = 1;
 		}
 
@@ -1874,15 +1896,18 @@
 		info->accum += delta;
 
 		/* if we got an absolute input, it overrides everything else */
 		if (analog_type == ANALOG_TYPE_ABSOLUTE)
 		{
-			/* apply the inverse of the sensitivity to the raw value so that */
-			/* it will still cover the full min->max range requested after */
-			/* we apply the sensitivity adjustment */
-			info->accum = APPLY_INVERSE_SENSITIVITY(rawvalue, port->analog.sensitivity);
-			info->lastdigital = 0;
+			/* allow both the analog joystick and the keyboard to control the input port */
+			if (rawvalue != 0 || !info->lastdigital) {
+				/* apply the inverse of the sensitivity to the raw value so that */
+				/* it will still cover the full min->max range requested after */
+				/* we apply the sensitivity adjustment */
+				info->accum = APPLY_INVERSE_SENSITIVITY(rawvalue, port->analog.sensitivity);
+				info->lastdigital = 0;
+			}
 		}
 
 		/* if our last movement was due to a digital input, and if this control */
 		/* type autocenters, and if neither the increment nor the decrement seq */
 		/* was pressed, apply autocentering */
diff -U 5 --new-file --recursive src.ori/input.c src/input.c
--- src.ori/input.c	2004-09-21 20:02:10.000000000 +0200
+++ src/input.c	2005-01-04 16:23:42.000000000 +0100
@@ -603,11 +603,33 @@
 	code_count = 0;
 	free(code_map);
 	code_map = NULL;
 }
 
+os_code_t code_to_oscode(input_code_t code)
+{
+	if (code_map[code].osinfo != NULL)
+		return code_map[code].osinfo->oscode;
+	else
+		return 0;
+}
 
+input_code_t oscode_to_code(os_code_t oscode)
+{
+	unsigned i;
+
+	for(i=0;i<code_count;++i) {
+		if (code_map[i].osinfo != NULL && code_map[i].osinfo->oscode == oscode) {
+			break;
+		}
+	}
+
+	if (i == code_count)
+		return CODE_NONE;
+
+	return i;
+}
 
 /*************************************
  *
  *	Return the analog value of a code.
  *
diff -U 5 --new-file --recursive src.ori/input.h src/input.h
--- src.ori/input.h	2004-09-21 20:02:10.000000000 +0200
+++ src/input.h	2005-01-04 16:23:42.000000000 +0100
@@ -479,10 +479,17 @@
 	CODE_NOT,					/* operators for sequences */
 	CODE_OR						/* operators for sequences */
 };
 
 
+/* AdvanceMAME: Remap the F1 key used by some debug code to an unused key. */
+#ifdef MESS
+#define KEYCODE_F1_REAL KEYCODE_F1
+#else
+#define KEYCODE_F1_REAL (KEYCODE_F2-1)
+#define KEYCODE_F1 KEYCODE_NUMLOCK
+#endif
 
 /*************************************
  *
  *	Type definitions
  *
@@ -530,10 +537,13 @@
 
 /* single code functions */
 int code_init(void);
 void code_close(void);
 
+os_code_t code_to_oscode(input_code_t code);
+input_code_t oscode_to_code(os_code_t oscode);
+
 INT32 code_analog_value(input_code_t code);
 int code_pressed(input_code_t code);
 int code_pressed_memory(input_code_t code);
 int code_pressed_memory_repeat(input_code_t code, int speed);
 input_code_t code_read_async(void);
diff -U 5 --new-file --recursive src.ori/mame.c src/mame.c
--- src.ori/mame.c	2005-01-03 15:05:48.000000000 +0100
+++ src/mame.c	2005-01-04 16:23:42.000000000 +0100
@@ -541,10 +541,15 @@
 		if (options.skip_warnings || showgamewarnings(artwork_get_ui_bitmap()) == 0)
 		{
 			/* show info about the game */
 			if (options.skip_gameinfo || showgameinfo(artwork_get_ui_bitmap()) == 0)
 			{
+				/* AdvanceMAME: Force a video update, otherwise with all the skip options the program crash */
+				fillbitmap(artwork_get_ui_bitmap(), get_black_pen(), NULL);
+				schedule_full_refresh();
+				update_video_and_audio();
+
 				init_user_interface();
 
 				/* enable artwork now */
 				artwork_enable(1);
 
diff -U 5 --new-file --recursive src.ori/osdepend.h src/osdepend.h
--- src.ori/osdepend.h	2004-11-23 18:05:40.000000000 +0100
+++ src/osdepend.h	2005-01-04 16:23:42.000000000 +0100
@@ -351,10 +351,48 @@
       __attribute__ ((format (printf, 1, 2)));
 #else
 void CLIB_DECL logerror(const char *text,...);
 #endif
 
+/* AdvanceMAME: Specific OSD interface */
+
+/* return the analog value of the specified input. */
+INT32 osd_get_analog_value(unsigned type, unsigned player, int* analog_type);
+
+/* called then the game is reset */
+void osd_reset(void);
+
+/* execute the specified menu (0,1,...) */
+int osd_menu(unsigned menu, struct mame_bitmap *bitmap, int sel);
+
+/* filter the main exit request */
+int osd_input_exit_filter(int result);
+
+/* filter the input port state */
+int osd_input_port_filter(int result, unsigned type, unsigned player, int seqtype);
+
+/* snapshot saving */
+void osd_save_snapshot(void);
+
+/* start and stop the video/sound recording. */
+void osd_record_start(void);
+void osd_record_stop(void);
+
+void osd_ui_menu(const char** items,const char** subitems, char* flag, int selected, int arrowize_subitem);
+void osd_ui_message(const char* text, int second);
+void osd_ui_osd(const char *text, int percentage, int default_percentage);
+void osd_ui_scroll(const char* text, int* pos);
+
+/* customize the inputport */
+void osd_config_load_default(struct InputPortDefinition* backup, struct InputPortDefinition* list);
+void osd_config_load(struct InputPort* backup, struct InputPort* list);
+void osd_config_save_default(struct InputPortDefinition* backup, struct InputPortDefinition* list);
+void osd_config_save(struct InputPort* backup, struct InputPort* list);
+
+/* handle the specific user interface */
+int osd_handle_user_interface(struct mame_bitmap *bitmap, int is_menu_active);
+
 #ifdef __cplusplus
 }
 #endif
 
 #endif
diff -U 5 --new-file --recursive src.ori/rules.mak src/rules.mak
--- src.ori/rules.mak	2005-01-03 15:32:56.000000000 +0100
+++ src/rules.mak	2005-01-04 16:23:42.000000000 +0100
@@ -1187,16 +1187,16 @@
 CPUOBJS += $(OBJ)/$(G6D)/g65816o1.o
 CPUOBJS += $(OBJ)/$(G6D)/g65816o2.o
 CPUOBJS += $(OBJ)/$(G6D)/g65816o3.o
 CPUOBJS += $(OBJ)/$(G6D)/g65816o4.o
 DBGOBJS += $(OBJ)/$(G6D)/g65816ds.o
-$(OBJ)/$(G6D)/g65816.o: $(G6D)/g65816.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
-$(OBJ)/$(G6D)/g65816o0.o: $(G6D)/g65816o0.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
-$(OBJ)/$(G6D)/g65816o1.o: $(G6D)/g65816o0.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
-$(OBJ)/$(G6D)/g65816o2.o: $(G6D)/g65816o0.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
-$(OBJ)/$(G6D)/g65816o3.o: $(G6D)/g65816o0.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
-$(OBJ)/$(G6D)/g65816o4.o: $(G6D)/g65816o0.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
+$(OBJ)/$(G6D)/g65816.o: g65816.c g65816.h g65816cm.h g65816op.h
+$(OBJ)/$(G6D)/g65816o0.o: g65816o0.c g65816.h g65816cm.h g65816op.h
+$(OBJ)/$(G6D)/g65816o1.o: g65816o0.c g65816.h g65816cm.h g65816op.h
+$(OBJ)/$(G6D)/g65816o2.o: g65816o0.c g65816.h g65816cm.h g65816op.h
+$(OBJ)/$(G6D)/g65816o3.o: g65816o0.c g65816.h g65816cm.h g65816op.h
+$(OBJ)/$(G6D)/g65816o4.o: g65816o0.c g65816.h g65816cm.h g65816op.h
 else
 CPUDEFS += -DHAS_G65816=0
 endif
 
 CPU=$(strip $(findstring SPC700@,$(CPUS)))
@@ -1204,11 +1204,11 @@
 SPCD = cpu/spc700
 OBJDIRS += $(OBJ)/$(SPCD)
 CPUDEFS += -DHAS_SPC700=1
 CPUOBJS += $(OBJ)/$(SPCD)/spc700.o
 DBGOBJS += $(OBJ)/$(SPCD)/spc700ds.o
-$(OBJ)/$(SPCD)/spc700/spc700.o: $(SPCD)/spc700.c $(SPCD)/spc700.h
+$(OBJ)/$(SPCD)/spc700.o: spc700.c spc700.h
 else
 CPUDEFS += -DHAS_SPC700=0
 endif
 
 CPU=$(strip $(findstring E116T@,$(CPUS)))
@@ -1495,13 +1495,13 @@
 
 SOUND=$(strip $(findstring DISCRETE@,$(SOUNDS)))
 ifneq ($(SOUND),)
 SOUNDDEFS += -DHAS_DISCRETE=1
 SOUNDOBJS += $(OBJ)/sound/discrete.o
-$(OBJ)/sound/discrete.o: src/sound/discrete.c src/sound/discrete.h \
-		src/sound/disc_dev.c src/sound/disc_flt.c src/sound/disc_inp.c \
-		src/sound/disc_mth.c src/sound/disc_wav.c
+$(OBJ)/sound/discrete.o: discrete.c discrete.h \
+		disc_dev.c disc_flt.c disc_inp.c \
+		disc_mth.c disc_wav.c
 else
 SOUNDDEFS += -DHAS_DISCRETE=0
 endif
 
 SOUND=$(strip $(findstring AY8910@,$(SOUNDS)))
diff -U 5 --new-file --recursive src.ori/ui_text.c src/ui_text.c
--- src.ori/ui_text.c	2004-08-22 21:14:00.000000000 +0200
+++ src/ui_text.c	2005-01-04 16:23:48.000000000 +0100
@@ -191,10 +191,14 @@
 	"One match found - added to list",
 
 	/* refresh rate */
 	"Refresh rate",
 
+	/* AdvanceMAME: Extra user interface commands */
+	"Video",
+	"Audio",
+
 	NULL
 };
 
 
 
diff -U 5 --new-file --recursive src.ori/ui_text.h src/ui_text.h
--- src.ori/ui_text.h	2004-07-28 22:26:24.000000000 +0200
+++ src/ui_text.h	2005-01-04 16:23:48.000000000 +0100
@@ -185,10 +185,14 @@
 	UI_search_one_match_found_added,
 	
 	/* refresh rate */
 	UI_refresh_rate,
 
+	/* AdvanceMAME: Extra user interface commands */
+	UI_osd_1,
+	UI_osd_2,
+
 	UI_last_mame_entry
 };
 
 #ifdef MESS
 #include "mui_text.h"
diff -U 5 --new-file --recursive src.ori/usrintrf.c src/usrintrf.c
--- src.ori/usrintrf.c	2005-01-03 15:05:50.000000000 +0100
+++ src/usrintrf.c	2005-01-04 16:26:43.000000000 +0100
@@ -809,10 +809,13 @@
 
 
 
 void ui_displaymenu(struct mame_bitmap *bitmap,const char **items,const char **subitems,char *flag,int selected,int arrowize_subitem)
 {
+#if 1 /* AdvanceMAME: Use custom ui code */
+	osd_ui_menu(items, subitems, flag, selected, arrowize_subitem);
+#else
 	struct DisplayText dt[256];
 	int curr_dt;
 	const char *lefthilight = ui_getstring (UI_lefthilight);
 	const char *righthilight = ui_getstring (UI_righthilight);
 	const char *uparrow = ui_getstring (UI_uparrow);
@@ -979,15 +982,19 @@
 		if (long_y + long_dy > uirotheight)
 			long_y = topoffs + i * 3*uirotcharheight/2 - long_dy;
 
 		ui_multitextbox_ex(bitmap,subitems[selected],subitems[selected] + strlen(subitems[selected]), long_max, long_x,long_y,long_dx,long_dy, UI_COLOR_NORMAL);
 	}
+#endif
 }
 
 
 void ui_displaymessagewindow(struct mame_bitmap *bitmap,const char *text)
 {
+#if 1 /* AdvanceMAME: Use custom ui code */
+	osd_ui_scroll(text, 0);
+#else
 	struct DisplayText dt[256];
 	int curr_dt;
 	char *c,*c2;
 	int i,len,maxlen,lines;
 	char textcopy[2048];
@@ -1082,10 +1089,11 @@
 	}
 
 	dt[curr_dt].text = 0;	/* terminate array */
 
 	displaytext(bitmap,dt);
+#endif
 }
 
 
 
 static void showcharset(struct mame_bitmap *bitmap)
@@ -1758,15 +1766,17 @@
 					menu_item[total] = in->name;
 					total++;
 				}
 				else
 				{
+#if 0 /* AdvanceMAME: The analog configuration is done at OSD level */
 					entry[total] = &in->defaultseq;
 					defentry[total] = &indef->defaultseq;
 					sprintf(menu_item_buffer[total], "%s Analog", in->name);
 					menu_item[total] = menu_item_buffer[total];
 					total++;
+#endif
 
 					analog[total] = 0;
 					entry[total] = &in->defaultdecseq;
 					defentry[total] = &indef->defaultdecseq;
 					sprintf(menu_item_buffer[total], "%s Dec", in->name);
@@ -1945,16 +1955,18 @@
 				menu_subitem[total] = menu_subitem_buffer[total];
 				total++;
 			}
 			else
 			{
+#if 0 /* AdvanceMAME: The analog configuration is done at OSD level */
 				seq[total] = &in->seq;
 				sprintf(menu_item_buffer[total], "%s Analog", input_port_name(in));
 				menu_item[total] = menu_item_buffer[total];
 				seq_name(input_port_seq(in, SEQ_TYPE_STANDARD), menu_subitem_buffer[total], sizeof(menu_subitem_buffer[0]));
 				menu_subitem[total] = menu_subitem_buffer[total];
 				total++;
+#endif
 
 				analog[total] = 0;
 				seq[total] = &in->analog.decseq;
 				sprintf(menu_item_buffer[total], "%s Dec", input_port_name(in));
 				menu_item[total] = menu_item_buffer[total];
@@ -2783,10 +2795,13 @@
 }
 
 /* Display lines from buffer, starting with line 'scroll', in a width x height text window */
 static void display_scroll_message (struct mame_bitmap *bitmap, int *scroll, int width, int height, char *buf)
 {
+#if 1 /* AdvanceMAME: Use custom ui code */
+	osd_ui_scroll(buf, scroll);
+#else
 	struct DisplayText dt[256];
 	int curr_dt = 0;
 	const char *uparrow = ui_getstring (UI_uparrow);
 	const char *downarrow = ui_getstring (UI_downarrow);
 	char textcopy[2048];
@@ -2889,10 +2904,11 @@
 	}
 
 	dt[curr_dt].text = 0;	/* terminate array */
 
 	displaytext(bitmap,dt);
+#endif
 }
 
 
 /* Display text entry for current driver from history.dat and mameinfo.dat. */
 static int displayhistory (struct mame_bitmap *bitmap, int selected)
@@ -2920,11 +2936,13 @@
 		{
 			/* try to load entry */
 			if (load_driver_history (Machine->gamedrv, buf, bufsize) == 0)
 			{
 				scroll = 0;
+#if 0 /* AdvanceMAME: The text is internally wrapped */
 				wordwrap_text_buffer (buf, maxcols);
+#endif
 				strcat(buf,"\n\t");
 				strcat(buf,ui_getstring (UI_lefthilight));
 				strcat(buf," ");
 				strcat(buf,ui_getstring (UI_returntomain));
 				strcat(buf," ");
@@ -3133,16 +3151,16 @@
 
 
 #ifndef MESS
 enum { UI_SWITCH = 0,UI_DEFGROUP,UI_CODE,UI_ANALOG,UI_CALIBRATE,
 		UI_STATS,UI_GAMEINFO, UI_HISTORY,
-		UI_CHEAT,UI_RESET,UI_MEMCARD,UI_EXIT };
+		UI_CHEAT,UI_RESET,UI_MEMCARD,UI_EXIT,UI_OSD_1,UI_OSD_2 };
 #else
 enum { UI_SWITCH = 0,UI_DEFGROUP,UI_CODE,UI_ANALOG,UI_CALIBRATE,
 		UI_GAMEINFO, UI_IMAGEINFO,UI_FILEMANAGER,UI_TAPECONTROL,
-		UI_HISTORY,UI_CHEAT,UI_RESET,UI_MEMCARD,UI_EXIT,
-		UI_CONFIGURATION, UI_CATEGORIES };
+		UI_HISTORY,UI_CHEAT,UI_RESET,UI_MEMCARD,UI_EXIT,UI_OSD_1,UI_OSD_2,
+		UI_CONFIGURATION, UI_CATEGORIES, };
 #endif
 
 
 #define MAX_SETUPMENU_ITEMS 20
 static const char *menu_item[MAX_SETUPMENU_ITEMS];
@@ -3272,10 +3290,13 @@
 		memcard_intf.eject != NULL)
 	{
 		append_menu(UI_memorycard, UI_MEMCARD);
 	}
 
+	/* AdvanceMAME: Extra menu UI_OSD */
+	append_menu(UI_osd_1, UI_OSD_1);
+	append_menu(UI_osd_2, UI_OSD_2);
 	append_menu(UI_resetgame, UI_RESET);
 	append_menu(UI_returntogame, UI_EXIT);
 	menu_item[menu_total] = 0; /* terminate array */
 }
 
@@ -3343,10 +3364,15 @@
 				res = cheat_menu(bitmap, sel >> SEL_BITS);
 				break;
 			case UI_MEMCARD:
 				res = memcard_menu(bitmap, sel >> SEL_BITS);
 				break;
+			/* AdvanceMAME: Extra menu UI_OSD */
+			case UI_OSD_1 :
+			case UI_OSD_2 :
+				res = osd_menu(menu_action[sel & SEL_MASK] - UI_OSD_1, bitmap, sel >> SEL_BITS);
+				break;
 		}
 
 		if (res == -1)
 		{
 			menu_lastselected = sel;
@@ -3388,10 +3414,13 @@
 			case UI_CATEGORIES:
 #endif /* !MESS */
 			case UI_HISTORY:
 			case UI_CHEAT:
 			case UI_MEMCARD:
+			/* AdvanceMAME: Extra menu UI_OSD */
+			case UI_OSD_1 :
+			case UI_OSD_2 :
 				sel |= 1 << SEL_BITS;
 				schedule_full_refresh();
 				break;
 
 			case UI_RESET:
@@ -3428,10 +3457,13 @@
 
 *********************************************************************/
 
 static void displayosd(struct mame_bitmap *bitmap,const char *text,int percentage,int default_percentage)
 {
+#if 1 /* AdvanceMAME: Use custom ui code */
+	osd_ui_osd(text, percentage, default_percentage);
+#else
 	struct DisplayText dt[2];
 	int avail;
 
 
 	avail = (uirotwidth / uirotcharwidth) * 19 / 20;
@@ -3453,10 +3485,11 @@
 	dt[0].color = UI_COLOR_NORMAL;
 	dt[0].x = (uirotwidth - uirotcharwidth * strlen(text)) / 2;
 	dt[0].y = (uirotheight - 2*uirotcharheight) + 2;
 	dt[1].text = 0; /* terminate array */
 	displaytext(bitmap,dt);
+#endif
 }
 
 static void onscrd_adjuster(struct mame_bitmap *bitmap,int increment,int arg)
 {
 	struct InputPort *in = &Machine->input_ports[arg];
@@ -3486,17 +3519,17 @@
 	if (increment)
 	{
 		attenuation = osd_get_mastervolume();
 		attenuation += increment;
 		if (attenuation > 0) attenuation = 0;
-		if (attenuation < -32) attenuation = -32;
+		if (attenuation < -40) attenuation = -40;
 		osd_set_mastervolume(attenuation);
 	}
 	attenuation = osd_get_mastervolume();
 
 	sprintf(buf,"%s %3ddB", ui_getstring (UI_volume), attenuation);
-	displayosd(bitmap,buf,100 * (attenuation + 32) / 32,100);
+	displayosd(bitmap,buf,100 * (attenuation + 40) / 40,100);
 }
 
 static void onscrd_mixervol(struct mame_bitmap *bitmap,int increment,int arg)
 {
 	static void *driver = 0;
@@ -3843,10 +3876,13 @@
 *********************************************************************/
 
 
 static void displaymessage(struct mame_bitmap *bitmap,const char *text)
 {
+#if 1 /* AdvanceMAME: Use custom ui code */
+	osd_ui_message(text, 0);
+#else
 	struct DisplayText dt[2];
 	int avail;
 
 
 	if (uirotwidth < uirotcharwidth * strlen(text))
@@ -3866,10 +3902,11 @@
 	dt[0].color = UI_COLOR_NORMAL;
 	dt[0].x = (uirotwidth - uirotcharwidth * strlen(text)) / 2;
 	dt[0].y = uirotheight - 5*uirotcharheight/2;
 	dt[1].text = 0; /* terminate array */
 	displaytext(bitmap,dt);
+#endif
 }
 
 
 static char messagetext[200];
 static int messagecounter;
@@ -3991,10 +4028,11 @@
 	return show_profiler;
 }
 
 void ui_display_fps(struct mame_bitmap *bitmap)
 {
+#if 0 /* AdvanceMAME: Use custom ui code */
 	const char *text, *end;
 	char textbuf[256];
 	int done = 0;
 	int x, y = 0;
 	/* remember which area we cover so that we can
@@ -4051,32 +4089,31 @@
 	{
 		showfpstemp--;
 		if (!showfps && showfpstemp == 0)
 			schedule_full_refresh();
 	}
+#endif
 }
 
 
 
 int handle_user_interface(struct mame_bitmap *bitmap)
 {
 #ifdef MESS
 	extern int mess_pause_for_ui;
 #endif
 
+	if (osd_handle_user_interface(bitmap, setup_selected != 0) != 0)
+		return 1;
+
 	/* if the user pressed F12, save the screen to a file */
 	if (input_ui_pressed(IPT_UI_SNAPSHOT))
 		save_screen_snapshot(bitmap);
 
 	/* This call is for the cheat, it must be called once a frame */
 	if (options.cheat) DoCheat(bitmap);
 
-	/* if the user pressed ESC, stop the emulation */
-	/* but don't quit if the setup menu is on screen */
-	if (setup_selected == 0 && input_ui_pressed(IPT_UI_CANCEL))
-		return 1;
-
 	if (setup_selected == 0 && input_ui_pressed(IPT_UI_CONFIGURE))
 	{
 		setup_selected = -1;
 		if (osd_selected != 0)
 		{
@@ -4150,11 +4187,11 @@
 			/* if the user pressed F4, show the character set */
 			if (input_ui_pressed(IPT_UI_SHOW_GFX))
 				showcharset(bitmap);
 
 			if (setup_selected == 0 && input_ui_pressed(IPT_UI_CANCEL))
-				return 1;
+				break;
 
 			if (setup_selected == 0 && input_ui_pressed(IPT_UI_CONFIGURE))
 			{
 				setup_selected = -1;
 				if (osd_selected != 0)
@@ -4233,16 +4270,18 @@
 	}
 
 	if (show_profiler) profiler_show(bitmap);
 
 
+#if 0 /* AdvanceMAME: The show_fps action is managed by the osd code */
 	/* show FPS display? */
 	if (input_ui_pressed(IPT_UI_SHOW_FPS))
 	{
 		/* toggle fps */
 		ui_show_fps_set(!ui_show_fps_get());
 	}
+#endif
 
 
 	/* if the user pressed F4, show the character set */
 	if (input_ui_pressed(IPT_UI_SHOW_GFX))
 	{
diff -U 5 --new-file --recursive src.ori/vidhrdw/voodoo.c src/vidhrdw/voodoo.c
--- src.ori/vidhrdw/voodoo.c	2004-10-24 22:52:04.000000000 +0200
+++ src/vidhrdw/voodoo.c	2005-01-04 16:23:48.000000000 +0100
@@ -16,11 +16,11 @@
  *
  *	Math trickery
  *
  *************************************/
 
-#ifndef _WIN32
+#if 1 /* AdvanceMAME: Use always the portable implementation */
 #define SETUP_FPU()
 #define RESTORE_FPU()
 #define TRUNC_TO_INT(f) (float) (floor(f))
 #else
 #include <float.h>
diff -U 5 --new-file --recursive src.ori/x86drc.c src/x86drc.c
--- src.ori/x86drc.c	2004-11-23 18:05:40.000000000 +0100
+++ src/x86drc.c	2005-01-04 16:23:48.000000000 +0100
@@ -677,10 +677,11 @@
 
 
 /*------------------------------------------------------------------
 	drc_x86_get_features()
 ------------------------------------------------------------------*/
+#if 0
 UINT32 drc_x86_get_features(void)
 {
 	UINT32 features = 0;
 #ifdef _MSC_VER
 	__asm 
@@ -706,10 +707,11 @@
 	: "%ebx", "%ecx", "%edx"	/* clobbers ebx, ecx and edx */
 	);
 #endif /* MSC_VER */
 	return features;
 }
+#endif
 
 
 
 /*------------------------------------------------------------------
 	log_dispatch
