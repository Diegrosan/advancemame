diff -U 5 --new-file --recursive src.ori/advance.pat src/advance.pat
--- src.ori/advance.pat	1970-01-01 01:00:00.000000000 +0100
+++ src/advance.pat	2005-02-13 13:37:02.000000000 +0100
@@ -0,0 +1 @@
+These files are patched for the use with the Advance emulator.
diff -U 5 --new-file --recursive src.ori/common.c src/common.c
--- src.ori/common.c	2005-02-04 21:36:30.000000000 +0100
+++ src/common.c	2005-02-13 13:37:02.000000000 +0100
@@ -779,10 +779,11 @@
 	the given filename
 -------------------------------------------------*/
 
 void save_screen_snapshot_as(mame_file *fp, struct mame_bitmap *bitmap)
 {
+#if 0 /* AdvanceMAME has its snapshot code */
 	struct rectangle bounds;
 	struct mame_bitmap *osdcopy;
 	UINT32 saved_rgb_components[3];
 
 	/* allow the artwork system to override certain parameters */
@@ -877,20 +878,24 @@
 	memcpy(direct_rgb_components, saved_rgb_components, sizeof(saved_rgb_components));
 
 	/* if the OSD system allocated a bitmap; free it */
 	if (osdcopy)
 		bitmap_free(osdcopy);
+#endif
 }
 
 
 
 /*-------------------------------------------------
 	save_screen_snapshot - save a screen snapshot
 -------------------------------------------------*/
 
 void save_screen_snapshot(struct mame_bitmap *bitmap)
 {
+#if 1 /* AdvanceMAME has its snapshot code */
+	osd_save_snapshot();
+#else
 	char name[20];
 	mame_file *fp;
 
 	/* avoid overwriting existing files */
 	/* first of all try with "gamename.png" */
@@ -907,10 +912,11 @@
 	if ((fp = mame_fopen(Machine->gamedrv->name, name, FILETYPE_SCREENSHOT, 1)) != NULL)
 	{
 		save_screen_snapshot_as(fp, bitmap);
 		mame_fclose(fp);
 	}
+#endif
 }
 
 
 
 /***************************************************************************
@@ -1265,11 +1271,11 @@
 		}
 		else
 			strcat(romdata->errorbuf, "WARNING: the game might not run correctly.\n");
 
 		/* display the result */
-		printf("%s", romdata->errorbuf);
+		osd_display_loading_rom_message(romdata->errorbuf, 0);
 
 		/* if we're not getting out of here, wait for a keypress */
 		if (!options.gui_host && !options.skip_warnings && !bailing)
 		{
 			int k;
diff -U 5 --new-file --recursive src.ori/cpu/i8085/i8085.c src/cpu/i8085/i8085.c
--- src.ori/cpu/i8085/i8085.c	2005-02-04 21:36:30.000000000 +0100
+++ src/cpu/i8085/i8085.c	2005-02-13 13:37:02.000000000 +0100
@@ -110,10 +110,16 @@
  *
  *****************************************************************************/
 
 /*int survival_prot = 0; */
 
+#if defined(__GNUC__) && __GNUC__ >= 3
+/* Disable all the asm macro and the big switch */
+#undef X86_ASM
+#define BIG_SWITCH 0
+#endif
+
 #define VERBOSE 0
 
 #include "driver.h"
 #include "state.h"
 #include "osd_cpu.h"
diff -U 5 --new-file --recursive src.ori/cpuexec.c src/cpuexec.c
--- src.ori/cpuexec.c	2004-12-17 22:04:14.000000000 +0100
+++ src/cpuexec.c	2005-02-13 13:37:33.000000000 +0100
@@ -323,10 +323,13 @@
 	watchdog_setup();
 
 	/* reset sound chips */
 	sound_reset();
 
+	/* reset the osd level */
+	osd_reset();
+
 	/* first pass over CPUs */
 	for (cpunum = 0; cpunum < cpu_gettotalcpu(); cpunum++)
 	{
 		/* enable all CPUs (except for audio CPUs if the sound is off) */
 		if (!(Machine->drv->cpu[cpunum].cpu_flags & CPU_AUDIO_CPU) || Machine->sample_rate != 0)
diff -U 5 --new-file --recursive src.ori/drivers/laserbas.c~ src/drivers/laserbas.c~
--- src.ori/drivers/laserbas.c~	2005-02-12 23:44:18.000000000 +0100
+++ src/drivers/laserbas.c~	1970-01-01 01:00:00.000000000 +0100
@@ -1,240 +0,0 @@
-/********************************************
- Laser Base / Future Flash driver
-
- IC marked as Z1 is probably protection device
- mapped in memory region f800-fbff
- (simil. to the one used in Parallel Turn)
-
- Reads form this device depends on previous
- writes (adr, data), address and previous
- operation (read or write).
- Pinout is almost identical to 2716 - type EPROM,
- except separated /RD and /WR	signals and lacks
- of /CS
-
- Tomasz Slanina analog [at] op.pl
-
-********************************************/
-
-#include "driver.h"
-#include "vidhrdw/generic.h"
-
-static data8_t *vram1,*vram2;
-static int vrambank=0;
-
-VIDEO_START(laserbas)
-{
-	vram1=auto_malloc(0x8000);
-	vram2=auto_malloc(0x8000);
-	if ((tmpbitmap = auto_bitmap_alloc(Machine->drv->screen_width,Machine->drv->screen_height)) == 0)
-		return 1;
-	return 0;
-}
-
-VIDEO_UPDATE(laserbas)
-{
-	int x,y;
- 	for(y=0;y<256;y++)
-		for(x=0;x<128;x++)
-		{
-			plot_pixel(tmpbitmap, x*2, y,  Machine->pens[vram1[y*128+x]&0xf]+16);
-			plot_pixel(tmpbitmap, x*2+1, y, Machine->pens[vram1[y*128+x]>>4]+16);
-		}
-	copybitmap(bitmap,tmpbitmap,0,0,0,0,&Machine->visible_area,TRANSPARENCY_NONE,0);
-	for(y=0;y<256;y++)
-		for(x=0;x<128;x++)
-		{
-			plot_pixel(tmpbitmap, x*2, y,  Machine->pens[vram2[y*128+x]&0xf]);
-			plot_pixel(tmpbitmap, x*2+1, y, Machine->pens[vram2[y*128+x]>>4]);
-		}
-	copybitmap(bitmap,tmpbitmap,0,0,0,0,&Machine->visible_area,TRANSPARENCY_PEN,0);
-}
-
-static READ8_HANDLER(vram_r)
-{
-	if(!vrambank)
-		return vram1[offset];
-	else
-		return vram2[offset];
-}
-
-static WRITE8_HANDLER(vram_w)
-{
-	if(!vrambank)
-		vram1[offset]=data;
-	else
-		vram2[offset]=data;
-}
-
-static READ8_HANDLER( read_unk )
-{
-	static int count=0;
-	count ^= 0x80;
-	return count|0x7f;
-}
-
-static WRITE8_HANDLER(palette_w)
-{
-	palette_set_color(offset,(data&0xe0),(data<<3)&0xe0,(data<<6)&0xe0);
-}
-
-static WRITE8_HANDLER(vrambank_w)
-{
-	if((offset&0xf1)==0x10)
-		vrambank=data&0x40;
-}
-
-static ADDRESS_MAP_START( laserbas_memory, ADDRESS_SPACE_PROGRAM, 8 )
-	AM_RANGE(0x0000, 0x3fff) AM_ROM
-	AM_RANGE(0x4000, 0xbfff) AM_READ(vram_r) AM_WRITE(vram_w)
-	AM_RANGE(0xc000, 0xf7ff) AM_ROM
-	AM_RANGE(0xf800, 0xfbff) AM_RAM /* protection device */
-	AM_RANGE(0xfc00, 0xffff) AM_RAM
-ADDRESS_MAP_END
-
-static ADDRESS_MAP_START( laserbas_io, ADDRESS_SPACE_IO, 8 )
-	AM_RANGE(0x00, 0x1f) AM_WRITE(vrambank_w)
-	AM_RANGE(0x20, 0x20) AM_READ(read_unk) AM_WRITENOP//write = ram/rom bank ? at fc00-f800 ?
-	AM_RANGE(0x21, 0x21) AM_READ(input_port_0_r)
-	AM_RANGE(0x80, 0x9f) AM_WRITE(palette_w)
-ADDRESS_MAP_END
-
-INPUT_PORTS_START( laserbas )
-	PORT_START
-		PORT_DIPNAME( 0x01, 0x00, "0-0" )
-		PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
-		PORT_DIPSETTING(    0x01, DEF_STR( On ) )
-		PORT_DIPNAME( 0x02, 0x00, "0-1" )
-		PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
-		PORT_DIPSETTING(    0x02, DEF_STR( On ) )
-		PORT_DIPNAME( 0x04, 0x00, "0-2" )
-		PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
-		PORT_DIPSETTING(    0x04, DEF_STR( On ) )
-		PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_START1 )
-		PORT_DIPNAME( 0x010, 0x10, "0-3" )
-		PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
-		PORT_DIPSETTING(    0x010, DEF_STR( On ) )
-		PORT_DIPNAME( 0x020, 0x20, "Test Mode" )
-		PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
-		PORT_DIPSETTING(    0x000, DEF_STR( On ) )
-		PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_COIN1 )
-		PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_COIN2 )
-INPUT_PORTS_END
-
-INTERRUPT_GEN( laserbas_interrupt )
-{
-	if(cpu_getvblank())
-		 cpunum_set_input_line(0, 0, HOLD_LINE);
-	else
-		cpunum_set_input_line(0, INPUT_LINE_NMI, PULSE_LINE);
-}
-
-static MACHINE_DRIVER_START( laserbas )
-	MDRV_CPU_ADD(Z80, 4000000)
-	MDRV_CPU_PROGRAM_MAP(laserbas_memory,0)
-	MDRV_CPU_IO_MAP(laserbas_io,0)
-	MDRV_CPU_VBLANK_INT(laserbas_interrupt,2)
-
-	MDRV_FRAMES_PER_SECOND(60)
-	MDRV_VBLANK_DURATION(DEFAULT_60HZ_VBLANK_DURATION)
-
-	MDRV_VIDEO_ATTRIBUTES(VIDEO_TYPE_RASTER)
-	MDRV_SCREEN_SIZE(32*8, 32*8)
-	MDRV_VISIBLE_AREA(0*8, 32*8-1, 0*8, 32*8-1)
-	MDRV_PALETTE_LENGTH(32)
-	MDRV_VIDEO_START(laserbas)
-	MDRV_VIDEO_UPDATE(laserbas)
-
-MACHINE_DRIVER_END
-
-/*
-Amstar LaserBase 1981 (Hoei)
-
-XBC-101-00-1 - CPU board
-  Z80A (D780C-1)
-  2 NB5K8253
-  2 2114 Rams
-  8 Dipswitches
-
-XBC-102-01-1 - RAM board?
-  HD46505R
-  32 MB8118 Rams
-
-------------------------------------
-
-Filename  Label Type   CSum Description
---------- ----- ------ ---- -----------------------------
-MB8532.1    1   2532   9316
-MB8532.2    2   2532   5662
-MB8532.3    3   2532   7E9F
-MB8532.4    4   2532   7CAD
-MB8532.5    5   2532   C7D4 (Marked F.F.)
-MB8532.6    6   2532   16BE
-MB8532.7    7   2532   CF6C (Marked F.F.)
-MB8716.8    8   2716   9601 (Marked F.F.)
-TI2716.Z1  Z1   TI2716 D925
---------- ----- ------ ---- -----------------------------
-
-I believe the F.F. markings on these chips show that
-these roms have been changed to Future Flash.
-
-It is unknown what the Z1 chip is, but the label screened
-on the board under the socket says 2716.  All the identifying
-numbers have been scratched off and has Z1 stamped on it.
-It appears that each one was then numbered by hand in red
-marker and stamped with white ink with Z1.
-
-The Z1 chip was read from 3 different boards, it is Valid.
-The chips were numbered 69, 82 & 624, all three read the same.
-Turns out it was a TI2716.  The TI chip has A10 on a different
-pin than a standard 2716.
-
-*/
-
-ROM_START( laserbas )
-	ROM_REGION( 0x10000, REGION_CPU1, 0 )	/* 64k for code */
-	ROM_LOAD( "mb8532.1",   0x0000, 0x1000, CRC(ef85e0c5)  )
-	ROM_LOAD( "mb8532.2",   0x1000, 0x1000, CRC(0ba2236c)  )
-	ROM_LOAD( "mb8532.3",   0x2000, 0x1000, CRC(83998e0b)  )
-	ROM_LOAD( "mb8532.4",   0x3000, 0x1000, CRC(00f9d909)  )
-	ROM_LOAD( "lb2532.5",   0xc000, 0x1000, CRC(6459073e)  )
-	ROM_LOAD( "lb2532.6",   0xd000, 0x1000, CRC(a2dc1e7e)  )
-	ROM_LOAD( "mb8532.7",   0xe000, 0x1000, CRC(9d2148d7)  )
-	ROM_LOAD( "mb8516.8",   0xf000, 0x0800, CRC(623f558f)  )
-ROM_END
-
-ROM_START( laserbsa )
-	ROM_REGION( 0x10000, REGION_CPU1, 0 )	/* 64k for code */
-	ROM_LOAD( "2732.u1",       0x0000, 0x1000, CRC(f3ab00dc)  )
-	ROM_LOAD( "2732.u2",       0x1000, 0x1000, CRC(0ba2236c)  )
-	ROM_LOAD( "mb8532.u3",     0x2000, 0x1000, CRC(c58a7745)  )
-	ROM_LOAD( "mbm2732.u4",    0x3000, 0x1000, CRC(00f9d909)  )
-	ROM_LOAD( "2732.u5",       0xc000, 0x1000, CRC(6459073e)  )
-	ROM_LOAD( "2732.u6",       0xd000, 0x1000, CRC(a2dc1e7e)  )
-	ROM_LOAD( "2732.u7",       0xe000, 0x1000, CRC(9d2148d7)  )
-	ROM_LOAD( "mb8516.u8",     0xf000, 0x0800, CRC(623f558f)  )
-ROM_END
-
-/*
-It was unclear what type of device FF.9 was. The silkscreen on the PCB said
-2716,
-but the device is a masked ROM with its identifying marks rubbed off.
-I dumped it
-as a 2716 (FF.9), a 2532 like the others (FF.9A) and a 2732 (FF.9B).
-*/
-
-ROM_START( futflash )
-	ROM_REGION( 0x10000, REGION_CPU1, 0 )	/* 64k for code */
-	ROM_LOAD( "ff.1",    	  	0x0000, 0x1000, CRC(bcd6b998)  )
-	ROM_LOAD( "ff.2",         0x1000, 0x1000, CRC(1b1f6953)  )
-	ROM_LOAD( "ff.3",         0x2000, 0x1000, CRC(30008f04)  )
-	ROM_LOAD( "ff.4",         0x3000, 0x1000, CRC(e559aa12)  )
-	ROM_LOAD( "ff.5",         0xc000, 0x1000, CRC(6459073e)  )
-	ROM_LOAD( "ff.6",         0xd000, 0x1000, CRC(a8b17f49)  )
-	ROM_LOAD( "ff.7",         0xe000, 0x1000, CRC(9d2148d7)  )
-	ROM_LOAD( "ff.8",         0xf000, 0x0800, CRC(623f558f)  )
-ROM_END
-
-GAMEX( 1981, laserbas, 0, laserbas, laserbas, 0, ROT270,  "Amstar/HOEI",	  "Laser Base (set 1)", GAME_NO_SOUND | GAME_NOT_WORKING)
-GAMEX( 1981, laserbsa, laserbas, laserbas, laserbas, 0, ROT270,  "Amstar/HOEI", "Laser Base (set 2)",		  GAME_NO_SOUND| GAME_NOT_WORKING )
-GAMEX( 19??, futflash, laserbas, laserbas, laserbas, 0, ROT270,  "HOEI",	  "Futur Flash", GAME_NO_SOUND | GAME_NOT_WORKING)
diff -U 5 --new-file --recursive src.ori/drivers/macs.c src/drivers/macs.c
--- src.ori/drivers/macs.c	2005-02-16 23:14:56.000000000 +0100
+++ src/drivers/macs.c	2005-02-16 23:14:33.000000000 +0100
@@ -49,10 +49,14 @@
 */
 
 #include "driver.h"
 #include "cpu/z80/z80.h"
 
+/* AdvanceMAME: Prevent name pollution */
+#define random_r mame_random_r
+#define rand_r mame_rand_r
+
 WRITE8_HANDLER (st0016_sprite_bank_w);
 WRITE8_HANDLER (st0016_palette_bank_w);
 WRITE8_HANDLER (st0016_character_bank_w);
 READ8_HANDLER  (st0016_sprite_ram_r);
 WRITE8_HANDLER (st0016_sprite_ram_w);
diff -U 5 --new-file --recursive src.ori/drivers/micro3d.c src/drivers/micro3d.c
--- src.ori/drivers/micro3d.c	2005-02-11 19:22:08.000000000 +0100
+++ src/drivers/micro3d.c	2005-02-13 16:06:58.000000000 +0100
@@ -442,13 +442,13 @@
        }
 }
 
 static WRITE16_HANDLER( m68901_w )
 {
-
+UINT8 value;
 m68901_base[offset]=data;
-UINT8 value = (data>>8)& 0xff;
+value = (data>>8)& 0xff;
 
 switch(offset)
 {
 
         case 0x0c:    printf("Timer A Control: %x\n",value);
diff -U 5 --new-file --recursive src.ori/drivers/multi32.c src/drivers/multi32.c
--- src.ori/drivers/multi32.c	2005-02-04 21:36:32.000000000 +0100
+++ src/drivers/multi32.c	2005-02-13 13:37:33.000000000 +0100
@@ -827,11 +827,11 @@
 	MDRV_NVRAM_HANDLER(system32)
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES(VIDEO_TYPE_RASTER | VIDEO_NEEDS_6BITS_PER_GUN | VIDEO_UPDATE_AFTER_VBLANK | VIDEO_RGB_DIRECT | VIDEO_HAS_SHADOWS ) // RGB_DIRECT will be needed for alpha
 	MDRV_SCREEN_SIZE(52*8*2, 28*8*2)
-	MDRV_VISIBLE_AREA(0*8, 52*8*2-1, 0*8, 28*8*2-1)
+	MDRV_VISIBLE_AREA(0, 320-1, 0, 224-1)
 
 	MDRV_GFXDECODE(gfxdecodeinfo)
 	MDRV_PALETTE_LENGTH(32768)
 
 	MDRV_VIDEO_START(system32)
diff -U 5 --new-file --recursive src.ori/drivers/namcos11.c src/drivers/namcos11.c
--- src.ori/drivers/namcos11.c	2005-02-04 21:40:00.000000000 +0100
+++ src/drivers/namcos11.c	2005-02-13 13:37:33.000000000 +0100
@@ -825,11 +825,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 8, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type1 )
 	MDRV_VIDEO_UPDATE( psx )
diff -U 5 --new-file --recursive src.ori/drivers/namcos12.c src/drivers/namcos12.c
--- src.ori/drivers/namcos12.c	2005-02-04 21:40:00.000000000 +0100
+++ src/drivers/namcos12.c	2005-02-13 13:37:33.000000000 +0100
@@ -469,11 +469,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 480-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
diff -U 5 --new-file --recursive src.ori/drivers/psikyo4.c src/drivers/psikyo4.c
--- src.ori/drivers/psikyo4.c	2005-02-16 23:14:57.000000000 +0100
+++ src/drivers/psikyo4.c	2005-02-16 23:14:34.000000000 +0100
@@ -412,13 +412,13 @@
 	MDRV_NVRAM_HANDLER(93C56)
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES(VIDEO_TYPE_RASTER | VIDEO_NEEDS_6BITS_PER_GUN | VIDEO_DUAL_MONITOR)
 #if DUAL_SCREEN
-	MDRV_ASPECT_RATIO(8,3)
+	MDRV_ASPECT_RATIO(4,3)
 	MDRV_SCREEN_SIZE(80*8, 32*8)
-	MDRV_VISIBLE_AREA(0, 80*8-1, 0, 28*8-1)
+	MDRV_VISIBLE_AREA(0, 320-1, 0, 28*8-1)
 #else
 	MDRV_ASPECT_RATIO(4,3)
 	MDRV_SCREEN_SIZE(64*8, 32*8)
 	MDRV_VISIBLE_AREA(0, 40*8-1, 0, 28*8-1)
 #endif
@@ -437,11 +437,11 @@
 static MACHINE_DRIVER_START( ps4small )
 	/* basic machine hardware */
 	MDRV_IMPORT_FROM(ps4big)
 
 #if DUAL_SCREEN
-	MDRV_VISIBLE_AREA(0, 80*8-1, 0, 30*8-1)
+	MDRV_VISIBLE_AREA(0, 320-1, 0, 30*8-1)
 #else
 	MDRV_VISIBLE_AREA(0, 40*8-1, 0, 30*8-1)
 #endif
 MACHINE_DRIVER_END
 
diff -U 5 --new-file --recursive src.ori/drivers/shanghai.c src/drivers/shanghai.c
--- src.ori/drivers/shanghai.c	2005-02-16 23:14:57.000000000 +0100
+++ src/drivers/shanghai.c	2005-02-16 23:14:34.000000000 +0100
@@ -20,10 +20,14 @@
 ***************************************************************************/
 
 #include "driver.h"
 #include "sndhrdw/seibu.h"
 
+/* AdvanceMAME: Prevent name pollution */
+#define random_r mame_random_r
+#define rand_r mame_rand_r
+
 /* the on-chip FIFO is 16 bytes long, but we use a larger one to simplify */
 /* decoding of long commands. Commands can be up to 64KB long... but Shanghai */
 /* doesn't reach that length. */
 #define FIFO_LENGTH 50
 #define HD63484_RAM_SIZE 0x200000
diff -U 5 --new-file --recursive src.ori/drivers/stv.c src/drivers/stv.c
--- src.ori/drivers/stv.c	2005-02-16 23:14:57.000000000 +0100
+++ src/drivers/stv.c	2005-02-16 23:14:34.000000000 +0100
@@ -4206,11 +4206,11 @@
 	MDRV_NVRAM_HANDLER(stv) /* Actually 93c45 */
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES(VIDEO_TYPE_RASTER | VIDEO_UPDATE_AFTER_VBLANK | VIDEO_RGB_DIRECT )
 	MDRV_SCREEN_SIZE(1024, 1024)
-	MDRV_VISIBLE_AREA(0*8, 703, 0*8, 512) // we need to use a resolution as high as the max size it can change to
+	MDRV_VISIBLE_AREA(0*8, 320-1, 0*8, 224-1)
 	MDRV_PALETTE_LENGTH(2048+(2048*2))//standard palette + extra memory for rgb brightness.
 	MDRV_GFXDECODE(gfxdecodeinfo)
 
 	MDRV_VIDEO_START(stv_vdp2)
 	MDRV_VIDEO_UPDATE(stv_vdp2)
diff -U 5 --new-file --recursive src.ori/drivers/zn.c src/drivers/zn.c
--- src.ori/drivers/zn.c	2004-12-17 22:04:08.000000000 +0100
+++ src/drivers/zn.c	2005-02-13 13:37:33.000000000 +0100
@@ -620,11 +620,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 512 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -655,11 +655,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -856,11 +856,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -1281,11 +1281,11 @@
 	MDRV_NVRAM_HANDLER( coh1000ta )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 512 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -1374,11 +1374,11 @@
 	MDRV_NVRAM_HANDLER( coh1000tb )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -1560,11 +1560,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -1770,11 +1770,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -2014,11 +2014,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 320-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -2347,11 +2347,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -2594,11 +2594,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 320-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -2861,11 +2861,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 480-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -2894,11 +2894,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 320-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -2926,11 +2926,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 320-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
diff -U 5 --new-file --recursive src.ori/inptport.c src/inptport.c
--- src.ori/inptport.c	2005-02-16 23:14:57.000000000 +0100
+++ src/inptport.c	2005-02-16 23:14:34.000000000 +0100
@@ -927,26 +927,21 @@
 
 	/* start with the raw defaults and ask the OSD to customize them in the backup array */
 	memcpy(inputport_list_backup, inputport_list_defaults, sizeof(inputport_list_backup));
 	osd_customize_inputport_list(inputport_list_backup);
 
-	/* load the controller-specific info -- note that even though we are still modifying */
-	/* the inputport_list_backup, token_to_port_type relies on inputport_list being valid */
-	memcpy(inputport_list, inputport_list_backup, sizeof(inputport_list));
-	if (options.controller != NULL)
-	{
-		loaded = config_load_controller(options.controller, inputport_list_backup);
-		if (!loaded)
-			osd_die("Could not load controller file %s.cfg\n", options.controller);
-	}
-
 	/* propogate that forward to the live list and apply the config on top of that */
 	memcpy(inputport_list, inputport_list_backup, sizeof(inputport_list));
-	config_load_default(inputport_list_backup, inputport_list);
 
-	/* now load the game-specific info */
-	loaded = config_load(Machine->input_ports_default, Machine->input_ports);
+	/* AdvanceMAME: Load user defined customization */
+	osd_config_load_default(inputport_list_backup, inputport_list);
+
+	/* AdvanceMAME: Load user defined customization */
+	osd_config_load(Machine->input_ports_default, Machine->input_ports);
+
+	/* AdvanceMAME: Report no setting loaded, always show the disclaimer */
+	loaded = 0;
 
 	/* initialize the various port states */
 	inputport_init();
 
 	/* if we didn't find a saved config, return 0 so the main core knows that it */
@@ -956,12 +951,16 @@
 
 
 void save_input_port_settings(void)
 {
 	/* save the default config and the game-specific config */
-	config_save_default(inputport_list_backup, inputport_list);
-	config_save(Machine->input_ports_default, Machine->input_ports);
+
+	/* AdvanceMAME: Save user defined customization */
+	osd_config_save_default(inputport_list_backup, inputport_list);
+
+	/* AdvanceMAME: Save user defined customization */
+	osd_config_save(Machine->input_ports_default, Machine->input_ports);
 }
 
 
 
 /*************************************
@@ -1487,12 +1486,18 @@
 {
 	int listnum;
 
 	/* search the defaults for the type */
 	for (listnum = 0; inputport_list[listnum].type != IPT_END; listnum++)
-		if (inputport_list[listnum].type == type && inputport_list[listnum].player == player)
-			return seq_pressed(&inputport_list[listnum].defaultseq);
+		if (inputport_list[listnum].type == type && inputport_list[listnum].player == player) {
+			int pressed = seq_pressed(&inputport_list[listnum].defaultseq);
+
+			/* AdvanceMAME: Filter all the input ports */
+			pressed = osd_input_port_filter(pressed, inputport_list[listnum].type, inputport_list[listnum].player, SEQ_TYPE_STANDARD);
+
+			return pressed;
+		}
 
 	return 0;
 }
 
 
@@ -1503,10 +1508,13 @@
 profiler_mark(PROFILER_INPUT);
 
 	/* get the status of this key (assumed to be only in the defaults) */
 	pressed = seq_pressed(input_port_default_seq(code, 0, SEQ_TYPE_STANDARD));
 
+	/* AdvanceMAME: Filter all the input ports */
+	pressed = osd_input_port_filter(pressed, code, 0, SEQ_TYPE_STANDARD);
+
 	/* if pressed, handle it specially */
 	if (pressed)
 	{
 		/* if this is the first press, leave pressed = 1 */
 		if (ui_memory[code] == 0)
@@ -1536,10 +1544,13 @@
 profiler_mark(PROFILER_INPUT);
 
 	/* get the status of this key (assumed to be only in the defaults) */
 	pressed = seq_pressed(input_port_default_seq(code, 0, SEQ_TYPE_STANDARD));
 
+	/* AdvanceMAME: Filter all the input ports */
+	pressed = osd_input_port_filter(pressed, code, 0, SEQ_TYPE_STANDARD);
+
 	/* if so, handle it specially */
 	if (pressed)
 	{
 		/* if this is the first press, set a 3x delay and leave pressed = 1 */
 		if (ui_memory[code] == 0)
@@ -1608,10 +1619,13 @@
 void inputport_vblank_start(void)
 {
 	int ui_visible = setup_active() || onscrd_active();
 	int portnum, bitnum;
 
+	/* AdvanceMAME: Never disable the input port. */
+	ui_visible = 0;
+
 profiler_mark(PROFILER_INPUT);
 
 	/* update the digital joysticks first */
 	update_digital_joysticks();
 
@@ -1642,11 +1656,16 @@
 
 			/* handle non-analog types, but only when the UI isn't visible */
 			else if (!IS_ANALOG(port) && !ui_visible)
 			{
 				/* if the sequence for this port is currently pressed.... */
-				if (seq_pressed(input_port_seq(port, SEQ_TYPE_STANDARD)))
+				int pressed = seq_pressed(input_port_seq(port, SEQ_TYPE_STANDARD));
+
+				/* AdvanceMAME: Filter all the input ports */
+				pressed = osd_input_port_filter(pressed, port->type, port->player, SEQ_TYPE_STANDARD);
+
+				if (pressed)
 				{
 #ifdef MESS
 					/* (MESS-specific) check for disabled keyboard */
 					if (port->type == IPT_KEYBOARD && osd_keyboard_disabled())
 						continue;
@@ -1774,17 +1793,18 @@
 			{
 				info->previous = info->current;
 				info->current = 0;
 
 				/* read all the associated ports */
-				if (info->port[JOYDIR_UP] != NULL && seq_pressed(input_port_seq(info->port[JOYDIR_UP], SEQ_TYPE_STANDARD)))
+				/* AdvanceMAME: Filter all the input ports */
+				if (info->port[JOYDIR_UP] != NULL && osd_input_port_filter(seq_pressed(input_port_seq(info->port[JOYDIR_UP], SEQ_TYPE_STANDARD)), info->port[JOYDIR_UP]->type, info->port[JOYDIR_UP]->player, SEQ_TYPE_STANDARD))
 					info->current |= JOYDIR_UP_BIT;
-				if (info->port[JOYDIR_DOWN] != NULL && seq_pressed(input_port_seq(info->port[JOYDIR_DOWN], SEQ_TYPE_STANDARD)))
+				if (info->port[JOYDIR_DOWN] != NULL && osd_input_port_filter(seq_pressed(input_port_seq(info->port[JOYDIR_DOWN], SEQ_TYPE_STANDARD)), info->port[JOYDIR_DOWN]->type, info->port[JOYDIR_DOWN]->player, SEQ_TYPE_STANDARD))
 					info->current |= JOYDIR_DOWN_BIT;
-				if (info->port[JOYDIR_LEFT] != NULL && seq_pressed(input_port_seq(info->port[JOYDIR_LEFT], SEQ_TYPE_STANDARD)))
+				if (info->port[JOYDIR_LEFT] != NULL && osd_input_port_filter(seq_pressed(input_port_seq(info->port[JOYDIR_LEFT], SEQ_TYPE_STANDARD)), info->port[JOYDIR_LEFT]->type, info->port[JOYDIR_LEFT]->player, SEQ_TYPE_STANDARD))
 					info->current |= JOYDIR_LEFT_BIT;
-				if (info->port[JOYDIR_RIGHT] != NULL && seq_pressed(input_port_seq(info->port[JOYDIR_RIGHT], SEQ_TYPE_STANDARD)))
+				if (info->port[JOYDIR_RIGHT] != NULL && osd_input_port_filter(seq_pressed(input_port_seq(info->port[JOYDIR_RIGHT], SEQ_TYPE_STANDARD)), info->port[JOYDIR_RIGHT]->type, info->port[JOYDIR_RIGHT]->player, SEQ_TYPE_STANDARD))
 					info->current |= JOYDIR_RIGHT_BIT;
 
 				/* lock out opposing directions (left + right or up + down) */
 				if ((info->current & (JOYDIR_UP_BIT | JOYDIR_DOWN_BIT)) == (JOYDIR_UP_BIT | JOYDIR_DOWN_BIT))
 					info->current &= ~(JOYDIR_UP_BIT | JOYDIR_DOWN_BIT);
@@ -1895,12 +1915,12 @@
 		int analog_type, keypressed = 0;
 
 		/* clamp the previous value to the min/max range and remember it */
 		info->previous = info->accum = apply_analog_min_max(info, info->accum);
 
-		/* get the new raw analog value and its type */
-		rawvalue = seq_analog_value(input_port_seq(port, SEQ_TYPE_STANDARD), &analog_type);
+		/* AdvanceMAME: Get the analog input for different players from the osd core. */
+		rawvalue = osd_get_analog_value(port->type, port->player, &analog_type);
 
 		/* if we got it from a relative device, use that as the starting delta */
 		/* also note that the last input was not a digital one */
 		if (analog_type == ANALOG_TYPE_RELATIVE && rawvalue != 0)
 		{
@@ -1908,18 +1928,20 @@
 			info->lastdigital = 0;
 		}
 
 		/* if the decrement code sequence is pressed, add the key delta to */
 		/* the accumulated delta; also note that the last input was a digital one */
-		if (seq_pressed(input_port_seq(info->port, SEQ_TYPE_DECREMENT)))
+		/* AdvanceMAME: Filter all the input ports */
+		if (osd_input_port_filter(seq_pressed(input_port_seq(info->port, SEQ_TYPE_DECREMENT)), info->port->type, info->port->player, SEQ_TYPE_DECREMENT))
 		{
 			delta -= (INT32)(port->analog.delta * info->keyscale);
 			keypressed = info->lastdigital = 1;
 		}
 
 		/* same for the increment code sequence */
-		if (seq_pressed(input_port_seq(info->port, SEQ_TYPE_INCREMENT)))
+		/* AdvanceMAME: Filter all the input ports */
+		if (osd_input_port_filter(seq_pressed(input_port_seq(info->port, SEQ_TYPE_INCREMENT)), info->port->type, info->port->player, SEQ_TYPE_INCREMENT))
 		{
 			delta += (INT32)(port->analog.delta * info->keyscale);
 			keypressed = info->lastdigital = 1;
 		}
 
@@ -1933,15 +1955,18 @@
 		info->accum += delta;
 
 		/* if we got an absolute input, it overrides everything else */
 		if (analog_type == ANALOG_TYPE_ABSOLUTE)
 		{
-			/* apply the inverse of the sensitivity to the raw value so that */
-			/* it will still cover the full min->max range requested after */
-			/* we apply the sensitivity adjustment */
-			info->accum = APPLY_INVERSE_SENSITIVITY(rawvalue, port->analog.sensitivity);
-			info->lastdigital = 0;
+			/* allow both the analog joystick and the keyboard to control the input port */
+			if (rawvalue != 0 || !info->lastdigital) {
+				/* apply the inverse of the sensitivity to the raw value so that */
+				/* it will still cover the full min->max range requested after */
+				/* we apply the sensitivity adjustment */
+				info->accum = APPLY_INVERSE_SENSITIVITY(rawvalue, port->analog.sensitivity);
+				info->lastdigital = 0;
+			}
 		}
 
 		/* if our last movement was due to a digital input, and if this control */
 		/* type autocenters, and if neither the increment nor the decrement seq */
 		/* was pressed, apply autocentering */
diff -U 5 --new-file --recursive src.ori/input.c src/input.c
--- src.ori/input.c	2004-09-21 20:02:10.000000000 +0200
+++ src/input.c	2005-02-13 13:37:33.000000000 +0100
@@ -603,11 +603,33 @@
 	code_count = 0;
 	free(code_map);
 	code_map = NULL;
 }
 
+os_code_t code_to_oscode(input_code_t code)
+{
+	if (code_map[code].osinfo != NULL)
+		return code_map[code].osinfo->oscode;
+	else
+		return 0;
+}
 
+input_code_t oscode_to_code(os_code_t oscode)
+{
+	unsigned i;
+
+	for(i=0;i<code_count;++i) {
+		if (code_map[i].osinfo != NULL && code_map[i].osinfo->oscode == oscode) {
+			break;
+		}
+	}
+
+	if (i == code_count)
+		return CODE_NONE;
+
+	return i;
+}
 
 /*************************************
  *
  *	Return the analog value of a code.
  *
diff -U 5 --new-file --recursive src.ori/input.h src/input.h
--- src.ori/input.h	2004-09-21 20:02:10.000000000 +0200
+++ src/input.h	2005-02-13 13:37:33.000000000 +0100
@@ -479,10 +479,17 @@
 	CODE_NOT,					/* operators for sequences */
 	CODE_OR						/* operators for sequences */
 };
 
 
+/* AdvanceMAME: Remap the F1 key used by some debug code to an unused key. */
+#ifdef MESS
+#define KEYCODE_F1_REAL KEYCODE_F1
+#else
+#define KEYCODE_F1_REAL (KEYCODE_F2-1)
+#define KEYCODE_F1 KEYCODE_NUMLOCK
+#endif
 
 /*************************************
  *
  *	Type definitions
  *
@@ -530,10 +537,13 @@
 
 /* single code functions */
 int code_init(void);
 void code_close(void);
 
+os_code_t code_to_oscode(input_code_t code);
+input_code_t oscode_to_code(os_code_t oscode);
+
 INT32 code_analog_value(input_code_t code);
 int code_pressed(input_code_t code);
 int code_pressed_memory(input_code_t code);
 int code_pressed_memory_repeat(input_code_t code, int speed);
 input_code_t code_read_async(void);
diff -U 5 --new-file --recursive src.ori/mame.c src/mame.c
--- src.ori/mame.c	2005-01-29 00:22:26.000000000 +0100
+++ src/mame.c	2005-02-13 13:37:33.000000000 +0100
@@ -541,10 +541,15 @@
 		if (options.skip_warnings || showgamewarnings(artwork_get_ui_bitmap()) == 0)
 		{
 			/* show info about the game */
 			if (options.skip_gameinfo || showgameinfo(artwork_get_ui_bitmap()) == 0)
 			{
+				/* AdvanceMAME: Force a video update, otherwise with all the skip options the program crash */
+				fillbitmap(artwork_get_ui_bitmap(), get_black_pen(), NULL);
+				schedule_full_refresh();
+				update_video_and_audio();
+
 				init_user_interface();
 
 				/* enable artwork now */
 				artwork_enable(1);
 
diff -U 5 --new-file --recursive src.ori/mame.mak src/mame.mak
--- src.ori/mame.mak	2005-02-16 23:14:58.000000000 +0100
+++ src/mame.mak	2005-02-17 13:18:47.000000000 +0100
@@ -204,11 +204,11 @@
 	$(OBJ)/pacman.a $(OBJ)/epos.a $(OBJ)/nichibut.a \
 	$(OBJ)/phoenix.a $(OBJ)/namco.a $(OBJ)/univers.a $(OBJ)/nintendo.a \
 	$(OBJ)/midw8080.a $(OBJ)/meadows.a $(OBJ)/cvs.a $(OBJ)/midway.a \
 	$(OBJ)/irem.a $(OBJ)/gottlieb.a $(OBJ)/taito.a $(OBJ)/toaplan.a $(OBJ)/cave.a \
 	$(OBJ)/kyugo.a $(OBJ)/williams.a $(OBJ)/gremlin.a $(OBJ)/vicdual.a \
-	$(OBJ)/capcom.a $(OBJ)/itech.a $(OBJ)/leland.a $(OBJ)/sega.a $(OBJ)/deniam.a \
+	$(OBJ)/capcom.a $(OBJ)/itech.a $(OBJ)/leland.a $(OBJ)/sega.a \
 	$(OBJ)/dataeast.a $(OBJ)/tehkan.a $(OBJ)/konami.a \
 	$(OBJ)/exidy.a $(OBJ)/atari.a $(OBJ)/snk.a $(OBJ)/alpha.a $(OBJ)/technos.a \
 	$(OBJ)/stern.a $(OBJ)/gameplan.a $(OBJ)/zaccaria.a \
 	$(OBJ)/upl.a $(OBJ)/nmk.a $(OBJ)/cinemar.a $(OBJ)/cinemav.a \
 	$(OBJ)/thepit.a $(OBJ)/valadon.a $(OBJ)/seibu.a $(OBJ)/tad.a $(OBJ)/jaleco.a \
diff -U 5 --new-file --recursive src.ori/osdepend.h src/osdepend.h
--- src.ori/osdepend.h	2005-01-29 00:22:26.000000000 +0100
+++ src/osdepend.h	2005-02-13 13:37:33.000000000 +0100
@@ -350,10 +350,48 @@
       __attribute__ ((format (printf, 1, 2)));
 #else
 void CLIB_DECL logerror(const char *text,...);
 #endif
 
+/* AdvanceMAME: Specific OSD interface */
+
+/* return the analog value of the specified input. */
+INT32 osd_get_analog_value(unsigned type, unsigned player, int* analog_type);
+
+/* called then the game is reset */
+void osd_reset(void);
+
+/* execute the specified menu (0,1,...) */
+int osd_menu(unsigned menu, struct mame_bitmap *bitmap, int sel);
+
+/* filter the main exit request */
+int osd_input_exit_filter(int result);
+
+/* filter the input port state */
+int osd_input_port_filter(int result, unsigned type, unsigned player, int seqtype);
+
+/* snapshot saving */
+void osd_save_snapshot(void);
+
+/* start and stop the video/sound recording. */
+void osd_record_start(void);
+void osd_record_stop(void);
+
+void osd_ui_menu(const char** items,const char** subitems, char* flag, int selected, int arrowize_subitem);
+void osd_ui_message(const char* text, int second);
+void osd_ui_osd(const char *text, int percentage, int default_percentage);
+void osd_ui_scroll(const char* text, int* pos);
+
+/* customize the inputport */
+void osd_config_load_default(struct InputPortDefinition* backup, struct InputPortDefinition* list);
+void osd_config_load(struct InputPort* backup, struct InputPort* list);
+void osd_config_save_default(struct InputPortDefinition* backup, struct InputPortDefinition* list);
+void osd_config_save(struct InputPort* backup, struct InputPort* list);
+
+/* handle the specific user interface */
+int osd_handle_user_interface(struct mame_bitmap *bitmap, int is_menu_active);
+
 #ifdef __cplusplus
 }
 #endif
 
 #endif
diff -U 5 --new-file --recursive src.ori/rules.mak src/rules.mak
--- src.ori/rules.mak	2005-02-11 20:37:08.000000000 +0100
+++ src/rules.mak	2005-02-13 13:37:33.000000000 +0100
@@ -1166,16 +1166,16 @@
 CPUOBJS += $(OBJ)/$(G6D)/g65816o1.o
 CPUOBJS += $(OBJ)/$(G6D)/g65816o2.o
 CPUOBJS += $(OBJ)/$(G6D)/g65816o3.o
 CPUOBJS += $(OBJ)/$(G6D)/g65816o4.o
 DBGOBJS += $(OBJ)/$(G6D)/g65816ds.o
-$(OBJ)/$(G6D)/g65816.o: $(G6D)/g65816.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
-$(OBJ)/$(G6D)/g65816o0.o: $(G6D)/g65816o0.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
-$(OBJ)/$(G6D)/g65816o1.o: $(G6D)/g65816o0.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
-$(OBJ)/$(G6D)/g65816o2.o: $(G6D)/g65816o0.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
-$(OBJ)/$(G6D)/g65816o3.o: $(G6D)/g65816o0.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
-$(OBJ)/$(G6D)/g65816o4.o: $(G6D)/g65816o0.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
+$(OBJ)/$(G6D)/g65816.o: g65816.c g65816.h g65816cm.h g65816op.h
+$(OBJ)/$(G6D)/g65816o0.o: g65816o0.c g65816.h g65816cm.h g65816op.h
+$(OBJ)/$(G6D)/g65816o1.o: g65816o0.c g65816.h g65816cm.h g65816op.h
+$(OBJ)/$(G6D)/g65816o2.o: g65816o0.c g65816.h g65816cm.h g65816op.h
+$(OBJ)/$(G6D)/g65816o3.o: g65816o0.c g65816.h g65816cm.h g65816op.h
+$(OBJ)/$(G6D)/g65816o4.o: g65816o0.c g65816.h g65816cm.h g65816op.h
 else
 CPUDEFS += -DHAS_G65816=0
 endif
 
 CPU=$(strip $(findstring SPC700@,$(CPUS)))
@@ -1183,11 +1183,11 @@
 SPCD = cpu/spc700
 OBJDIRS += $(OBJ)/$(SPCD)
 CPUDEFS += -DHAS_SPC700=1
 CPUOBJS += $(OBJ)/$(SPCD)/spc700.o
 DBGOBJS += $(OBJ)/$(SPCD)/spc700ds.o
-$(OBJ)/$(SPCD)/spc700/spc700.o: $(SPCD)/spc700.c $(SPCD)/spc700.h
+$(OBJ)/$(SPCD)/spc700.o: spc700.c spc700.h
 else
 CPUDEFS += -DHAS_SPC700=0
 endif
 
 CPU=$(strip $(findstring E116T@,$(CPUS)))
@@ -1507,13 +1507,13 @@
 
 SOUND=$(strip $(findstring DISCRETE@,$(SOUNDS)))
 ifneq ($(SOUND),)
 SOUNDDEFS += -DHAS_DISCRETE=1
 SOUNDOBJS += $(OBJ)/sound/discrete.o
-$(OBJ)/sound/discrete.o: src/sound/discrete.c src/sound/discrete.h \
-		src/sound/disc_dev.c src/sound/disc_flt.c src/sound/disc_inp.c \
-		src/sound/disc_mth.c src/sound/disc_wav.c
+$(OBJ)/sound/discrete.o: discrete.c discrete.h \
+		disc_dev.c disc_flt.c disc_inp.c \
+		disc_mth.c disc_wav.c
 else
 SOUNDDEFS += -DHAS_DISCRETE=0
 endif
 
 SOUND=$(strip $(findstring AY8910@,$(SOUNDS)))
diff -U 5 --new-file --recursive src.ori/ui_text.c src/ui_text.c
--- src.ori/ui_text.c	2004-08-22 21:14:00.000000000 +0200
+++ src/ui_text.c	2005-02-13 13:37:33.000000000 +0100
@@ -191,10 +191,14 @@
 	"One match found - added to list",
 
 	/* refresh rate */
 	"Refresh rate",
 
+	/* AdvanceMAME: Extra user interface commands */
+	"Video",
+	"Audio",
+
 	NULL
 };
 
 
 
diff -U 5 --new-file --recursive src.ori/ui_text.h src/ui_text.h
--- src.ori/ui_text.h	2004-07-28 22:26:24.000000000 +0200
+++ src/ui_text.h	2005-02-13 13:37:33.000000000 +0100
@@ -185,10 +185,14 @@
 	UI_search_one_match_found_added,
 	
 	/* refresh rate */
 	UI_refresh_rate,
 
+	/* AdvanceMAME: Extra user interface commands */
+	UI_osd_1,
+	UI_osd_2,
+
 	UI_last_mame_entry
 };
 
 #ifdef MESS
 #include "mui_text.h"
diff -U 5 --new-file --recursive src.ori/usrintrf.c src/usrintrf.c
--- src.ori/usrintrf.c	2005-01-03 15:05:50.000000000 +0100
+++ src/usrintrf.c	2005-02-13 13:37:33.000000000 +0100
@@ -809,10 +809,13 @@
 
 
 
 void ui_displaymenu(struct mame_bitmap *bitmap,const char **items,const char **subitems,char *flag,int selected,int arrowize_subitem)
 {
+#if 1 /* AdvanceMAME: Use custom ui code */
+	osd_ui_menu(items, subitems, flag, selected, arrowize_subitem);
+#else
 	struct DisplayText dt[256];
 	int curr_dt;
 	const char *lefthilight = ui_getstring (UI_lefthilight);
 	const char *righthilight = ui_getstring (UI_righthilight);
 	const char *uparrow = ui_getstring (UI_uparrow);
@@ -979,15 +982,19 @@
 		if (long_y + long_dy > uirotheight)
 			long_y = topoffs + i * 3*uirotcharheight/2 - long_dy;
 
 		ui_multitextbox_ex(bitmap,subitems[selected],subitems[selected] + strlen(subitems[selected]), long_max, long_x,long_y,long_dx,long_dy, UI_COLOR_NORMAL);
 	}
+#endif
 }
 
 
 void ui_displaymessagewindow(struct mame_bitmap *bitmap,const char *text)
 {
+#if 1 /* AdvanceMAME: Use custom ui code */
+	osd_ui_scroll(text, 0);
+#else
 	struct DisplayText dt[256];
 	int curr_dt;
 	char *c,*c2;
 	int i,len,maxlen,lines;
 	char textcopy[2048];
@@ -1082,10 +1089,11 @@
 	}
 
 	dt[curr_dt].text = 0;	/* terminate array */
 
 	displaytext(bitmap,dt);
+#endif
 }
 
 
 
 static void showcharset(struct mame_bitmap *bitmap)
@@ -1758,15 +1766,17 @@
 					menu_item[total] = in->name;
 					total++;
 				}
 				else
 				{
+#if 0 /* AdvanceMAME: The analog configuration is done at OSD level */
 					entry[total] = &in->defaultseq;
 					defentry[total] = &indef->defaultseq;
 					sprintf(menu_item_buffer[total], "%s Analog", in->name);
 					menu_item[total] = menu_item_buffer[total];
 					total++;
+#endif
 
 					analog[total] = 0;
 					entry[total] = &in->defaultdecseq;
 					defentry[total] = &indef->defaultdecseq;
 					sprintf(menu_item_buffer[total], "%s Dec", in->name);
@@ -1945,16 +1955,18 @@
 				menu_subitem[total] = menu_subitem_buffer[total];
 				total++;
 			}
 			else
 			{
+#if 0 /* AdvanceMAME: The analog configuration is done at OSD level */
 				seq[total] = &in->seq;
 				sprintf(menu_item_buffer[total], "%s Analog", input_port_name(in));
 				menu_item[total] = menu_item_buffer[total];
 				seq_name(input_port_seq(in, SEQ_TYPE_STANDARD), menu_subitem_buffer[total], sizeof(menu_subitem_buffer[0]));
 				menu_subitem[total] = menu_subitem_buffer[total];
 				total++;
+#endif
 
 				analog[total] = 0;
 				seq[total] = &in->analog.decseq;
 				sprintf(menu_item_buffer[total], "%s Dec", input_port_name(in));
 				menu_item[total] = menu_item_buffer[total];
@@ -2783,10 +2795,13 @@
 }
 
 /* Display lines from buffer, starting with line 'scroll', in a width x height text window */
 static void display_scroll_message (struct mame_bitmap *bitmap, int *scroll, int width, int height, char *buf)
 {
+#if 1 /* AdvanceMAME: Use custom ui code */
+	osd_ui_scroll(buf, scroll);
+#else
 	struct DisplayText dt[256];
 	int curr_dt = 0;
 	const char *uparrow = ui_getstring (UI_uparrow);
 	const char *downarrow = ui_getstring (UI_downarrow);
 	char textcopy[2048];
@@ -2889,10 +2904,11 @@
 	}
 
 	dt[curr_dt].text = 0;	/* terminate array */
 
 	displaytext(bitmap,dt);
+#endif
 }
 
 
 /* Display text entry for current driver from history.dat and mameinfo.dat. */
 static int displayhistory (struct mame_bitmap *bitmap, int selected)
@@ -2920,11 +2936,13 @@
 		{
 			/* try to load entry */
 			if (load_driver_history (Machine->gamedrv, buf, bufsize) == 0)
 			{
 				scroll = 0;
+#if 0 /* AdvanceMAME: The text is internally wrapped */
 				wordwrap_text_buffer (buf, maxcols);
+#endif
 				strcat(buf,"\n\t");
 				strcat(buf,ui_getstring (UI_lefthilight));
 				strcat(buf," ");
 				strcat(buf,ui_getstring (UI_returntomain));
 				strcat(buf," ");
@@ -3133,16 +3151,16 @@
 
 
 #ifndef MESS
 enum { UI_SWITCH = 0,UI_DEFGROUP,UI_CODE,UI_ANALOG,UI_CALIBRATE,
 		UI_STATS,UI_GAMEINFO, UI_HISTORY,
-		UI_CHEAT,UI_RESET,UI_MEMCARD,UI_EXIT };
+		UI_CHEAT,UI_RESET,UI_MEMCARD,UI_EXIT,UI_OSD_1,UI_OSD_2 };
 #else
 enum { UI_SWITCH = 0,UI_DEFGROUP,UI_CODE,UI_ANALOG,UI_CALIBRATE,
 		UI_GAMEINFO, UI_IMAGEINFO,UI_FILEMANAGER,UI_TAPECONTROL,
-		UI_HISTORY,UI_CHEAT,UI_RESET,UI_MEMCARD,UI_EXIT,
-		UI_CONFIGURATION, UI_CATEGORIES };
+		UI_HISTORY,UI_CHEAT,UI_RESET,UI_MEMCARD,UI_EXIT,UI_OSD_1,UI_OSD_2,
+		UI_CONFIGURATION, UI_CATEGORIES, };
 #endif
 
 
 #define MAX_SETUPMENU_ITEMS 20
 static const char *menu_item[MAX_SETUPMENU_ITEMS];
@@ -3272,10 +3290,13 @@
 		memcard_intf.eject != NULL)
 	{
 		append_menu(UI_memorycard, UI_MEMCARD);
 	}
 
+	/* AdvanceMAME: Extra menu UI_OSD */
+	append_menu(UI_osd_1, UI_OSD_1);
+	append_menu(UI_osd_2, UI_OSD_2);
 	append_menu(UI_resetgame, UI_RESET);
 	append_menu(UI_returntogame, UI_EXIT);
 	menu_item[menu_total] = 0; /* terminate array */
 }
 
@@ -3343,10 +3364,15 @@
 				res = cheat_menu(bitmap, sel >> SEL_BITS);
 				break;
 			case UI_MEMCARD:
 				res = memcard_menu(bitmap, sel >> SEL_BITS);
 				break;
+			/* AdvanceMAME: Extra menu UI_OSD */
+			case UI_OSD_1 :
+			case UI_OSD_2 :
+				res = osd_menu(menu_action[sel & SEL_MASK] - UI_OSD_1, bitmap, sel >> SEL_BITS);
+				break;
 		}
 
 		if (res == -1)
 		{
 			menu_lastselected = sel;
@@ -3388,10 +3414,13 @@
 			case UI_CATEGORIES:
 #endif /* !MESS */
 			case UI_HISTORY:
 			case UI_CHEAT:
 			case UI_MEMCARD:
+			/* AdvanceMAME: Extra menu UI_OSD */
+			case UI_OSD_1 :
+			case UI_OSD_2 :
 				sel |= 1 << SEL_BITS;
 				schedule_full_refresh();
 				break;
 
 			case UI_RESET:
@@ -3428,10 +3457,13 @@
 
 *********************************************************************/
 
 static void displayosd(struct mame_bitmap *bitmap,const char *text,int percentage,int default_percentage)
 {
+#if 1 /* AdvanceMAME: Use custom ui code */
+	osd_ui_osd(text, percentage, default_percentage);
+#else
 	struct DisplayText dt[2];
 	int avail;
 
 
 	avail = (uirotwidth / uirotcharwidth) * 19 / 20;
@@ -3453,10 +3485,11 @@
 	dt[0].color = UI_COLOR_NORMAL;
 	dt[0].x = (uirotwidth - uirotcharwidth * strlen(text)) / 2;
 	dt[0].y = (uirotheight - 2*uirotcharheight) + 2;
 	dt[1].text = 0; /* terminate array */
 	displaytext(bitmap,dt);
+#endif
 }
 
 static void onscrd_adjuster(struct mame_bitmap *bitmap,int increment,int arg)
 {
 	struct InputPort *in = &Machine->input_ports[arg];
@@ -3486,17 +3519,17 @@
 	if (increment)
 	{
 		attenuation = osd_get_mastervolume();
 		attenuation += increment;
 		if (attenuation > 0) attenuation = 0;
-		if (attenuation < -32) attenuation = -32;
+		if (attenuation < -40) attenuation = -40;
 		osd_set_mastervolume(attenuation);
 	}
 	attenuation = osd_get_mastervolume();
 
 	sprintf(buf,"%s %3ddB", ui_getstring (UI_volume), attenuation);
-	displayosd(bitmap,buf,100 * (attenuation + 32) / 32,100);
+	displayosd(bitmap,buf,100 * (attenuation + 40) / 40,100);
 }
 
 static void onscrd_mixervol(struct mame_bitmap *bitmap,int increment,int arg)
 {
 	static void *driver = 0;
@@ -3843,10 +3876,13 @@
 *********************************************************************/
 
 
 static void displaymessage(struct mame_bitmap *bitmap,const char *text)
 {
+#if 1 /* AdvanceMAME: Use custom ui code */
+	osd_ui_message(text, 0);
+#else
 	struct DisplayText dt[2];
 	int avail;
 
 
 	if (uirotwidth < uirotcharwidth * strlen(text))
@@ -3866,10 +3902,11 @@
 	dt[0].color = UI_COLOR_NORMAL;
 	dt[0].x = (uirotwidth - uirotcharwidth * strlen(text)) / 2;
 	dt[0].y = uirotheight - 5*uirotcharheight/2;
 	dt[1].text = 0; /* terminate array */
 	displaytext(bitmap,dt);
+#endif
 }
 
 
 static char messagetext[200];
 static int messagecounter;
@@ -3991,10 +4028,11 @@
 	return show_profiler;
 }
 
 void ui_display_fps(struct mame_bitmap *bitmap)
 {
+#if 0 /* AdvanceMAME: Use custom ui code */
 	const char *text, *end;
 	char textbuf[256];
 	int done = 0;
 	int x, y = 0;
 	/* remember which area we cover so that we can
@@ -4051,32 +4089,31 @@
 	{
 		showfpstemp--;
 		if (!showfps && showfpstemp == 0)
 			schedule_full_refresh();
 	}
+#endif
 }
 
 
 
 int handle_user_interface(struct mame_bitmap *bitmap)
 {
 #ifdef MESS
 	extern int mess_pause_for_ui;
 #endif
 
+	if (osd_handle_user_interface(bitmap, setup_selected != 0) != 0)
+		return 1;
+
 	/* if the user pressed F12, save the screen to a file */
 	if (input_ui_pressed(IPT_UI_SNAPSHOT))
 		save_screen_snapshot(bitmap);
 
 	/* This call is for the cheat, it must be called once a frame */
 	if (options.cheat) DoCheat(bitmap);
 
-	/* if the user pressed ESC, stop the emulation */
-	/* but don't quit if the setup menu is on screen */
-	if (setup_selected == 0 && input_ui_pressed(IPT_UI_CANCEL))
-		return 1;
-
 	if (setup_selected == 0 && input_ui_pressed(IPT_UI_CONFIGURE))
 	{
 		setup_selected = -1;
 		if (osd_selected != 0)
 		{
@@ -4150,11 +4187,11 @@
 			/* if the user pressed F4, show the character set */
 			if (input_ui_pressed(IPT_UI_SHOW_GFX))
 				showcharset(bitmap);
 
 			if (setup_selected == 0 && input_ui_pressed(IPT_UI_CANCEL))
-				return 1;
+				break;
 
 			if (setup_selected == 0 && input_ui_pressed(IPT_UI_CONFIGURE))
 			{
 				setup_selected = -1;
 				if (osd_selected != 0)
@@ -4233,16 +4270,18 @@
 	}
 
 	if (show_profiler) profiler_show(bitmap);
 
 
+#if 0 /* AdvanceMAME: The show_fps action is managed by the osd code */
 	/* show FPS display? */
 	if (input_ui_pressed(IPT_UI_SHOW_FPS))
 	{
 		/* toggle fps */
 		ui_show_fps_set(!ui_show_fps_get());
 	}
+#endif
 
 
 	/* if the user pressed F4, show the character set */
 	if (input_ui_pressed(IPT_UI_SHOW_GFX))
 	{
diff -U 5 --new-file --recursive src.ori/vidhrdw/gladiatr.c src/vidhrdw/gladiatr.c
--- src.ori/vidhrdw/gladiatr.c	2005-02-16 23:14:58.000000000 +0100
+++ src/vidhrdw/gladiatr.c	2005-02-17 07:58:13.000000000 +0100
@@ -279,16 +279,17 @@
 	draw_sprites(bitmap,cliprect);
 
 	/* the fg layer just selects the upper palette bank on underlying pixels */
 	{
 		struct mame_bitmap *transparency_bitmap;
+		int sx, sy;
 
 		tilemap_get_pixmap( fg_tilemap );
 		transparency_bitmap = tilemap_get_transparency_bitmap( fg_tilemap );
 
-		int sx = cliprect->min_x;
-		int sy = cliprect->min_y;
+		sx = cliprect->min_x;
+		sy = cliprect->min_y;
 
 		while( sy <= cliprect->max_y )
 		{
 			int x = sx;
 			int y = (sy + fg_scrolly) & 0x1ff;
diff -U 5 --new-file --recursive src.ori/vidhrdw/voodoo.c src/vidhrdw/voodoo.c
--- src.ori/vidhrdw/voodoo.c	2005-02-04 21:36:32.000000000 +0100
+++ src/vidhrdw/voodoo.c	2005-02-13 13:37:33.000000000 +0100
@@ -16,11 +16,11 @@
  *
  *	Math trickery
  *
  *************************************/
 
-#ifndef _WIN32
+#if 1 /* AdvanceMAME: Use always the portable implementation */
 #define SETUP_FPU()
 #define RESTORE_FPU()
 #define TRUNC_TO_INT(f) (float) (floor(f))
 #else
 #include <float.h>
diff -U 5 --new-file --recursive src.ori/x86drc.c src/x86drc.c
--- src.ori/x86drc.c	2004-11-23 18:05:40.000000000 +0100
+++ src/x86drc.c	2005-02-13 13:37:33.000000000 +0100
@@ -677,10 +677,11 @@
 
 
 /*------------------------------------------------------------------
 	drc_x86_get_features()
 ------------------------------------------------------------------*/
+#if 0
 UINT32 drc_x86_get_features(void)
 {
 	UINT32 features = 0;
 #ifdef _MSC_VER
 	__asm 
@@ -706,10 +707,11 @@
 	: "%ebx", "%ecx", "%edx"	/* clobbers ebx, ecx and edx */
 	);
 #endif /* MSC_VER */
 	return features;
 }
+#endif
 
 
 
 /*------------------------------------------------------------------
 	log_dispatch
