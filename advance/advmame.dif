diff -U 5 --new-file --recursive src.ori/advance.pat src/advance.pat
--- src.ori/advance.pat	1970-01-01 01:00:00.000000000 +0100
+++ src/advance.pat	2005-10-15 08:49:57.000000000 +0200
@@ -0,0 +1 @@
+These files are patched for the use with the Advance emulator.
diff -U 5 --new-file --recursive src.ori/common.c src/common.c
--- src.ori/common.c	2005-09-05 17:31:36.000000000 +0200
+++ src/common.c	2005-10-15 08:49:57.000000000 +0200
@@ -662,10 +662,11 @@
 /*-------------------------------------------------
     save_frame_with - save a frame with a
     given handler for screenshots and movies
 -------------------------------------------------*/
 
+#if 0 /* AdvanceMAME has its snapshot code */
 static void save_frame_with(mame_file *fp, mame_bitmap *bitmap, int (*write_handler)(mame_file *, mame_bitmap *))
 {
 	rectangle bounds;
 	mame_bitmap *osdcopy;
 	UINT32 saved_rgb_components[3];
@@ -765,20 +766,23 @@
 
 	/* if the OSD system allocated a bitmap; free it */
 	if (osdcopy)
 		bitmap_free(osdcopy);
 }
+#endif
 
 
  /*-------------------------------------------------
     save_screen_snapshot_as - save a snapshot to
     the given file handle
 -------------------------------------------------*/
 
 void save_screen_snapshot_as(mame_file *fp, mame_bitmap *bitmap)
 {
+#if 0 /* AdvanceMAME has its snapshot code */
 	save_frame_with(fp, bitmap, png_write_bitmap);
+#endif
 }
 
 
 /*-------------------------------------------------
     open the next non-existing file of type
@@ -811,26 +815,31 @@
     save_screen_snapshot - save a snapshot.
 -------------------------------------------------*/
 
 void save_screen_snapshot(mame_bitmap *bitmap)
 {
+#if 1 /* AdvanceMAME has its snapshot code */
+	osd_save_snapshot();
+#else
 	mame_file *fp;
 
 	if ((fp = mame_fopen_next(FILETYPE_SCREENSHOT)) != NULL)
 	{
 		save_screen_snapshot_as(fp, bitmap);
 		mame_fclose(fp);
 	}
+#endif
 }
 
  /*-------------------------------------------------
     record_movie - start, stop and update the
     recording of a MNG movie
 -------------------------------------------------*/
 
 void record_movie_toggle(void)
 {
+#if 0 /* AdvanceMAME has its record code */
 	if (movie_file == NULL)
 	{
 		movie_frame = 0;
 		movie_file = mame_fopen_next(FILETYPE_MOVIE);
 		if (movie_file)
@@ -841,28 +850,33 @@
 		mng_capture_stop(movie_file);
 		mame_fclose(movie_file);
 		movie_file = NULL;
 		ui_popup("REC STOP (%d frames)", movie_frame);
 	}
+#endif
 }
 
 
 void record_movie_stop(void)
 {
+#if 0 /* AdvanceMAME has its record code */
 	if (movie_file)
 		record_movie_toggle();
+#endif
 }
 
 
 void record_movie_frame(mame_bitmap *bitmap)
 {
+#if 0 /* AdvanceMAME has its record code */
 	if (movie_file != NULL && bitmap != NULL)
 	{
 		if (movie_frame++ == 0)
 			save_frame_with(movie_file, bitmap, mng_capture_start);
 		save_frame_with(movie_file, bitmap, mng_capture_frame);
 	}
+#endif
 }
 
 
 
 /***************************************************************************
@@ -1217,11 +1231,11 @@
 		}
 		else
 			strcat(romdata->errorbuf, "WARNING: the game might not run correctly.\n");
 
 		/* display the result */
-		printf("%s", romdata->errorbuf);
+		osd_display_loading_rom_message(romdata->errorbuf, 0);
 	}
 
 	/* clean up any regions */
 	if (romdata->errors)
 		for (region = 0; region < MAX_MEMORY_REGIONS; region++)
diff -U 5 --new-file --recursive src.ori/config.c src/config.c
--- src.ori/config.c	2005-09-08 08:30:46.000000000 +0200
+++ src/config.c	2005-10-15 08:49:57.000000000 +0200
@@ -112,20 +112,27 @@
  *
  *  Settings save/load frontend
  *
  *************************************/
 
+int input_config_load_settings();
+void input_config_save_settings(void);
+
 int config_load_settings(void)
 {
 	config_type *type;
 	mame_file *file;
 	int loaded = 0;
 
 	/* loop over all registrants and call their init function */
 	for (type = typelist; type; type = type->next)
 		(*type->load)(CONFIG_TYPE_INIT, NULL);
 
+/* AdvanceMAME: Specific configuration for port */
+#if 1
+	loaded = input_config_load_settings();
+#else
 	/* now load the controller file */
 	if (options.controller != NULL)
 	{
 		/* open the config file */
 		file = mame_fopen(NULL, options.controller, FILETYPE_CTRLR, 0);
@@ -151,10 +158,11 @@
 	if (file)
 	{
 		loaded = config_load_xml(file, CONFIG_TYPE_GAME);
 		mame_fclose(file);
 	}
+#endif
 
 	/* loop over all registrants and call their final function */
 	for (type = typelist; type; type = type->next)
 		(*type->load)(CONFIG_TYPE_FINAL, NULL);
 
@@ -171,10 +179,14 @@
 
 	/* loop over all registrants and call their init function */
 	for (type = typelist; type; type = type->next)
 		(*type->save)(CONFIG_TYPE_INIT, NULL);
 
+/* AdvanceMAME: Specific configuration for port */
+#if 1
+	input_config_save_settings();
+#else
 	/* save the defaults file */
 	file = mame_fopen("default", 0, FILETYPE_CONFIG, 1);
 	if (file)
 	{
 		config_save_xml(file, CONFIG_TYPE_DEFAULT);
@@ -186,10 +198,11 @@
 	if (file)
 	{
 		config_save_xml(file, CONFIG_TYPE_GAME);
 		mame_fclose(file);
 	}
+#endif
 
 	/* loop over all registrants and call their final function */
 	for (type = typelist; type; type = type->next)
 		(*type->save)(CONFIG_TYPE_FINAL, NULL);
 }
diff -U 5 --new-file --recursive src.ori/cpuexec.c src/cpuexec.c
--- src.ori/cpuexec.c	2005-09-08 08:30:46.000000000 +0200
+++ src/cpuexec.c	2005-10-15 08:49:57.000000000 +0200
@@ -374,10 +374,13 @@
 	watchdog_setup(TRUE);
 
 	/* reset sound chips */
 	sound_reset();
 
+	/* reset the osd level */
+	osd_reset();
+
 	/* first pass over CPUs */
 	for (cpunum = 0; cpunum < cpu_gettotalcpu(); cpunum++)
 	{
 		/* enable all CPUs (except for disabled CPUs) */
 		if (!(Machine->drv->cpu[cpunum].cpu_flags & CPU_DISABLE))
diff -U 5 --new-file --recursive src.ori/drivers/namcos11.c src/drivers/namcos11.c
--- src.ori/drivers/namcos11.c	2005-09-13 09:25:10.000000000 +0200
+++ src/drivers/namcos11.c	2005-10-15 08:49:57.000000000 +0200
@@ -834,11 +834,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 8, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type1 )
 	MDRV_VIDEO_UPDATE( psx )
diff -U 5 --new-file --recursive src.ori/drivers/namcos12.c src/drivers/namcos12.c
--- src.ori/drivers/namcos12.c	2005-09-12 06:39:04.000000000 +0200
+++ src/drivers/namcos12.c	2005-10-15 08:49:57.000000000 +0200
@@ -1135,11 +1135,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 480-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
diff -U 5 --new-file --recursive src.ori/drivers/psikyo4.c src/drivers/psikyo4.c
--- src.ori/drivers/psikyo4.c	2005-08-29 21:46:22.000000000 +0200
+++ src/drivers/psikyo4.c	2005-10-15 08:49:57.000000000 +0200
@@ -414,13 +414,13 @@
 	MDRV_NVRAM_HANDLER(93C56)
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES(VIDEO_TYPE_RASTER | VIDEO_NEEDS_6BITS_PER_GUN | VIDEO_DUAL_MONITOR)
 #if DUAL_SCREEN
-	MDRV_ASPECT_RATIO(8,3)
+	MDRV_ASPECT_RATIO(4,3)
 	MDRV_SCREEN_SIZE(80*8, 32*8)
-	MDRV_VISIBLE_AREA(0, 80*8-1, 0, 28*8-1)
+	MDRV_VISIBLE_AREA(0, 320-1, 0, 28*8-1)
 #else
 	MDRV_ASPECT_RATIO(4,3)
 	MDRV_SCREEN_SIZE(64*8, 32*8)
 	MDRV_VISIBLE_AREA(0, 40*8-1, 0, 28*8-1)
 #endif
@@ -443,11 +443,11 @@
 static MACHINE_DRIVER_START( ps4small )
 	/* basic machine hardware */
 	MDRV_IMPORT_FROM(ps4big)
 
 #if DUAL_SCREEN
-	MDRV_VISIBLE_AREA(0, 80*8-1, 0, 30*8-1)
+	MDRV_VISIBLE_AREA(0, 320-1, 0, 30*8-1)
 #else
 	MDRV_VISIBLE_AREA(0, 40*8-1, 0, 30*8-1)
 #endif
 MACHINE_DRIVER_END
 
diff -U 5 --new-file --recursive src.ori/drivers/stv.c src/drivers/stv.c
--- src.ori/drivers/stv.c	2005-09-08 22:08:30.000000000 +0200
+++ src/drivers/stv.c	2005-10-15 08:49:57.000000000 +0200
@@ -4393,11 +4393,11 @@
 	MDRV_NVRAM_HANDLER(stv) /* Actually 93c45 */
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES(VIDEO_TYPE_RASTER | VIDEO_UPDATE_AFTER_VBLANK | VIDEO_RGB_DIRECT )
 	MDRV_SCREEN_SIZE(1024, 1024)
-	MDRV_VISIBLE_AREA(0*8, 703, 0*8, 512) // we need to use a resolution as high as the max size it can change to
+	MDRV_VISIBLE_AREA(0*8, 320-1, 0*8, 224-1)
 	MDRV_PALETTE_LENGTH(2048+(2048*2))//standard palette + extra memory for rgb brightness.
 	MDRV_GFXDECODE(gfxdecodeinfo)
 
 	MDRV_VIDEO_START(stv_vdp2)
 	MDRV_VIDEO_UPDATE(stv_vdp2)
diff -U 5 --new-file --recursive src.ori/drivers/zn.c src/drivers/zn.c
--- src.ori/drivers/zn.c	2005-08-29 09:13:22.000000000 +0200
+++ src/drivers/zn.c	2005-10-15 08:49:57.000000000 +0200
@@ -652,11 +652,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 512 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -695,11 +695,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -904,11 +904,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -1336,11 +1336,11 @@
 	MDRV_NVRAM_HANDLER( coh1000ta )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 512 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -1439,11 +1439,11 @@
 	MDRV_NVRAM_HANDLER( coh1000tb )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -1629,11 +1629,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -1843,11 +1843,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -2089,11 +2089,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 320-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -2430,11 +2430,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -2601,11 +2601,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 320-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -2686,11 +2686,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 320-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -2955,11 +2955,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 480-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -2992,11 +2992,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 320-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -3032,11 +3032,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 320-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
diff -U 5 --new-file --recursive src.ori/inptport.c src/inptport.c
--- src.ori/inptport.c	2005-09-12 06:42:22.000000000 +0200
+++ src/inptport.c	2005-10-15 08:49:57.000000000 +0200
@@ -860,11 +860,13 @@
 	INPUT_PORT_DIGITAL_DEF( 0, IPG_UI,      UI_FRAMESKIP_DEC,	"Frameskip Dec",		SEQ_DEF_1(KEYCODE_F8) )
 	INPUT_PORT_DIGITAL_DEF( 0, IPG_UI,      UI_FRAMESKIP_INC,	"Frameskip Inc",		SEQ_DEF_1(KEYCODE_F9) )
 	INPUT_PORT_DIGITAL_DEF( 0, IPG_UI,      UI_THROTTLE,		"Throttle",				SEQ_DEF_1(KEYCODE_F10) )
 	INPUT_PORT_DIGITAL_DEF( 0, IPG_UI,      UI_SHOW_FPS,		"Show FPS",				SEQ_DEF_5(KEYCODE_F11, CODE_NOT, KEYCODE_LCONTROL, CODE_NOT, KEYCODE_LSHIFT) )
 	INPUT_PORT_DIGITAL_DEF( 0, IPG_UI,      UI_SNAPSHOT,		"Save Snapshot",		SEQ_DEF_3(KEYCODE_F12, CODE_NOT, KEYCODE_LSHIFT) )
+#if 0 /* AdvanceMAME has its record code */
 	INPUT_PORT_DIGITAL_DEF( 0, IPG_UI,      UI_RECORD_MOVIE,	"Record Movie",			SEQ_DEF_2(KEYCODE_F12, KEYCODE_LSHIFT) )
+#endif
 	INPUT_PORT_DIGITAL_DEF( 0, IPG_UI,      UI_TOGGLE_CHEAT,	"Toggle Cheat",			SEQ_DEF_1(KEYCODE_F6) )
 	INPUT_PORT_DIGITAL_DEF( 0, IPG_UI,      UI_UP,				"UI Up",				SEQ_DEF_3(KEYCODE_UP, CODE_OR, JOYCODE_1_UP) )
 	INPUT_PORT_DIGITAL_DEF( 0, IPG_UI,      UI_DOWN,			"UI Down",				SEQ_DEF_3(KEYCODE_DOWN, CODE_OR, JOYCODE_1_DOWN) )
 	INPUT_PORT_DIGITAL_DEF( 0, IPG_UI,      UI_LEFT,			"UI Left",				SEQ_DEF_3(KEYCODE_LEFT, CODE_OR, JOYCODE_1_LEFT) )
 	INPUT_PORT_DIGITAL_DEF( 0, IPG_UI,      UI_RIGHT,			"UI Right",				SEQ_DEF_3(KEYCODE_RIGHT, CODE_OR, JOYCODE_1_RIGHT) )
@@ -919,10 +921,32 @@
 static input_port_default_entry default_ports[ARRAY_LENGTH(default_ports_builtin)];
 static input_port_default_entry default_ports_backup[ARRAY_LENGTH(default_ports_builtin)];
 static const int input_port_count = ARRAY_LENGTH(default_ports_builtin);
 static int default_ports_lookup[__ipt_max][MAX_PLAYERS];
 
+/* AdvanceMAME: Custom settings load */
+int input_config_load_settings()
+{
+	/* AdvanceMAME: Load user defined customization */
+	osd_config_load_default(default_ports_backup, default_ports);
+
+	/* AdvanceMAME: Load user defined customization */
+	osd_config_load(Machine->input_ports_default, Machine->input_ports);
+
+	/* AdvanceMAME: Report no setting loaded, always show the disclaimer */
+	return 0;
+}
+
+/* AdvanceMAME: Custom settings save */
+void input_config_save_settings(void)
+{
+	/* AdvanceMAME: Save user defined customization */
+	osd_config_save_default(default_ports_backup, default_ports);
+
+	/* AdvanceMAME: Save user defined customization */
+	osd_config_save(Machine->input_ports_default, Machine->input_ports);
+}
 
 
 /*************************************
  *
  *  Function prototypes
@@ -1880,12 +1904,18 @@
  *************************************/
 
 int input_port_type_pressed(int type, int player)
 {
 	int defindex = default_ports_lookup[type][player];
-	if (defindex != -1)
-		return seq_pressed(&default_ports[defindex].defaultseq);
+	if (defindex != -1) {
+		int pressed = seq_pressed(&default_ports[defindex].defaultseq);
+
+		/* AdvanceMAME: Filter all the input ports */
+		pressed = osd_input_port_filter(pressed, type, player, SEQ_TYPE_STANDARD);
+
+		return pressed;
+	}
 
 	return 0;
 }
 
 
@@ -1896,10 +1926,13 @@
 profiler_mark(PROFILER_INPUT);
 
 	/* get the status of this key (assumed to be only in the defaults) */
 	pressed = seq_pressed(input_port_default_seq(code, 0, SEQ_TYPE_STANDARD));
 
+	/* AdvanceMAME: Filter all the input ports */
+	pressed = osd_input_port_filter(pressed, code, 0, SEQ_TYPE_STANDARD);
+
 	/* if pressed, handle it specially */
 	if (pressed)
 	{
 		/* if this is the first press, leave pressed = 1 */
 		if (ui_memory[code] == 0)
@@ -1929,10 +1962,13 @@
 profiler_mark(PROFILER_INPUT);
 
 	/* get the status of this key (assumed to be only in the defaults) */
 	pressed = seq_pressed(input_port_default_seq(code, 0, SEQ_TYPE_STANDARD));
 
+	/* AdvanceMAME: Filter all the input ports */
+	pressed = osd_input_port_filter(pressed, code, 0, SEQ_TYPE_STANDARD);
+
 	/* if so, handle it specially */
 	if (pressed)
 	{
 		/* if this is the first press, set a 3x delay and leave pressed = 1 */
 		if (ui_memory[code] == 0)
@@ -2046,10 +2082,13 @@
 void input_port_vblank_start(void)
 {
 	int ui_visible = ui_is_setup_active() || ui_is_onscrd_active();
 	int portnum, bitnum;
 
+	/* AdvanceMAME: Never disable the input port. */
+	ui_visible = 0;
+
 profiler_mark(PROFILER_INPUT);
 
 	/* update the digital joysticks first */
 	update_digital_joysticks();
 
@@ -2081,11 +2120,16 @@
 
 				/* handle non-analog types, but only when the UI isn't visible */
 				if (port->type != IPT_VBLANK && !IS_ANALOG(port) && !ui_visible)
 				{
 					/* if the sequence for this port is currently pressed.... */
-					if (seq_pressed(input_port_seq(port, SEQ_TYPE_STANDARD)))
+					int pressed = seq_pressed(input_port_seq(port, SEQ_TYPE_STANDARD));
+
+					/* AdvanceMAME: Filter all the input ports */
+					pressed = osd_input_port_filter(pressed, port->type, port->player, SEQ_TYPE_STANDARD);
+
+					if (pressed)
 					{
 #ifdef MESS
 						/* (MESS-specific) check for disabled keyboard */
 						if (port->type == IPT_KEYBOARD && osd_keyboard_disabled())
 							continue;
@@ -2207,17 +2251,18 @@
 			{
 				info->previous = info->current;
 				info->current = 0;
 
 				/* read all the associated ports */
-				if (info->port[JOYDIR_UP] != NULL && seq_pressed(input_port_seq(info->port[JOYDIR_UP], SEQ_TYPE_STANDARD)))
+				/* AdvanceMAME: Filter all the input ports */
+				if (info->port[JOYDIR_UP] != NULL && osd_input_port_filter(seq_pressed(input_port_seq(info->port[JOYDIR_UP], SEQ_TYPE_STANDARD)), info->port[JOYDIR_UP]->type, info->port[JOYDIR_UP]->player, SEQ_TYPE_STANDARD))
 					info->current |= JOYDIR_UP_BIT;
-				if (info->port[JOYDIR_DOWN] != NULL && seq_pressed(input_port_seq(info->port[JOYDIR_DOWN], SEQ_TYPE_STANDARD)))
+				if (info->port[JOYDIR_DOWN] != NULL && osd_input_port_filter(seq_pressed(input_port_seq(info->port[JOYDIR_DOWN], SEQ_TYPE_STANDARD)), info->port[JOYDIR_DOWN]->type, info->port[JOYDIR_DOWN]->player, SEQ_TYPE_STANDARD))
 					info->current |= JOYDIR_DOWN_BIT;
-				if (info->port[JOYDIR_LEFT] != NULL && seq_pressed(input_port_seq(info->port[JOYDIR_LEFT], SEQ_TYPE_STANDARD)))
+				if (info->port[JOYDIR_LEFT] != NULL && osd_input_port_filter(seq_pressed(input_port_seq(info->port[JOYDIR_LEFT], SEQ_TYPE_STANDARD)), info->port[JOYDIR_LEFT]->type, info->port[JOYDIR_LEFT]->player, SEQ_TYPE_STANDARD))
 					info->current |= JOYDIR_LEFT_BIT;
-				if (info->port[JOYDIR_RIGHT] != NULL && seq_pressed(input_port_seq(info->port[JOYDIR_RIGHT], SEQ_TYPE_STANDARD)))
+				if (info->port[JOYDIR_RIGHT] != NULL && osd_input_port_filter(seq_pressed(input_port_seq(info->port[JOYDIR_RIGHT], SEQ_TYPE_STANDARD)), info->port[JOYDIR_RIGHT]->type, info->port[JOYDIR_RIGHT]->player, SEQ_TYPE_STANDARD))
 					info->current |= JOYDIR_RIGHT_BIT;
 
 				/* lock out opposing directions (left + right or up + down) */
 				if ((info->current & (JOYDIR_UP_BIT | JOYDIR_DOWN_BIT)) == (JOYDIR_UP_BIT | JOYDIR_DOWN_BIT))
 					info->current &= ~(JOYDIR_UP_BIT | JOYDIR_DOWN_BIT);
@@ -2328,12 +2373,12 @@
 		int analog_type, keypressed = 0;
 
 		/* clamp the previous value to the min/max range and remember it */
 		info->previous = info->accum = apply_analog_min_max(info, info->accum);
 
-		/* get the new raw analog value and its type */
-		rawvalue = seq_analog_value(input_port_seq(port, SEQ_TYPE_STANDARD), &analog_type);
+		/* AdvanceMAME: Get the analog input for different players from the osd core. */
+		rawvalue = osd_get_analog_value(port->type, port->player, &analog_type);
 
 		/* if we got it from a relative device, use that as the starting delta */
 		/* also note that the last input was not a digital one */
 		if (analog_type == ANALOG_TYPE_RELATIVE && rawvalue != 0)
 		{
@@ -2341,18 +2386,20 @@
 			info->lastdigital = 0;
 		}
 
 		/* if the decrement code sequence is pressed, add the key delta to */
 		/* the accumulated delta; also note that the last input was a digital one */
-		if (seq_pressed(input_port_seq(info->port, SEQ_TYPE_DECREMENT)))
+		/* AdvanceMAME: Filter all the input ports */
+		if (osd_input_port_filter(seq_pressed(input_port_seq(info->port, SEQ_TYPE_DECREMENT)), info->port->type, info->port->player, SEQ_TYPE_DECREMENT))
 		{
 			delta -= (INT32)(port->analog.delta * info->keyscale);
 			keypressed = info->lastdigital = 1;
 		}
 
 		/* same for the increment code sequence */
-		if (seq_pressed(input_port_seq(info->port, SEQ_TYPE_INCREMENT)))
+		/* AdvanceMAME: Filter all the input ports */
+		if (osd_input_port_filter(seq_pressed(input_port_seq(info->port, SEQ_TYPE_INCREMENT)), info->port->type, info->port->player, SEQ_TYPE_INCREMENT))
 		{
 			delta += (INT32)(port->analog.delta * info->keyscale);
 			keypressed = info->lastdigital = 1;
 		}
 
@@ -2366,15 +2413,18 @@
 		info->accum += delta;
 
 		/* if we got an absolute input, it overrides everything else */
 		if (analog_type == ANALOG_TYPE_ABSOLUTE)
 		{
-			/* apply the inverse of the sensitivity to the raw value so that */
-			/* it will still cover the full min->max range requested after */
-			/* we apply the sensitivity adjustment */
-			info->accum = APPLY_INVERSE_SENSITIVITY(rawvalue, port->analog.sensitivity);
-			info->lastdigital = 0;
+			/* allow both the analog joystick and the keyboard to control the input port */
+			if (rawvalue != 0 || !info->lastdigital) {
+				/* apply the inverse of the sensitivity to the raw value so that */
+				/* it will still cover the full min->max range requested after */
+				/* we apply the sensitivity adjustment */
+				info->accum = APPLY_INVERSE_SENSITIVITY(rawvalue, port->analog.sensitivity);
+				info->lastdigital = 0;
+			}
 		}
 
 		/* if our last movement was due to a digital input, and if this control */
 		/* type autocenters, and if neither the increment nor the decrement seq */
 		/* was pressed, apply autocentering */
diff -U 5 --new-file --recursive src.ori/input.c src/input.c
--- src.ori/input.c	2005-08-25 08:17:12.000000000 +0200
+++ src/input.c	2005-10-15 08:49:57.000000000 +0200
@@ -605,11 +605,33 @@
 	code_count = 0;
 	free(code_map);
 	code_map = NULL;
 }
 
+os_code code_to_oscode(input_code code)
+{
+	if (code_map[code].osinfo != NULL)
+		return code_map[code].osinfo->oscode;
+	else
+		return 0;
+}
 
+input_code oscode_to_code(os_code oscode)
+{
+	unsigned i;
+
+	for(i=0;i<code_count;++i) {
+		if (code_map[i].osinfo != NULL && code_map[i].osinfo->oscode == oscode) {
+			break;
+		}
+	}
+
+	if (i == code_count)
+		return CODE_NONE;
+
+	return i;
+}
 
 /*************************************
  *
  *  Return the analog value of a code.
  *
diff -U 5 --new-file --recursive src.ori/input.h src/input.h
--- src.ori/input.h	2005-08-25 08:17:12.000000000 +0200
+++ src/input.h	2005-10-15 08:49:57.000000000 +0200
@@ -481,10 +481,17 @@
 	CODE_NOT,					/* operators for sequences */
 	CODE_OR						/* operators for sequences */
 };
 
 
+/* AdvanceMAME: Remap the F1 key used by some debug code to an unused key. */
+#ifdef MESS
+#define KEYCODE_F1_REAL KEYCODE_F1
+#else
+#define KEYCODE_F1_REAL (KEYCODE_F2-1)
+#define KEYCODE_F1 KEYCODE_NUMLOCK
+#endif
 
 /*************************************
  *
  *  Type definitions
  *
@@ -536,10 +543,13 @@
 
 /* single code functions */
 int code_init(void);
 void code_exit(void);
 
+os_code code_to_oscode(input_code code);
+input_code oscode_to_code(os_code oscode);
+
 INT32 code_analog_value(input_code code);
 int code_pressed(input_code code);
 int code_pressed_memory(input_code code);
 int code_pressed_memory_repeat(input_code code, int speed);
 input_code code_read_async(void);
diff -U 5 --new-file --recursive src.ori/mame.c src/mame.c
--- src.ori/mame.c	2005-09-08 08:30:46.000000000 +0200
+++ src/mame.c	2005-10-15 08:49:57.000000000 +0200
@@ -571,10 +571,15 @@
 		if (options.skip_warnings || ui_display_game_warnings(artwork_get_ui_bitmap()) == 0)
 		{
 			/* show info about the game */
 			if (options.skip_gameinfo || ui_display_game_info(artwork_get_ui_bitmap()) == 0)
 			{
+				/* AdvanceMAME: HACK force a video update, otherwise with all the skip options the program crash */
+				fillbitmap(artwork_get_ui_bitmap(), get_black_pen(), NULL);
+				schedule_full_refresh();
+				update_video_and_audio();
+
 				/* enable artwork now */
 				artwork_enable(1);
 
 				/* disable cheat if no roms */
 				if (!gamedrv->rom)
diff -U 5 --new-file --recursive src.ori/mame.mak src/mame.mak
--- src.ori/mame.mak	2005-09-13 09:25:10.000000000 +0200
+++ src/mame.mak	2005-10-15 08:49:57.000000000 +0200
@@ -1311,11 +1311,11 @@
 
 
 COREOBJS += $(OBJ)/driver.o $(OBJ)/cheat.o
 
 # Files shared across several libraries
-OBJS += \
+COREOBJS += \
 	$(OBJ)/machine/segacrpt.o \
 	$(OBJ)/machine/tmp68301.o \
 	$(OBJ)/machine/6532riot.o \
 	$(OBJ)/machine/z80fmly.o \
 	$(OBJ)/machine/6821pia.o \
diff -U 5 --new-file --recursive src.ori/mamecore.h src/mamecore.h
--- src.ori/mamecore.h	2005-09-05 17:31:36.000000000 +0200
+++ src/mamecore.h	2005-10-15 08:49:57.000000000 +0200
@@ -84,10 +84,18 @@
 	int min_y,max_y;
 };
 typedef struct _rectangle rectangle;
 
 
+struct _ui_menu_item
+{
+   const char *text;
+   const char *subtext;
+   UINT32 flags;
+};
+typedef struct _ui_menu_item ui_menu_item;
+
 
 /***************************************************************************
  * Union of UINT8, UINT16 and UINT32 in native endianess of the target
  * This is used to access bytes and words in a machine independent manner.
  * The upper bytes h2 and h3 normally contain zero (16 bit CPU cores)
diff -U 5 --new-file --recursive src.ori/osdepend.h src/osdepend.h
--- src.ori/osdepend.h	2005-08-29 09:13:22.000000000 +0200
+++ src/osdepend.h	2005-10-15 08:49:57.000000000 +0200
@@ -324,6 +324,44 @@
 #include "osd_mess.h"
 #endif
 
 void CLIB_DECL logerror(const char *text,...) ATTR_PRINTF(1,2);
 
+/* AdvanceMAME: Specific OSD interface */
+
+/* return the analog value of the specified input. */
+INT32 osd_get_analog_value(unsigned type, unsigned player, int* analog_type);
+
+/* called then the game is reset */
+void osd_reset(void);
+
+/* execute the specified menu (0,1,...) */
+int osd_menu(unsigned menu, int sel);
+
+/* filter the main exit request */
+int osd_input_exit_filter(int result);
+
+/* filter the input port state */
+int osd_input_port_filter(int result, unsigned type, unsigned player, int seqtype);
+
+/* snapshot saving */
+void osd_save_snapshot(void);
+
+/* start and stop the video/sound recording. */
+void osd_record_start(void);
+void osd_record_stop(void);
+
+void osd_ui_menu(const ui_menu_item *items, int numitems, int selected);
+void osd_ui_message(const char* text, int second);
+void osd_ui_osd(const char *text, int percentage, int default_percentage);
+void osd_ui_scroll(const char* text, int* pos);
+
+/* customize the inputport */
+void osd_config_load_default(input_port_default_entry* backup, input_port_default_entry* list);
+void osd_config_load(input_port_entry* backup, input_port_entry* list);
+void osd_config_save_default(input_port_default_entry* backup, input_port_default_entry* list);
+void osd_config_save(input_port_entry* backup, input_port_entry* list);
+
+/* handle the specific user interface */
+int osd_handle_user_interface(mame_bitmap *bitmap, int is_menu_active);
+
 #endif	/* __OSDEPEND_H__ */
diff -U 5 --new-file --recursive src.ori/rules.mak src/rules.mak
--- src.ori/rules.mak	2005-08-29 21:46:22.000000000 +0200
+++ src/rules.mak	2005-10-15 08:49:57.000000000 +0200
@@ -1179,16 +1179,16 @@
 CPUOBJS += $(OBJ)/$(G6D)/g65816o1.o
 CPUOBJS += $(OBJ)/$(G6D)/g65816o2.o
 CPUOBJS += $(OBJ)/$(G6D)/g65816o3.o
 CPUOBJS += $(OBJ)/$(G6D)/g65816o4.o
 DBGOBJS += $(OBJ)/$(G6D)/g65816ds.o
-$(OBJ)/$(G6D)/g65816.o: $(G6D)/g65816.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
-$(OBJ)/$(G6D)/g65816o0.o: $(G6D)/g65816o0.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
-$(OBJ)/$(G6D)/g65816o1.o: $(G6D)/g65816o0.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
-$(OBJ)/$(G6D)/g65816o2.o: $(G6D)/g65816o0.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
-$(OBJ)/$(G6D)/g65816o3.o: $(G6D)/g65816o0.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
-$(OBJ)/$(G6D)/g65816o4.o: $(G6D)/g65816o0.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
+$(OBJ)/$(G6D)/g65816.o: g65816.c g65816.h g65816cm.h g65816op.h
+$(OBJ)/$(G6D)/g65816o0.o: g65816o0.c g65816.h g65816cm.h g65816op.h
+$(OBJ)/$(G6D)/g65816o1.o: g65816o0.c g65816.h g65816cm.h g65816op.h
+$(OBJ)/$(G6D)/g65816o2.o: g65816o0.c g65816.h g65816cm.h g65816op.h
+$(OBJ)/$(G6D)/g65816o3.o: g65816o0.c g65816.h g65816cm.h g65816op.h
+$(OBJ)/$(G6D)/g65816o4.o: g65816o0.c g65816.h g65816cm.h g65816op.h
 else
 CPUDEFS += -DHAS_G65816=0
 endif
 
 CPU=$(strip $(findstring SPC700@,$(CPUS)))
@@ -1196,11 +1196,11 @@
 SPCD = cpu/spc700
 OBJDIRS += $(OBJ)/$(SPCD)
 CPUDEFS += -DHAS_SPC700=1
 CPUOBJS += $(OBJ)/$(SPCD)/spc700.o
 DBGOBJS += $(OBJ)/$(SPCD)/spc700ds.o
-$(OBJ)/$(SPCD)/spc700/spc700.o: $(SPCD)/spc700.c $(SPCD)/spc700.h
+$(OBJ)/$(SPCD)/spc700.o: spc700.c spc700.h
 else
 CPUDEFS += -DHAS_SPC700=0
 endif
 
 CPU=$(strip $(findstring E116T@,$(CPUS)))
@@ -1546,13 +1546,13 @@
 
 SOUND=$(strip $(findstring DISCRETE@,$(SOUNDS)))
 ifneq ($(SOUND),)
 SOUNDDEFS += -DHAS_DISCRETE=1
 SOUNDOBJS += $(OBJ)/sound/discrete.o
-$(OBJ)/sound/discrete.o: src/sound/discrete.c src/sound/discrete.h \
-		src/sound/disc_dev.c src/sound/disc_flt.c src/sound/disc_inp.c \
-		src/sound/disc_mth.c src/sound/disc_wav.c
+$(OBJ)/sound/discrete.o: discrete.c discrete.h \
+		disc_dev.c disc_flt.c disc_inp.c \
+		disc_mth.c disc_wav.c
 else
 SOUNDDEFS += -DHAS_DISCRETE=0
 endif
 
 SOUND=$(strip $(findstring AY8910@,$(SOUNDS)))
diff -U 5 --new-file --recursive src.ori/ui_text.c src/ui_text.c
--- src.ori/ui_text.c	2005-08-25 08:26:00.000000000 +0200
+++ src/ui_text.c	2005-10-15 08:49:57.000000000 +0200
@@ -83,11 +83,11 @@
 	"Dip Switches",
 	"Analog Controls",
 	"Calibrate Joysticks",
 	"Bookkeeping Info",
 
-	"Input (this " CAPSTARTGAMENOUN")",
+	"Input (this " GAMENOUN")",
 	CAPSTARTGAMENOUN " Information",
 	CAPSTARTGAMENOUN " History",
 	"Reset " CAPSTARTGAMENOUN,
 	"Return to " CAPSTARTGAMENOUN,
 
@@ -192,10 +192,14 @@
 	"One match found - added to list",
 
 	/* refresh rate */
 	"Refresh rate",
 
+	/* AdvanceMAME: Extra user interface commands */
+	"Video",
+	"Audio",
+
 	NULL
 };
 
 
 
diff -U 5 --new-file --recursive src.ori/ui_text.h src/ui_text.h
--- src.ori/ui_text.h	2005-08-25 08:26:00.000000000 +0200
+++ src/ui_text.h	2005-10-15 08:49:57.000000000 +0200
@@ -188,10 +188,14 @@
 	UI_search_one_match_found_added,
 
 	/* refresh rate */
 	UI_refresh_rate,
 
+	/* AdvanceMAME: Extra user interface commands */
+	UI_osd_1,
+	UI_osd_2,
+
 	UI_last_mame_entry
 };
 
 #ifdef MESS
 #include "mui_text.h"
diff -U 5 --new-file --recursive src.ori/usrintrf.c src/usrintrf.c
--- src.ori/usrintrf.c	2005-09-08 08:30:46.000000000 +0200
+++ src/usrintrf.c	2005-10-15 13:23:08.000000000 +0200
@@ -639,13 +639,17 @@
  *
  *************************************/
 
 void ui_draw_text(const char *buf, int x, int y)
 {
+#if 1 /* AdvanceMAME: Use custom ui code */
+	logerror("ERROR:mame:invalid UI call ui_draw_text(%s,%d,%d)\n", buf, x, y);
+#else
 	int ui_width, ui_height;
 	ui_get_bounds(&ui_width, &ui_height);
 	ui_draw_text_full(buf, x, y, ui_width - x, JUSTIFY_LEFT, WRAP_WORD, DRAW_OPAQUE, RGB_WHITE, RGB_BLACK, NULL, NULL);
+#endif
 }
 
 
 
 /*************************************
@@ -654,10 +658,13 @@
  *
  *************************************/
 
 void ui_draw_text_full(const char *s, int x, int y, int wrapwidth, int justify, int wrap, int draw, rgb_t fgcolor, rgb_t bgcolor, int *totalwidth, int *totalheight)
 {
+#if 1 /* AdvanceMAME: Use custom ui code */
+	logerror("ERROR:mame:invalid UI call ui_draw_text_full(%s,%d,%d)\n", s, x, y);
+#else
 	const char *linestart;
 	int cury = y;
 	int maxwidth = 0;
 
 	/* if we don't want wrapping, guarantee a huge wrapwidth */
@@ -791,10 +798,11 @@
 	/* report the width and height of the resulting space */
 	if (totalwidth)
 		*totalwidth = maxwidth;
 	if (totalheight)
 		*totalheight = cury - y;
+#endif
 }
 
 
 
 /*************************************
@@ -803,10 +811,13 @@
  *
  *************************************/
 
 void ui_draw_menu(const ui_menu_item *items, int numitems, int selected)
 {
+#if 1 /* AdvanceMAME: Use custom ui code */
+	osd_ui_menu(items, numitems, selected);
+#else
 	const char *up_arrow = ui_getstring(UI_uparrow);
 	const char *down_arrow = ui_getstring(UI_downarrow);
 	const char *left_arrow = ui_getstring(UI_leftarrow);
 	const char *right_arrow = ui_getstring(UI_rightarrow);
 	const char *left_hilight = ui_getstring(UI_lefthilight);
@@ -975,10 +986,11 @@
 						target_x + target_width - 1 + UI_BOX_LR_BORDER,
 						target_y + target_height - 1 + UI_BOX_TB_BORDER);
 		ui_draw_text_full(item->subtext, target_x, target_y, target_width,
 					JUSTIFY_RIGHT, WRAP_WORD, DRAW_NORMAL, RGB_WHITE, RGB_BLACK, NULL, NULL);
 	}
+#endif
 }
 
 
 
 /*************************************
@@ -1074,10 +1086,13 @@
  *
  *************************************/
 
 static void draw_multiline_text_box(const char *text, int justify, float xpos, float ypos)
 {
+#if 1 /* AdvanceMAME: Use custom ui code */
+	logerror("ERROR:mame:invalid UI call ui_draw_multiline_text_box(%s)\n", text);
+#else
 	int target_width, target_height;
 	int ui_width, ui_height;
 	int target_x, target_y;
 
 	/* start with the bounds */
@@ -1108,16 +1123,21 @@
 					target_y - UI_BOX_TB_BORDER,
 					target_x + target_width - 1 + UI_BOX_LR_BORDER,
 					target_y + target_height - 1 + UI_BOX_TB_BORDER);
 	ui_draw_text_full(text, target_x, target_y, target_width,
 				justify, WRAP_WORD, DRAW_NORMAL, RGB_WHITE, RGB_BLACK, NULL, NULL);
+#endif
 }
 
 
 void ui_draw_message_window(const char *text)
 {
+#if 1 /* AdvanceMAME: Use custom ui code */
+	osd_ui_scroll(text, 0);
+#else
 	draw_multiline_text_box(text, JUSTIFY_LEFT, 0.5, 0.5);
+#endif
 }
 
 
 
 /*************************************
@@ -1202,10 +1222,14 @@
  *
  *************************************/
 
 static int handle_keys(mame_bitmap *bitmap)
 {
+	/* AdvanceMAME: Intercept user interface handling */
+	if (osd_handle_user_interface(bitmap, menu_handler != NULL) != 0)
+		return 1;
+
 	/* if the user pressed ESC, stop the emulation as long as menus aren't up */
 	if (menu_handler == NULL && input_ui_pressed(IPT_UI_CANCEL))
 		return 1;
 
 	/* if menus aren't up and the user has toggled them, turn them on */
@@ -1268,21 +1292,25 @@
 		}
 		else
 			mame_pause(!mame_is_paused());
 	}
 
+#if 0 /* AdvanceMAME has its record code */
 	/* toggle movie recording */
 	if (input_ui_pressed(IPT_UI_RECORD_MOVIE))
 		record_movie_toggle();
+#endif
 
 	/* toggle profiler display */
 	if (input_ui_pressed(IPT_UI_SHOW_PROFILER))
 		ui_set_show_profiler(!ui_get_show_profiler());
 
+#if 0 /* AdvanceMAME: The show_fps action is managed by the osd code */
 	/* toggle FPS display */
 	if (input_ui_pressed(IPT_UI_SHOW_FPS))
 		ui_set_show_fps(!ui_get_show_fps());
+#endif
 
 	/* toggle crosshair display */
 	if (input_ui_pressed(IPT_UI_TOGGLE_CROSSHAIR))
 		drawgfx_toggle_crosshair();
 
@@ -1295,10 +1323,27 @@
  *
  *  Main menu
  *
  *************************************/
 
+static UINT32 menu_osd_1(UINT32 state)
+{
+	int result = osd_menu(0, state);
+	if (result == 0)
+		return ui_menu_stack_pop();
+	return result;
+
+}
+
+static UINT32 menu_osd_2(UINT32 state)
+{
+	int result = osd_menu(1, state);
+	if (result == 0)
+		return ui_menu_stack_pop();
+	return result;
+}
+
 static UINT32 menu_main(UINT32 state)
 {
 #define ADD_MENU(name, handler, param) \
 do { \
 	item_list[menu_items].text = ui_getstring(name); \
@@ -1388,10 +1433,14 @@
 
 	/* add memory card menu */
 	if (memcard_intf.create != NULL && memcard_intf.load != NULL && memcard_intf.save != NULL && memcard_intf.eject != NULL)
 		ADD_MENU(UI_memorycard, menu_memory_card, 0);
 
+	/* AdvanceMAME: Extra menu UI_OSD */
+	ADD_MENU(UI_osd_1, menu_osd_1, 0);
+	ADD_MENU(UI_osd_2, menu_osd_2, 0);
+
 	/* add reset and exit menus */
 	ADD_MENU(UI_resetgame, menu_reset_game, 0);
 	ADD_MENU(UI_returntogame, NULL, 0);
 
 	/* draw the menu */
@@ -1549,10 +1598,11 @@
 			}
 
 			/* if we are analog, add three items */
 			else
 			{
+#if 0 /* AdvanceMAME: The analog configuration is done at OSD level */
 				if (menu_items == selected)
 				{
 					selected_seq = &in->defaultseq;
 					selected_defseq = &indef->defaultseq;
 					selected_is_analog = TRUE;
@@ -1570,10 +1620,11 @@
 				{
 					selected_seq = &in->defaultincseq;
 					selected_defseq = &indef->defaultincseq;
 				}
 				default_input_menu_add_item(&item_list[menu_items++], "%s Inc", in->name, &in->defaultincseq, &indef->defaultincseq);
+#endif
 			}
 		}
 
 	/* if we're polling, just put an empty entry and arrows for the subitem */
 	if (polling)
@@ -3135,13 +3186,15 @@
 		{
 			int ui_width, ui_height;
 
 			erase_screen(bitmap);
 
+#if 0 /* AdvanceMAME: Use custom ui code */
 			ui_get_bounds(&ui_width, &ui_height);
 			add_filled_box(0, 0, ui_width - 1, ui_height - 1);
 			ui_draw_message_window(buf);
+#endif
 			render_ui(bitmap);
 
 			update_video_and_audio();
 			if (input_ui_pressed(IPT_UI_CANCEL))
 				return 1;
@@ -3169,13 +3222,15 @@
 
 	while (code_read_async() == CODE_NONE)
 	{
 		char *bufptr = buf;
 
+#if 0 /* AdvanceMAME: Use custom ui code */
 		/* first draw a box around the whole screen */
 		ui_get_bounds(&ui_width, &ui_height);
 		add_filled_box(0, 0, ui_width - 1, ui_height - 1);
+#endif
 
 		/* add the game info */
 		bufptr += sprintf_game_info(bufptr);
 
 		/* append MAME version and ask for any key */
@@ -3199,13 +3254,15 @@
 
 	while (code_read_async() == CODE_NONE)
 	{
 		char *bufptr = buf;
 
+#if 0 /* AdvanceMAME: Use custom ui code */
 		/* first draw a box around the whole screen */
 		ui_get_bounds(&ui_width, &ui_height);
 		add_filled_box(0, 0, ui_width - 1, ui_height - 1);
+#endif
 
 		/* add the game info */
 		bufptr += ui_sprintf_image_info(bufptr);
 
 		/* draw the window */
@@ -3238,10 +3295,11 @@
 
 /*-------------------------------------------------
     drawbar - draw a thermometer bar
 -------------------------------------------------*/
 
+#if 0 /* AdvanceMAME: Use custom ui code */
 static void drawbar(int leftx, int topy, int width, int height, int percentage, int default_percentage)
 {
 	int current_x, default_x;
 	int bar_top, bar_bottom;
 
@@ -3260,15 +3318,19 @@
 	add_line(default_x, bar_bottom, default_x, topy + height - 1, RGB_WHITE);
 
 	/* fill in the percentage */
 	add_fill(leftx, bar_top + 1, current_x, bar_bottom - 1, RGB_WHITE);
 }
+#endif
 
 
 
 static void displayosd(const char *text,int percentage,int default_percentage)
 {
+#if 1 /* AdvanceMAME: Use custom ui code */
+	osd_ui_osd(text, percentage, default_percentage);
+#else
 	int space_width = ui_get_char_width(' ');
 	int line_height = ui_get_line_height();
 	int ui_width, ui_height;
 	int text_height;
 
@@ -3294,10 +3356,11 @@
 			ui_width - 2 * space_width, line_height*3/4, percentage, default_percentage);
 
 	/* draw the actual text */
 	ui_draw_text_full(text, space_width + UI_BOX_LR_BORDER, line_height + ui_height - UI_BOX_TB_BORDER - text_height, ui_width - 2 * UI_BOX_LR_BORDER,
 				JUSTIFY_CENTER, WRAP_WORD, DRAW_NORMAL, RGB_WHITE, RGB_BLACK, NULL, &text_height);
+#endif
 }
 
 static void onscrd_adjuster(int increment,int arg)
 {
 	input_port_entry *in = &Machine->input_ports[arg];
@@ -3327,17 +3390,17 @@
 	if (increment)
 	{
 		attenuation = osd_get_mastervolume();
 		attenuation += increment;
 		if (attenuation > 0) attenuation = 0;
-		if (attenuation < -32) attenuation = -32;
+		if (attenuation < -40) attenuation = -40;
 		osd_set_mastervolume(attenuation);
 	}
 	attenuation = osd_get_mastervolume();
 
 	sprintf(buf,"%s %3ddB", ui_getstring (UI_volume), attenuation);
-	displayosd(buf,100 * (attenuation + 32) / 32,100);
+	displayosd(buf,100 * (attenuation + 40) / 40,100);
 }
 
 static void onscrd_mixervol(int increment,int arg)
 {
 	static void *driver = 0;
@@ -3742,10 +3805,11 @@
 }
 
 
 void ui_display_fps(void)
 {
+#if 0 /* AdvanceMAME: Use custom ui code */
 	int ui_width, ui_height;
 
 	/* if we're not currently displaying, skip it */
 	if (!showfps && !showfpstemp)
 		return;
@@ -3761,30 +3825,36 @@
 	{
 		showfpstemp--;
 		if (!showfps && showfpstemp == 0)
 			schedule_full_refresh();
 	}
+#endif
 }
 
 static void ui_display_profiler(void)
 {
+#if 0 /* AdvanceMAME: Use custom ui code */
 	int ui_width, ui_height;
 
 	if (show_profiler)
 	{
 		ui_get_bounds(&ui_width, &ui_height);
 		ui_draw_text_full(profiler_get_text(), 0, 0, ui_width, JUSTIFY_LEFT, WRAP_WORD, DRAW_OPAQUE, RGB_WHITE, RGB_BLACK, NULL, NULL);
 	}
+#endif
 }
 
 static void ui_display_popup(void)
 {
 	/* show popup message if any */
 	if (popup_text_counter > 0)
 	{
+#if 1 /* AdvanceMAME: Use custom ui code */
+		osd_ui_scroll(popup_text, 0);
+#else
 		draw_multiline_text_box(popup_text, JUSTIFY_CENTER, 0.5, 0.9);
-
+#endif
 		if (--popup_text_counter == 0)
 			schedule_full_refresh();
 	}
 }
 
@@ -3861,10 +3931,11 @@
 		rect->max_y = temp;
 	}
 }
 
 
+#if 0 /* AdvanceMAME: Use custom ui code */
 static void add_line(int x1, int y1, int x2, int y2, rgb_t color)
 {
 	if (elemindex < ARRAY_LENGTH(elemlist))
 	{
 		elemlist[elemindex].x = (x1 < x2) ? x1 : x2;
@@ -3904,14 +3975,20 @@
 	add_line(x1, y1, x2, y1, RGB_WHITE);
 	add_line(x2, y1, x2, y2, RGB_WHITE);
 	add_line(x2, y2, x1, y2, RGB_WHITE);
 	add_line(x1, y2, x1, y1, RGB_WHITE);
 }
+#endif
 
 
 static void render_ui(mame_bitmap *dest)
 {
+/* AdvanceMAME: Custom ui */
+	if (elemindex != 0) {
+		logerror("Invalid UI access, %d", elemindex);
+	}
+#if 0
 	int i;
 
 	uirotfont->colortable[0] = get_black_pen();
 	uirotfont->colortable[1] = get_white_pen();
 	uirotfont->colortable[2] = get_white_pen();
@@ -3947,6 +4024,7 @@
 				break;
 		}
 	}
 
 	elemindex = 0;
+#endif
 }
diff -U 5 --new-file --recursive src.ori/usrintrf.h src/usrintrf.h
--- src.ori/usrintrf.h	2005-08-29 21:46:22.000000000 +0200
+++ src/usrintrf.h	2005-10-15 08:49:57.000000000 +0200
@@ -63,19 +63,10 @@
  *
  *************************************/
 
 typedef UINT32 (*ui_menu_handler)(UINT32 state);
 
-struct _ui_menu_item
-{
-   const char *text;
-   const char *subtext;
-   UINT32 flags;
-};
-typedef struct _ui_menu_item ui_menu_item;
-
-
 struct _memcard_interface
 {
 	int (*create)(int);
 	int (*load)(int);
 	void (*save)(void);
diff -U 5 --new-file --recursive src.ori/vidhrdw/voodoo.c src/vidhrdw/voodoo.c
--- src.ori/vidhrdw/voodoo.c	2005-08-29 09:13:22.000000000 +0200
+++ src/vidhrdw/voodoo.c	2005-10-15 08:49:57.000000000 +0200
@@ -16,11 +16,11 @@
  *
  *  Math trickery
  *
  *************************************/
 
-#ifndef _WIN32
+#if 1 /* AdvanceMAME: Use always the portable implementation */
 #define SETUP_FPU()
 #define RESTORE_FPU()
 #define TRUNC_TO_INT(f) (float) (floor(f))
 #else
 #include <float.h>
diff -U 5 --new-file --recursive src.ori/x86drc.c src/x86drc.c
--- src.ori/x86drc.c	2005-08-25 08:26:00.000000000 +0200
+++ src/x86drc.c	2005-10-15 08:49:57.000000000 +0200
@@ -677,10 +677,11 @@
 
 
 /*------------------------------------------------------------------
     drc_x86_get_features()
 ------------------------------------------------------------------*/
+#if 0
 UINT32 drc_x86_get_features(void)
 {
 	UINT32 features = 0;
 #ifdef _MSC_VER
 	__asm
@@ -706,10 +707,11 @@
 	: "%ebx", "%ecx", "%edx"	/* clobbers ebx, ecx and edx */
 	);
 #endif /* MSC_VER */
 	return features;
 }
+#endif
 
 
 
 /*------------------------------------------------------------------
     log_dispatch
