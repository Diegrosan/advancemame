diff -U 5 --new-file --recursive src.ori/advance.pat src/advance.pat
--- src.ori/advance.pat	1970-01-01 01:00:00.000000000 +0100
+++ src/advance.pat	2005-03-28 18:29:49.000000000 +0200
@@ -0,0 +1 @@
+These files are patched for the use with the Advance emulator.
diff -U 5 --new-file --recursive src.ori/common.c src/common.c
--- src.ori/common.c	2005-03-27 15:42:10.000000000 +0200
+++ src/common.c	2005-03-28 18:29:50.000000000 +0200
@@ -593,10 +593,11 @@
 	the given filename
 -------------------------------------------------*/
 
 void save_screen_snapshot_as(mame_file *fp, struct mame_bitmap *bitmap)
 {
+#if 0 /* AdvanceMAME has its snapshot code */
 	struct rectangle bounds;
 	struct mame_bitmap *osdcopy;
 	UINT32 saved_rgb_components[3];
 
 	/* allow the artwork system to override certain parameters */
@@ -691,20 +692,24 @@
 	memcpy(direct_rgb_components, saved_rgb_components, sizeof(saved_rgb_components));
 
 	/* if the OSD system allocated a bitmap; free it */
 	if (osdcopy)
 		bitmap_free(osdcopy);
+#endif
 }
 
 
 
 /*-------------------------------------------------
 	save_screen_snapshot - save a screen snapshot
 -------------------------------------------------*/
 
 void save_screen_snapshot(struct mame_bitmap *bitmap)
 {
+#if 1 /* AdvanceMAME has its snapshot code */
+	osd_save_snapshot();
+#else
 	char name[20];
 	mame_file *fp;
 
 	/* avoid overwriting existing files */
 	/* first of all try with "gamename.png" */
@@ -721,10 +726,11 @@
 	if ((fp = mame_fopen(Machine->gamedrv->name, name, FILETYPE_SCREENSHOT, 1)) != NULL)
 	{
 		save_screen_snapshot_as(fp, bitmap);
 		mame_fclose(fp);
 	}
+#endif
 }
 
 
 
 /***************************************************************************
@@ -1079,11 +1085,11 @@
 		}
 		else
 			strcat(romdata->errorbuf, "WARNING: the game might not run correctly.\n");
 
 		/* display the result */
-		printf("%s", romdata->errorbuf);
+		osd_display_loading_rom_message(romdata->errorbuf, 0);
 
 		/* if we're not getting out of here, wait for a keypress */
 		if (!options.gui_host && !options.skip_warnings && !bailing)
 		{
 			int k;
diff -U 5 --new-file --recursive src.ori/cpuexec.c src/cpuexec.c
--- src.ori/cpuexec.c	2005-03-27 15:42:36.000000000 +0200
+++ src/cpuexec.c	2005-03-28 18:29:50.000000000 +0200
@@ -323,10 +323,13 @@
 	watchdog_setup();
 
 	/* reset sound chips */
 	sound_reset();
 
+	/* reset the osd level */
+	osd_reset();
+
 	/* first pass over CPUs */
 	for (cpunum = 0; cpunum < cpu_gettotalcpu(); cpunum++)
 	{
 		/* enable all CPUs (except for disabled CPUs) */
 		if (!(Machine->drv->cpu[cpunum].cpu_flags & CPU_DISABLE))
diff -U 5 --new-file --recursive src.ori/drivers/multi32.c src/drivers/multi32.c
--- src.ori/drivers/multi32.c	2005-02-22 22:12:50.000000000 +0100
+++ src/drivers/multi32.c	2005-03-28 18:29:50.000000000 +0200
@@ -819,11 +819,11 @@
 	MDRV_NVRAM_HANDLER(system32)
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES(VIDEO_TYPE_RASTER | VIDEO_NEEDS_6BITS_PER_GUN | VIDEO_UPDATE_AFTER_VBLANK | VIDEO_RGB_DIRECT | VIDEO_HAS_SHADOWS ) // RGB_DIRECT will be needed for alpha
 	MDRV_SCREEN_SIZE(52*8*2, 28*8*2)
-	MDRV_VISIBLE_AREA(0*8, 52*8*2-1, 0*8, 28*8*2-1)
+	MDRV_VISIBLE_AREA(0, 320-1, 0, 224-1)
 
 	MDRV_GFXDECODE(gfxdecodeinfo)
 	MDRV_PALETTE_LENGTH(32768)
 
 	MDRV_VIDEO_START(system32)
diff -U 5 --new-file --recursive src.ori/drivers/namcos11.c src/drivers/namcos11.c
--- src.ori/drivers/namcos11.c	2005-03-27 15:42:16.000000000 +0200
+++ src/drivers/namcos11.c	2005-03-28 18:29:50.000000000 +0200
@@ -827,11 +827,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 8, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type1 )
 	MDRV_VIDEO_UPDATE( psx )
diff -U 5 --new-file --recursive src.ori/drivers/namcos12.c src/drivers/namcos12.c
--- src.ori/drivers/namcos12.c	2005-03-27 15:42:16.000000000 +0200
+++ src/drivers/namcos12.c	2005-03-28 18:29:50.000000000 +0200
@@ -1082,11 +1082,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 480-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
diff -U 5 --new-file --recursive src.ori/drivers/psikyo4.c src/drivers/psikyo4.c
--- src.ori/drivers/psikyo4.c	2005-02-24 19:49:06.000000000 +0100
+++ src/drivers/psikyo4.c	2005-03-28 18:29:50.000000000 +0200
@@ -410,13 +410,13 @@
 	MDRV_NVRAM_HANDLER(93C56)
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES(VIDEO_TYPE_RASTER | VIDEO_NEEDS_6BITS_PER_GUN | VIDEO_DUAL_MONITOR)
 #if DUAL_SCREEN
-	MDRV_ASPECT_RATIO(8,3)
+	MDRV_ASPECT_RATIO(4,3)
 	MDRV_SCREEN_SIZE(80*8, 32*8)
-	MDRV_VISIBLE_AREA(0, 80*8-1, 0, 28*8-1)
+	MDRV_VISIBLE_AREA(0, 320-1, 0, 28*8-1)
 #else
 	MDRV_ASPECT_RATIO(4,3)
 	MDRV_SCREEN_SIZE(64*8, 32*8)
 	MDRV_VISIBLE_AREA(0, 40*8-1, 0, 28*8-1)
 #endif
@@ -439,11 +439,11 @@
 static MACHINE_DRIVER_START( ps4small )
 	/* basic machine hardware */
 	MDRV_IMPORT_FROM(ps4big)
 
 #if DUAL_SCREEN
-	MDRV_VISIBLE_AREA(0, 80*8-1, 0, 30*8-1)
+	MDRV_VISIBLE_AREA(0, 320-1, 0, 30*8-1)
 #else
 	MDRV_VISIBLE_AREA(0, 40*8-1, 0, 30*8-1)
 #endif
 MACHINE_DRIVER_END
 
diff -U 5 --new-file --recursive src.ori/drivers/srmp6.c src/drivers/srmp6.c
--- src.ori/drivers/srmp6.c	2005-03-27 15:42:20.000000000 +0200
+++ src/drivers/srmp6.c	2005-04-03 15:45:32.000000000 +0200
@@ -131,18 +131,20 @@
 	fillbitmap(bitmap, get_black_pen(), cliprect);
 
 	// parse sprite list
 	while( source<finish )
 	{
+		int num, xpos, ypos, color, flipx, flipy;
+
 		if (source[0]&0x8000) break;	// end of list
 
-		int num  = source[1];
-		int xpos = source[2];
-		int ypos = source[3];
-		int color = 0;
-		int flipx = 0;
-		int flipy = 0;
+		num  = source[1];
+		xpos = source[2];
+		ypos = source[3];
+		color = 0;
+		flipx = 0;
+		flipy = 0;
 
 		drawgfx(
 				bitmap,
 				gfx,
 				num,
diff -U 5 --new-file --recursive src.ori/drivers/stv.c src/drivers/stv.c
--- src.ori/drivers/stv.c	2005-03-27 15:42:36.000000000 +0200
+++ src/drivers/stv.c	2005-03-28 18:29:50.000000000 +0200
@@ -4205,11 +4205,11 @@
 	MDRV_NVRAM_HANDLER(stv) /* Actually 93c45 */
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES(VIDEO_TYPE_RASTER | VIDEO_UPDATE_AFTER_VBLANK | VIDEO_RGB_DIRECT )
 	MDRV_SCREEN_SIZE(1024, 1024)
-	MDRV_VISIBLE_AREA(0*8, 703, 0*8, 512) // we need to use a resolution as high as the max size it can change to
+	MDRV_VISIBLE_AREA(0*8, 320-1, 0*8, 224-1)
 	MDRV_PALETTE_LENGTH(2048+(2048*2))//standard palette + extra memory for rgb brightness.
 	MDRV_GFXDECODE(gfxdecodeinfo)
 
 	MDRV_VIDEO_START(stv_vdp2)
 	MDRV_VIDEO_UPDATE(stv_vdp2)
diff -U 5 --new-file --recursive src.ori/drivers/tx1.c src/drivers/tx1.c
--- src.ori/drivers/tx1.c	2005-03-27 15:42:12.000000000 +0200
+++ src/drivers/tx1.c	2005-04-03 15:59:54.000000000 +0200
@@ -870,14 +870,17 @@
 }
 
 
 static MACHINE_INIT( tx1 )
 {
+       data8_t *rom;
+       data8_t *rom_b;
+
        ppi8255_init(&tx1_ppi8255_intf);
 
-       data8_t *rom = (data8_t *)memory_region(REGION_CPU1);
-       data8_t *rom_b = (data8_t *)memory_region(REGION_CPU2);
+       rom = (data8_t *)memory_region(REGION_CPU1);
+       rom_b = (data8_t *)memory_region(REGION_CPU2);
 
        /* Needed to skip the startup tests */
 
        rom_b[0xfcf38]=0x3B;      /* Patch out AU check */
        rom_b[0xfcf39]=0xc0;
diff -U 5 --new-file --recursive src.ori/drivers/zn.c src/drivers/zn.c
--- src.ori/drivers/zn.c	2005-03-27 15:42:10.000000000 +0200
+++ src/drivers/zn.c	2005-03-28 18:29:50.000000000 +0200
@@ -651,11 +651,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 512 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -694,11 +694,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -903,11 +903,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -1335,11 +1335,11 @@
 	MDRV_NVRAM_HANDLER( coh1000ta )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 512 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -1438,11 +1438,11 @@
 	MDRV_NVRAM_HANDLER( coh1000tb )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -1628,11 +1628,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -1842,11 +1842,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -2088,11 +2088,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 320-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -2429,11 +2429,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -2600,11 +2600,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 320-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -2685,11 +2685,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 320-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -2953,11 +2953,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 512-1, 0, 480-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -2990,11 +2990,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 320-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
@@ -3030,11 +3030,11 @@
 	MDRV_NVRAM_HANDLER( at28c16_0 )
 
 	/* video hardware */
 	MDRV_VIDEO_ATTRIBUTES( VIDEO_TYPE_RASTER )
 	MDRV_SCREEN_SIZE( 1024, 1024 )
-	MDRV_VISIBLE_AREA( 0, 639, 0, 479 )
+	MDRV_VISIBLE_AREA( 0, 320-1, 0, 240-1 )
 	MDRV_PALETTE_LENGTH( 65536 )
 
 	MDRV_PALETTE_INIT( psx )
 	MDRV_VIDEO_START( psx_type2 )
 	MDRV_VIDEO_UPDATE( psx )
diff -U 5 --new-file --recursive src.ori/inptport.c src/inptport.c
--- src.ori/inptport.c	2005-03-27 15:42:14.000000000 +0200
+++ src/inptport.c	2005-03-28 18:29:51.000000000 +0200
@@ -928,26 +928,21 @@
 
 	/* start with the raw defaults and ask the OSD to customize them in the backup array */
 	memcpy(inputport_list_backup, inputport_list_defaults, sizeof(inputport_list_backup));
 	osd_customize_inputport_list(inputport_list_backup);
 
-	/* load the controller-specific info -- note that even though we are still modifying */
-	/* the inputport_list_backup, token_to_port_type relies on inputport_list being valid */
-	memcpy(inputport_list, inputport_list_backup, sizeof(inputport_list));
-	if (options.controller != NULL)
-	{
-		loaded = config_load_controller(options.controller, inputport_list_backup);
-		if (!loaded)
-			osd_die("Could not load controller file %s.cfg\n", options.controller);
-	}
-
 	/* propogate that forward to the live list and apply the config on top of that */
 	memcpy(inputport_list, inputport_list_backup, sizeof(inputport_list));
-	config_load_default(inputport_list_backup, inputport_list);
 
-	/* now load the game-specific info */
-	loaded = config_load(Machine->input_ports_default, Machine->input_ports);
+	/* AdvanceMAME: Load user defined customization */
+	osd_config_load_default(inputport_list_backup, inputport_list);
+
+	/* AdvanceMAME: Load user defined customization */
+	osd_config_load(Machine->input_ports_default, Machine->input_ports);
+
+	/* AdvanceMAME: Report no setting loaded, always show the disclaimer */
+	loaded = 0;
 
 	/* initialize the various port states */
 	inputport_init();
 
 	/* if we didn't find a saved config, return 0 so the main core knows that it */
@@ -957,12 +952,16 @@
 
 
 void save_input_port_settings(void)
 {
 	/* save the default config and the game-specific config */
-	config_save_default(inputport_list_backup, inputport_list);
-	config_save(Machine->input_ports_default, Machine->input_ports);
+
+	/* AdvanceMAME: Save user defined customization */
+	osd_config_save_default(inputport_list_backup, inputport_list);
+
+	/* AdvanceMAME: Save user defined customization */
+	osd_config_save(Machine->input_ports_default, Machine->input_ports);
 }
 
 
 
 /*************************************
@@ -1488,12 +1487,18 @@
 {
 	int listnum;
 
 	/* search the defaults for the type */
 	for (listnum = 0; inputport_list[listnum].type != IPT_END; listnum++)
-		if (inputport_list[listnum].type == type && inputport_list[listnum].player == player)
-			return seq_pressed(&inputport_list[listnum].defaultseq);
+		if (inputport_list[listnum].type == type && inputport_list[listnum].player == player) {
+			int pressed = seq_pressed(&inputport_list[listnum].defaultseq);
+
+			/* AdvanceMAME: Filter all the input ports */
+			pressed = osd_input_port_filter(pressed, inputport_list[listnum].type, inputport_list[listnum].player, SEQ_TYPE_STANDARD);
+
+			return pressed;
+		}
 
 	return 0;
 }
 
 
@@ -1504,10 +1509,13 @@
 profiler_mark(PROFILER_INPUT);
 
 	/* get the status of this key (assumed to be only in the defaults) */
 	pressed = seq_pressed(input_port_default_seq(code, 0, SEQ_TYPE_STANDARD));
 
+	/* AdvanceMAME: Filter all the input ports */
+	pressed = osd_input_port_filter(pressed, code, 0, SEQ_TYPE_STANDARD);
+
 	/* if pressed, handle it specially */
 	if (pressed)
 	{
 		/* if this is the first press, leave pressed = 1 */
 		if (ui_memory[code] == 0)
@@ -1537,10 +1545,13 @@
 profiler_mark(PROFILER_INPUT);
 
 	/* get the status of this key (assumed to be only in the defaults) */
 	pressed = seq_pressed(input_port_default_seq(code, 0, SEQ_TYPE_STANDARD));
 
+	/* AdvanceMAME: Filter all the input ports */
+	pressed = osd_input_port_filter(pressed, code, 0, SEQ_TYPE_STANDARD);
+
 	/* if so, handle it specially */
 	if (pressed)
 	{
 		/* if this is the first press, set a 3x delay and leave pressed = 1 */
 		if (ui_memory[code] == 0)
@@ -1609,10 +1620,13 @@
 void inputport_vblank_start(void)
 {
 	int ui_visible = setup_active() || onscrd_active();
 	int portnum, bitnum;
 
+	/* AdvanceMAME: Never disable the input port. */
+	ui_visible = 0;
+
 profiler_mark(PROFILER_INPUT);
 
 	/* update the digital joysticks first */
 	update_digital_joysticks();
 
@@ -1643,11 +1657,16 @@
 
 			/* handle non-analog types, but only when the UI isn't visible */
 			else if (!IS_ANALOG(port) && !ui_visible)
 			{
 				/* if the sequence for this port is currently pressed.... */
-				if (seq_pressed(input_port_seq(port, SEQ_TYPE_STANDARD)))
+				int pressed = seq_pressed(input_port_seq(port, SEQ_TYPE_STANDARD));
+
+				/* AdvanceMAME: Filter all the input ports */
+				pressed = osd_input_port_filter(pressed, port->type, port->player, SEQ_TYPE_STANDARD);
+
+				if (pressed)
 				{
 #ifdef MESS
 					/* (MESS-specific) check for disabled keyboard */
 					if (port->type == IPT_KEYBOARD && osd_keyboard_disabled())
 						continue;
@@ -1775,17 +1794,18 @@
 			{
 				info->previous = info->current;
 				info->current = 0;
 
 				/* read all the associated ports */
-				if (info->port[JOYDIR_UP] != NULL && seq_pressed(input_port_seq(info->port[JOYDIR_UP], SEQ_TYPE_STANDARD)))
+				/* AdvanceMAME: Filter all the input ports */
+				if (info->port[JOYDIR_UP] != NULL && osd_input_port_filter(seq_pressed(input_port_seq(info->port[JOYDIR_UP], SEQ_TYPE_STANDARD)), info->port[JOYDIR_UP]->type, info->port[JOYDIR_UP]->player, SEQ_TYPE_STANDARD))
 					info->current |= JOYDIR_UP_BIT;
-				if (info->port[JOYDIR_DOWN] != NULL && seq_pressed(input_port_seq(info->port[JOYDIR_DOWN], SEQ_TYPE_STANDARD)))
+				if (info->port[JOYDIR_DOWN] != NULL && osd_input_port_filter(seq_pressed(input_port_seq(info->port[JOYDIR_DOWN], SEQ_TYPE_STANDARD)), info->port[JOYDIR_DOWN]->type, info->port[JOYDIR_DOWN]->player, SEQ_TYPE_STANDARD))
 					info->current |= JOYDIR_DOWN_BIT;
-				if (info->port[JOYDIR_LEFT] != NULL && seq_pressed(input_port_seq(info->port[JOYDIR_LEFT], SEQ_TYPE_STANDARD)))
+				if (info->port[JOYDIR_LEFT] != NULL && osd_input_port_filter(seq_pressed(input_port_seq(info->port[JOYDIR_LEFT], SEQ_TYPE_STANDARD)), info->port[JOYDIR_LEFT]->type, info->port[JOYDIR_LEFT]->player, SEQ_TYPE_STANDARD))
 					info->current |= JOYDIR_LEFT_BIT;
-				if (info->port[JOYDIR_RIGHT] != NULL && seq_pressed(input_port_seq(info->port[JOYDIR_RIGHT], SEQ_TYPE_STANDARD)))
+				if (info->port[JOYDIR_RIGHT] != NULL && osd_input_port_filter(seq_pressed(input_port_seq(info->port[JOYDIR_RIGHT], SEQ_TYPE_STANDARD)), info->port[JOYDIR_RIGHT]->type, info->port[JOYDIR_RIGHT]->player, SEQ_TYPE_STANDARD))
 					info->current |= JOYDIR_RIGHT_BIT;
 
 				/* lock out opposing directions (left + right or up + down) */
 				if ((info->current & (JOYDIR_UP_BIT | JOYDIR_DOWN_BIT)) == (JOYDIR_UP_BIT | JOYDIR_DOWN_BIT))
 					info->current &= ~(JOYDIR_UP_BIT | JOYDIR_DOWN_BIT);
@@ -1896,12 +1916,12 @@
 		int analog_type, keypressed = 0;
 
 		/* clamp the previous value to the min/max range and remember it */
 		info->previous = info->accum = apply_analog_min_max(info, info->accum);
 
-		/* get the new raw analog value and its type */
-		rawvalue = seq_analog_value(input_port_seq(port, SEQ_TYPE_STANDARD), &analog_type);
+		/* AdvanceMAME: Get the analog input for different players from the osd core. */
+		rawvalue = osd_get_analog_value(port->type, port->player, &analog_type);
 
 		/* if we got it from a relative device, use that as the starting delta */
 		/* also note that the last input was not a digital one */
 		if (analog_type == ANALOG_TYPE_RELATIVE && rawvalue != 0)
 		{
@@ -1909,18 +1929,20 @@
 			info->lastdigital = 0;
 		}
 
 		/* if the decrement code sequence is pressed, add the key delta to */
 		/* the accumulated delta; also note that the last input was a digital one */
-		if (seq_pressed(input_port_seq(info->port, SEQ_TYPE_DECREMENT)))
+		/* AdvanceMAME: Filter all the input ports */
+		if (osd_input_port_filter(seq_pressed(input_port_seq(info->port, SEQ_TYPE_DECREMENT)), info->port->type, info->port->player, SEQ_TYPE_DECREMENT))
 		{
 			delta -= (INT32)(port->analog.delta * info->keyscale);
 			keypressed = info->lastdigital = 1;
 		}
 
 		/* same for the increment code sequence */
-		if (seq_pressed(input_port_seq(info->port, SEQ_TYPE_INCREMENT)))
+		/* AdvanceMAME: Filter all the input ports */
+		if (osd_input_port_filter(seq_pressed(input_port_seq(info->port, SEQ_TYPE_INCREMENT)), info->port->type, info->port->player, SEQ_TYPE_INCREMENT))
 		{
 			delta += (INT32)(port->analog.delta * info->keyscale);
 			keypressed = info->lastdigital = 1;
 		}
 
@@ -1934,15 +1956,18 @@
 		info->accum += delta;
 
 		/* if we got an absolute input, it overrides everything else */
 		if (analog_type == ANALOG_TYPE_ABSOLUTE)
 		{
-			/* apply the inverse of the sensitivity to the raw value so that */
-			/* it will still cover the full min->max range requested after */
-			/* we apply the sensitivity adjustment */
-			info->accum = APPLY_INVERSE_SENSITIVITY(rawvalue, port->analog.sensitivity);
-			info->lastdigital = 0;
+			/* allow both the analog joystick and the keyboard to control the input port */
+			if (rawvalue != 0 || !info->lastdigital) {
+				/* apply the inverse of the sensitivity to the raw value so that */
+				/* it will still cover the full min->max range requested after */
+				/* we apply the sensitivity adjustment */
+				info->accum = APPLY_INVERSE_SENSITIVITY(rawvalue, port->analog.sensitivity);
+				info->lastdigital = 0;
+			}
 		}
 
 		/* if our last movement was due to a digital input, and if this control */
 		/* type autocenters, and if neither the increment nor the decrement seq */
 		/* was pressed, apply autocentering */
diff -U 5 --new-file --recursive src.ori/input.c src/input.c
--- src.ori/input.c	2004-09-21 20:02:10.000000000 +0200
+++ src/input.c	2005-03-28 18:29:51.000000000 +0200
@@ -603,11 +603,33 @@
 	code_count = 0;
 	free(code_map);
 	code_map = NULL;
 }
 
+os_code_t code_to_oscode(input_code_t code)
+{
+	if (code_map[code].osinfo != NULL)
+		return code_map[code].osinfo->oscode;
+	else
+		return 0;
+}
 
+input_code_t oscode_to_code(os_code_t oscode)
+{
+	unsigned i;
+
+	for(i=0;i<code_count;++i) {
+		if (code_map[i].osinfo != NULL && code_map[i].osinfo->oscode == oscode) {
+			break;
+		}
+	}
+
+	if (i == code_count)
+		return CODE_NONE;
+
+	return i;
+}
 
 /*************************************
  *
  *	Return the analog value of a code.
  *
diff -U 5 --new-file --recursive src.ori/input.h src/input.h
--- src.ori/input.h	2004-09-21 20:02:10.000000000 +0200
+++ src/input.h	2005-03-28 18:29:51.000000000 +0200
@@ -479,10 +479,17 @@
 	CODE_NOT,					/* operators for sequences */
 	CODE_OR						/* operators for sequences */
 };
 
 
+/* AdvanceMAME: Remap the F1 key used by some debug code to an unused key. */
+#ifdef MESS
+#define KEYCODE_F1_REAL KEYCODE_F1
+#else
+#define KEYCODE_F1_REAL (KEYCODE_F2-1)
+#define KEYCODE_F1 KEYCODE_NUMLOCK
+#endif
 
 /*************************************
  *
  *	Type definitions
  *
@@ -530,10 +537,13 @@
 
 /* single code functions */
 int code_init(void);
 void code_close(void);
 
+os_code_t code_to_oscode(input_code_t code);
+input_code_t oscode_to_code(os_code_t oscode);
+
 INT32 code_analog_value(input_code_t code);
 int code_pressed(input_code_t code);
 int code_pressed_memory(input_code_t code);
 int code_pressed_memory_repeat(input_code_t code, int speed);
 input_code_t code_read_async(void);
diff -U 5 --new-file --recursive src.ori/mame.c src/mame.c
--- src.ori/mame.c	2005-03-27 15:42:20.000000000 +0200
+++ src/mame.c	2005-03-28 18:29:51.000000000 +0200
@@ -567,10 +567,15 @@
 		if (options.skip_warnings || showgamewarnings(artwork_get_ui_bitmap()) == 0)
 		{
 			/* show info about the game */
 			if (options.skip_gameinfo || showgameinfo(artwork_get_ui_bitmap()) == 0)
 			{
+				/* AdvanceMAME: Force a video update, otherwise with all the skip options the program crash */
+				fillbitmap(artwork_get_ui_bitmap(), get_black_pen(), NULL);
+				schedule_full_refresh();
+				update_video_and_audio();
+
 				init_user_interface();
 
 				/* enable artwork now */
 				artwork_enable(1);
 
diff -U 5 --new-file --recursive src.ori/mame.mak src/mame.mak
--- src.ori/mame.mak	2005-03-27 15:42:36.000000000 +0200
+++ src/mame.mak	2005-03-28 19:31:40.000000000 +0200
@@ -1269,11 +1269,11 @@
 
 
 COREOBJS += $(OBJ)/driver.o $(OBJ)/cheat.o
 
 # Files shared across several libraries
-OBJS += \
+COREOBJS += \
 	$(OBJ)/machine/segacrpt.o \
 	$(OBJ)/machine/tmp68301.o \
 	$(OBJ)/machine/6532riot.o \
 	$(OBJ)/machine/z80fmly.o \
 	$(OBJ)/machine/6821pia.o \
diff -U 5 --new-file --recursive src.ori/osdepend.h src/osdepend.h
--- src.ori/osdepend.h	2005-01-29 00:22:26.000000000 +0100
+++ src/osdepend.h	2005-03-28 18:29:51.000000000 +0200
@@ -350,10 +350,48 @@
       __attribute__ ((format (printf, 1, 2)));
 #else
 void CLIB_DECL logerror(const char *text,...);
 #endif
 
+/* AdvanceMAME: Specific OSD interface */
+
+/* return the analog value of the specified input. */
+INT32 osd_get_analog_value(unsigned type, unsigned player, int* analog_type);
+
+/* called then the game is reset */
+void osd_reset(void);
+
+/* execute the specified menu (0,1,...) */
+int osd_menu(unsigned menu, struct mame_bitmap *bitmap, int sel);
+
+/* filter the main exit request */
+int osd_input_exit_filter(int result);
+
+/* filter the input port state */
+int osd_input_port_filter(int result, unsigned type, unsigned player, int seqtype);
+
+/* snapshot saving */
+void osd_save_snapshot(void);
+
+/* start and stop the video/sound recording. */
+void osd_record_start(void);
+void osd_record_stop(void);
+
+void osd_ui_menu(const char** items,const char** subitems, char* flag, int selected, int arrowize_subitem);
+void osd_ui_message(const char* text, int second);
+void osd_ui_osd(const char *text, int percentage, int default_percentage);
+void osd_ui_scroll(const char* text, int* pos);
+
+/* customize the inputport */
+void osd_config_load_default(struct InputPortDefinition* backup, struct InputPortDefinition* list);
+void osd_config_load(struct InputPort* backup, struct InputPort* list);
+void osd_config_save_default(struct InputPortDefinition* backup, struct InputPortDefinition* list);
+void osd_config_save(struct InputPort* backup, struct InputPort* list);
+
+/* handle the specific user interface */
+int osd_handle_user_interface(struct mame_bitmap *bitmap, int is_menu_active);
+
 #ifdef __cplusplus
 }
 #endif
 
 #endif
diff -U 5 --new-file --recursive src.ori/rules.mak src/rules.mak
--- src.ori/rules.mak	2005-03-27 15:42:10.000000000 +0200
+++ src/rules.mak	2005-03-28 18:29:51.000000000 +0200
@@ -1166,16 +1166,16 @@
 CPUOBJS += $(OBJ)/$(G6D)/g65816o1.o
 CPUOBJS += $(OBJ)/$(G6D)/g65816o2.o
 CPUOBJS += $(OBJ)/$(G6D)/g65816o3.o
 CPUOBJS += $(OBJ)/$(G6D)/g65816o4.o
 DBGOBJS += $(OBJ)/$(G6D)/g65816ds.o
-$(OBJ)/$(G6D)/g65816.o: $(G6D)/g65816.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
-$(OBJ)/$(G6D)/g65816o0.o: $(G6D)/g65816o0.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
-$(OBJ)/$(G6D)/g65816o1.o: $(G6D)/g65816o0.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
-$(OBJ)/$(G6D)/g65816o2.o: $(G6D)/g65816o0.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
-$(OBJ)/$(G6D)/g65816o3.o: $(G6D)/g65816o0.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
-$(OBJ)/$(G6D)/g65816o4.o: $(G6D)/g65816o0.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
+$(OBJ)/$(G6D)/g65816.o: g65816.c g65816.h g65816cm.h g65816op.h
+$(OBJ)/$(G6D)/g65816o0.o: g65816o0.c g65816.h g65816cm.h g65816op.h
+$(OBJ)/$(G6D)/g65816o1.o: g65816o0.c g65816.h g65816cm.h g65816op.h
+$(OBJ)/$(G6D)/g65816o2.o: g65816o0.c g65816.h g65816cm.h g65816op.h
+$(OBJ)/$(G6D)/g65816o3.o: g65816o0.c g65816.h g65816cm.h g65816op.h
+$(OBJ)/$(G6D)/g65816o4.o: g65816o0.c g65816.h g65816cm.h g65816op.h
 else
 CPUDEFS += -DHAS_G65816=0
 endif
 
 CPU=$(strip $(findstring SPC700@,$(CPUS)))
@@ -1183,11 +1183,11 @@
 SPCD = cpu/spc700
 OBJDIRS += $(OBJ)/$(SPCD)
 CPUDEFS += -DHAS_SPC700=1
 CPUOBJS += $(OBJ)/$(SPCD)/spc700.o
 DBGOBJS += $(OBJ)/$(SPCD)/spc700ds.o
-$(OBJ)/$(SPCD)/spc700/spc700.o: $(SPCD)/spc700.c $(SPCD)/spc700.h
+$(OBJ)/$(SPCD)/spc700.o: spc700.c spc700.h
 else
 CPUDEFS += -DHAS_SPC700=0
 endif
 
 CPU=$(strip $(findstring E116T@,$(CPUS)))
@@ -1508,13 +1508,13 @@
 
 SOUND=$(strip $(findstring DISCRETE@,$(SOUNDS)))
 ifneq ($(SOUND),)
 SOUNDDEFS += -DHAS_DISCRETE=1
 SOUNDOBJS += $(OBJ)/sound/discrete.o
-$(OBJ)/sound/discrete.o: src/sound/discrete.c src/sound/discrete.h \
-		src/sound/disc_dev.c src/sound/disc_flt.c src/sound/disc_inp.c \
-		src/sound/disc_mth.c src/sound/disc_wav.c
+$(OBJ)/sound/discrete.o: discrete.c discrete.h \
+		disc_dev.c disc_flt.c disc_inp.c \
+		disc_mth.c disc_wav.c
 else
 SOUNDDEFS += -DHAS_DISCRETE=0
 endif
 
 SOUND=$(strip $(findstring AY8910@,$(SOUNDS)))
diff -U 5 --new-file --recursive src.ori/ui_text.c src/ui_text.c
--- src.ori/ui_text.c	2004-08-22 21:14:00.000000000 +0200
+++ src/ui_text.c	2005-03-28 18:29:51.000000000 +0200
@@ -191,10 +191,14 @@
 	"One match found - added to list",
 
 	/* refresh rate */
 	"Refresh rate",
 
+	/* AdvanceMAME: Extra user interface commands */
+	"Video",
+	"Audio",
+
 	NULL
 };
 
 
 
diff -U 5 --new-file --recursive src.ori/ui_text.h src/ui_text.h
--- src.ori/ui_text.h	2004-07-28 22:26:24.000000000 +0200
+++ src/ui_text.h	2005-03-28 18:29:51.000000000 +0200
@@ -185,10 +185,14 @@
 	UI_search_one_match_found_added,
 	
 	/* refresh rate */
 	UI_refresh_rate,
 
+	/* AdvanceMAME: Extra user interface commands */
+	UI_osd_1,
+	UI_osd_2,
+
 	UI_last_mame_entry
 };
 
 #ifdef MESS
 #include "mui_text.h"
diff -U 5 --new-file --recursive src.ori/usrintrf.c src/usrintrf.c
--- src.ori/usrintrf.c	2005-03-27 15:42:14.000000000 +0200
+++ src/usrintrf.c	2005-03-28 18:29:51.000000000 +0200
@@ -804,10 +804,13 @@
 
 
 
 void ui_displaymenu(struct mame_bitmap *bitmap,const char **items,const char **subitems,char *flag,int selected,int arrowize_subitem)
 {
+#if 1 /* AdvanceMAME: Use custom ui code */
+	osd_ui_menu(items, subitems, flag, selected, arrowize_subitem);
+#else
 	struct DisplayText dt[256];
 	int curr_dt;
 	const char *lefthilight = ui_getstring (UI_lefthilight);
 	const char *righthilight = ui_getstring (UI_righthilight);
 	const char *uparrow = ui_getstring (UI_uparrow);
@@ -974,15 +977,19 @@
 		if (long_y + long_dy > uirotheight)
 			long_y = topoffs + i * 3*uirotcharheight/2 - long_dy;
 
 		ui_multitextbox_ex(bitmap,subitems[selected],subitems[selected] + strlen(subitems[selected]), long_max, long_x,long_y,long_dx,long_dy, UI_COLOR_NORMAL);
 	}
+#endif
 }
 
 
 void ui_displaymessagewindow(struct mame_bitmap *bitmap,const char *text)
 {
+#if 1 /* AdvanceMAME: Use custom ui code */
+	osd_ui_scroll(text, 0);
+#else
 	struct DisplayText dt[256];
 	int curr_dt;
 	char *c,*c2;
 	int i,len,maxlen,lines;
 	char textcopy[2048];
@@ -1077,10 +1084,11 @@
 	}
 
 	dt[curr_dt].text = 0;	/* terminate array */
 
 	displaytext(bitmap,dt);
+#endif
 }
 
 
 
 static void showcharset(struct mame_bitmap *bitmap)
@@ -1754,15 +1762,17 @@
 					menu_item[total] = in->name;
 					total++;
 				}
 				else
 				{
+#if 0 /* AdvanceMAME: The analog configuration is done at OSD level */
 					entry[total] = &in->defaultseq;
 					defentry[total] = &indef->defaultseq;
 					sprintf(menu_item_buffer[total], "%s Analog", in->name);
 					menu_item[total] = menu_item_buffer[total];
 					total++;
+#endif
 
 					analog[total] = 0;
 					entry[total] = &in->defaultdecseq;
 					defentry[total] = &indef->defaultdecseq;
 					sprintf(menu_item_buffer[total], "%s Dec", in->name);
@@ -1941,16 +1951,18 @@
 				menu_subitem[total] = menu_subitem_buffer[total];
 				total++;
 			}
 			else
 			{
+#if 0 /* AdvanceMAME: The analog configuration is done at OSD level */
 				seq[total] = &in->seq;
 				sprintf(menu_item_buffer[total], "%s Analog", input_port_name(in));
 				menu_item[total] = menu_item_buffer[total];
 				seq_name(input_port_seq(in, SEQ_TYPE_STANDARD), menu_subitem_buffer[total], sizeof(menu_subitem_buffer[0]));
 				menu_subitem[total] = menu_subitem_buffer[total];
 				total++;
+#endif
 
 				analog[total] = 0;
 				seq[total] = &in->analog.decseq;
 				sprintf(menu_item_buffer[total], "%s Dec", input_port_name(in));
 				menu_item[total] = menu_item_buffer[total];
@@ -2803,10 +2815,13 @@
 }
 
 /* Display lines from buffer, starting with line 'scroll', in a width x height text window */
 static void display_scroll_message (struct mame_bitmap *bitmap, int *scroll, int width, int height, char *buf)
 {
+#if 1 /* AdvanceMAME: Use custom ui code */
+	osd_ui_scroll(buf, scroll);
+#else
 	struct DisplayText dt[256];
 	int curr_dt = 0;
 	const char *uparrow = ui_getstring (UI_uparrow);
 	const char *downarrow = ui_getstring (UI_downarrow);
 	char textcopy[2048];
@@ -2909,10 +2924,11 @@
 	}
 
 	dt[curr_dt].text = 0;	/* terminate array */
 
 	displaytext(bitmap,dt);
+#endif
 }
 
 
 /* Display text entry for current driver from history.dat and mameinfo.dat. */
 static int displayhistory (struct mame_bitmap *bitmap, int selected)
@@ -2940,11 +2956,13 @@
 		{
 			/* try to load entry */
 			if (load_driver_history (Machine->gamedrv, buf, bufsize) == 0)
 			{
 				scroll = 0;
+#if 0 /* AdvanceMAME: The text is internally wrapped */
 				wordwrap_text_buffer (buf, maxcols);
+#endif
 				strcat(buf,"\n\t");
 				strcat(buf,ui_getstring (UI_lefthilight));
 				strcat(buf," ");
 				strcat(buf,ui_getstring (UI_returntomain));
 				strcat(buf," ");
@@ -3153,16 +3171,16 @@
 
 
 #ifndef MESS
 enum { UI_SWITCH = 0,UI_DEFGROUP,UI_CODE,UI_ANALOG,UI_CALIBRATE,
 		UI_STATS,UI_GAMEINFO, UI_HISTORY,
-		UI_CHEAT,UI_RESET,UI_MEMCARD,UI_EXIT };
+		UI_CHEAT,UI_RESET,UI_MEMCARD,UI_EXIT,UI_OSD_1,UI_OSD_2 };
 #else
 enum { UI_SWITCH = 0,UI_DEFGROUP,UI_CODE,UI_ANALOG,UI_CALIBRATE,
 		UI_GAMEINFO, UI_IMAGEINFO,UI_FILEMANAGER,UI_TAPECONTROL,
-		UI_HISTORY,UI_CHEAT,UI_RESET,UI_MEMCARD,UI_EXIT,
-		UI_CONFIGURATION, UI_CATEGORIES };
+		UI_HISTORY,UI_CHEAT,UI_RESET,UI_MEMCARD,UI_EXIT,UI_OSD_1,UI_OSD_2,
+		UI_CONFIGURATION, UI_CATEGORIES, };
 #endif
 
 
 #define MAX_SETUPMENU_ITEMS 20
 static const char *menu_item[MAX_SETUPMENU_ITEMS];
@@ -3293,10 +3311,13 @@
 		memcard_intf.eject != NULL)
 	{
 		append_menu(UI_memorycard, UI_MEMCARD);
 	}
 
+	/* AdvanceMAME: Extra menu UI_OSD */
+	append_menu(UI_osd_1, UI_OSD_1);
+	append_menu(UI_osd_2, UI_OSD_2);
 	append_menu(UI_resetgame, UI_RESET);
 	append_menu(UI_returntogame, UI_EXIT);
 	menu_item[menu_total] = 0; /* terminate array */
 }
 
@@ -3364,10 +3385,15 @@
 				res = cheat_menu(bitmap, sel >> SEL_BITS);
 				break;
 			case UI_MEMCARD:
 				res = memcard_menu(bitmap, sel >> SEL_BITS);
 				break;
+			/* AdvanceMAME: Extra menu UI_OSD */
+			case UI_OSD_1 :
+			case UI_OSD_2 :
+				res = osd_menu(menu_action[sel & SEL_MASK] - UI_OSD_1, bitmap, sel >> SEL_BITS);
+				break;
 		}
 
 		if (res == -1)
 		{
 			menu_lastselected = sel;
@@ -3409,10 +3435,13 @@
 			case UI_CATEGORIES:
 #endif /* !MESS */
 			case UI_HISTORY:
 			case UI_CHEAT:
 			case UI_MEMCARD:
+			/* AdvanceMAME: Extra menu UI_OSD */
+			case UI_OSD_1 :
+			case UI_OSD_2 :
 				sel |= 1 << SEL_BITS;
 				schedule_full_refresh();
 				break;
 
 			case UI_RESET:
@@ -3449,10 +3478,13 @@
 
 *********************************************************************/
 
 static void displayosd(struct mame_bitmap *bitmap,const char *text,int percentage,int default_percentage)
 {
+#if 1 /* AdvanceMAME: Use custom ui code */
+	osd_ui_osd(text, percentage, default_percentage);
+#else
 	struct DisplayText dt[2];
 	int avail;
 
 
 	avail = (uirotwidth / uirotcharwidth) * 19 / 20;
@@ -3474,10 +3506,11 @@
 	dt[0].color = UI_COLOR_NORMAL;
 	dt[0].x = (uirotwidth - uirotcharwidth * strlen(text)) / 2;
 	dt[0].y = (uirotheight - 2*uirotcharheight) + 2;
 	dt[1].text = 0; /* terminate array */
 	displaytext(bitmap,dt);
+#endif
 }
 
 static void onscrd_adjuster(struct mame_bitmap *bitmap,int increment,int arg)
 {
 	struct InputPort *in = &Machine->input_ports[arg];
@@ -3507,17 +3540,17 @@
 	if (increment)
 	{
 		attenuation = osd_get_mastervolume();
 		attenuation += increment;
 		if (attenuation > 0) attenuation = 0;
-		if (attenuation < -32) attenuation = -32;
+		if (attenuation < -40) attenuation = -40;
 		osd_set_mastervolume(attenuation);
 	}
 	attenuation = osd_get_mastervolume();
 
 	sprintf(buf,"%s %3ddB", ui_getstring (UI_volume), attenuation);
-	displayosd(bitmap,buf,100 * (attenuation + 32) / 32,100);
+	displayosd(bitmap,buf,100 * (attenuation + 40) / 40,100);
 }
 
 static void onscrd_mixervol(struct mame_bitmap *bitmap,int increment,int arg)
 {
 	static void *driver = 0;
@@ -3862,10 +3895,13 @@
 *********************************************************************/
 
 
 static void displaymessage(struct mame_bitmap *bitmap,const char *text)
 {
+#if 1 /* AdvanceMAME: Use custom ui code */
+	osd_ui_message(text, 0);
+#else
 	struct DisplayText dt[2];
 	int avail;
 
 
 	if (uirotwidth < uirotcharwidth * strlen(text))
@@ -3885,10 +3921,11 @@
 	dt[0].color = UI_COLOR_NORMAL;
 	dt[0].x = (uirotwidth - uirotcharwidth * strlen(text)) / 2;
 	dt[0].y = uirotheight - 5*uirotcharheight/2;
 	dt[1].text = 0; /* terminate array */
 	displaytext(bitmap,dt);
+#endif
 }
 
 
 static char messagetext[200];
 static int messagecounter;
@@ -4010,10 +4047,11 @@
 	return show_profiler;
 }
 
 void ui_display_fps(struct mame_bitmap *bitmap)
 {
+#if 0 /* AdvanceMAME: Use custom ui code */
 	const char *text, *end;
 	char textbuf[256];
 	int done = 0;
 	int x, y = 0;
 	/* remember which area we cover so that we can
@@ -4070,32 +4108,31 @@
 	{
 		showfpstemp--;
 		if (!showfps && showfpstemp == 0)
 			schedule_full_refresh();
 	}
+#endif
 }
 
 
 
 int handle_user_interface(struct mame_bitmap *bitmap)
 {
 #ifdef MESS
 	extern int mess_pause_for_ui;
 #endif
 
+	if (osd_handle_user_interface(bitmap, setup_selected != 0) != 0)
+		return 1;
+
 	/* if the user pressed F12, save the screen to a file */
 	if (input_ui_pressed(IPT_UI_SNAPSHOT))
 		save_screen_snapshot(bitmap);
 
 	/* This call is for the cheat, it must be called once a frame */
 	if (options.cheat) DoCheat(bitmap);
 
-	/* if the user pressed ESC, stop the emulation */
-	/* but don't quit if the setup menu is on screen */
-	if (setup_selected == 0 && input_ui_pressed(IPT_UI_CANCEL))
-		return 1;
-
 	if (setup_selected == 0 && input_ui_pressed(IPT_UI_CONFIGURE))
 	{
 		setup_selected = -1;
 		if (osd_selected != 0)
 		{
@@ -4169,11 +4206,11 @@
 			/* if the user pressed F4, show the character set */
 			if (input_ui_pressed(IPT_UI_SHOW_GFX))
 				showcharset(bitmap);
 
 			if (setup_selected == 0 && input_ui_pressed(IPT_UI_CANCEL))
-				return 1;
+				break;
 
 			if (setup_selected == 0 && input_ui_pressed(IPT_UI_CONFIGURE))
 			{
 				setup_selected = -1;
 				if (osd_selected != 0)
@@ -4252,16 +4289,18 @@
 	}
 
 	if (show_profiler) profiler_show(bitmap);
 
 
+#if 0 /* AdvanceMAME: The show_fps action is managed by the osd code */
 	/* show FPS display? */
 	if (input_ui_pressed(IPT_UI_SHOW_FPS))
 	{
 		/* toggle fps */
 		ui_show_fps_set(!ui_show_fps_get());
 	}
+#endif
 
 
 	/* if the user pressed F4, show the character set */
 	if (input_ui_pressed(IPT_UI_SHOW_GFX))
 	{
diff -U 5 --new-file --recursive src.ori/vidhrdw/tx1.c src/vidhrdw/tx1.c
--- src.ori/vidhrdw/tx1.c	2005-03-27 15:42:14.000000000 +0200
+++ src/vidhrdw/tx1.c	2005-04-03 15:56:56.000000000 +0200
@@ -36,15 +36,16 @@
 	tx1_vram[offset] = data;
 }
 
 static void get_tx1_tile_info(int tile_index)
 {
+	int bit15, upper, lower, tileno;
   	tile_index <<= 1;
-        int bit15 = (tx1_vram[tile_index+1] & 0x80)<<6;
-        int upper = (tx1_vram[tile_index+1]&0x03)<<11;
-        int lower = (tx1_vram[tile_index]<<3);
-	int tileno = (bit15 | upper | lower)/8;
+        bit15 = (tx1_vram[tile_index+1] & 0x80)<<6;
+        upper = (tx1_vram[tile_index+1]&0x03)<<11;
+        lower = (tx1_vram[tile_index]<<3);
+	tileno = (bit15 | upper | lower)/8;
 
 	SET_TILE_INFO(0,tileno,0,0)
 }
 
 VIDEO_START( tx1 )
@@ -177,28 +178,38 @@
 }
 
 
 static void get_buggyb1_tile_info(int tile_index)
 {
+ 	int color;
+        int bit15;
+        int upper;
+        int lower;
+	int tileno;
   	tile_index <<= 1;
- 	int color = ((buggyb1_vram[tile_index+1] >>2) & 0x3f);
-        int bit15 = (buggyb1_vram[tile_index+1] & 0x80);
-        int upper = (buggyb1_vram[tile_index+1]&0x03)<<11;
-        int lower = (buggyb1_vram[tile_index]<<3);
-	int tileno = ((bit15 << 6) | upper | lower)/8;
+ 	color = ((buggyb1_vram[tile_index+1] >>2) & 0x3f);
+        bit15 = (buggyb1_vram[tile_index+1] & 0x80);
+        upper = (buggyb1_vram[tile_index+1]&0x03)<<11;
+        lower = (buggyb1_vram[tile_index]<<3);
+	tileno = ((bit15 << 6) | upper | lower)/8;
 
         SET_TILE_INFO(0,tileno,color,0);
 }
 
 static void get_buggyboy_tile_info(int tile_index)
 {
+ 	int color;
+        int bit15;
+        int upper;
+        int lower;
+	int tileno;
   	tile_index <<= 1;
- 	int color = ((buggyboy_vram[tile_index+1] >>2) & 0x3f);
-        int bit15 = (buggyboy_vram[tile_index+1] & 0x80)<<6;
-        int upper = (buggyboy_vram[tile_index+1]&0x03)<<11;
-        int lower = (buggyboy_vram[tile_index]<<3);
-	int tileno = (bit15 | upper | lower)/8;
+ 	color = ((buggyboy_vram[tile_index+1] >>2) & 0x3f);
+        bit15 = (buggyboy_vram[tile_index+1] & 0x80)<<6;
+        upper = (buggyboy_vram[tile_index+1]&0x03)<<11;
+        lower = (buggyboy_vram[tile_index]<<3);
+	tileno = (bit15 | upper | lower)/8;
 
 	SET_TILE_INFO(0,tileno,color,0)
 }
 
 
@@ -242,10 +253,17 @@
         data8_t *ROM_LUTB = (data8_t *)memory_region(REGION_USER2)+0x8000;      /* Object LUT (lower byte) */
         data8_t *ROM_CLUT = (data8_t *)memory_region(REGION_USER3)+0x2000;      /* Object palette LUT */
 
 	for (offs = 0x0; offs <= (bb_objectram_size); offs += 16)
 	{
+          int bit_12;
+          int PSA0_12;
+          int PSA;
+          int index_y,index_x,index;
+          int object_flip_x;
+          int inc,last;
+
           if(bb_objram[offs+1] == 0xff)   /* End of object list marker? */
                 return;
 
           /* The object code is fed into ROM and PROM to generate a lookup into a pair of ROMs */
           PROM_lookup = bb_objram[offs];
@@ -253,18 +271,17 @@
 
 	  if(rom_lut[ROM_lookup] == 0xff) /* Do not draw object  */
            	continue;
 
           /* Calculate 13-bit index into object lookup ROMs that holds 8x8 chunk sequence */
-          int bit_12 = (((bb_objram[offs]>>7)&0x1) | ((bb_objram[offs]>>6)&0x1)) <<12;
-          int PSA0_12 = ( ( (prom_lut[PROM_lookup]&0xf)<<8) | rom_lut[ROM_lookup] | bit_12) & 0x1fff;
+          bit_12 = (((bb_objram[offs]>>7)&0x1) | ((bb_objram[offs]>>6)&0x1)) <<12;
+          PSA0_12 = ( ( (prom_lut[PROM_lookup]&0xf)<<8) | rom_lut[ROM_lookup] | bit_12) & 0x1fff;
 
-          int PSA = (PSA0_12 << 2);
-          int index_y,index_x,index=0;
+          PSA = (PSA0_12 << 2);
+          index=0;
 
-          int object_flip_x = (bb_objram[offs+5]>>7)&0x1;
-          int inc,last;
+          object_flip_x = (bb_objram[offs+5]>>7)&0x1;
 
           for (index_y=0; index_y<16; index_y++)
           {
 
                 if (object_flip_x)
@@ -308,24 +325,31 @@
                         int tmp3 = bits10_and_11 >> 1;
 
                         int color = (tmp + tmp2 + tmp3);
                         int trans;
 
+                        int bank;
+                        int zoomx;
+                        int zoomy;
+			int flipx;
+			int flipy;
+			const struct GfxElement *gfx;
+
                         if(!(OPCD & 0x80))  /* Seems to work! */
                              trans = TRANSPARENCY_PEN;
                         else
                              trans = TRANSPARENCY_NONE;
 
 
                         /* 8x8 chunk ROM bank (0-2) */
-                        int bank = (((bb_objram[offs+5]>>3)&0x2) | ((chunk_number>>13)&0x1))+1;
-                        int zoomx = 0xffff; //object_ram[offs+6]<<8;
-                        int zoomy = 0xffff; //object_ram[offs+4]<<8;
-			int flipx = ((chunk_number>>15) & 0x1) ^ object_flip_x;
-			int flipy = 0;
+                        bank = (((bb_objram[offs+5]>>3)&0x2) | ((chunk_number>>13)&0x1))+1;
+                        zoomx = 0xffff; //object_ram[offs+6]<<8;
+                        zoomy = 0xffff; //object_ram[offs+4]<<8;
+			flipx = ((chunk_number>>15) & 0x1) ^ object_flip_x;
+			flipy = 0;
 
-			const struct GfxElement *gfx = Machine->gfx[bank];
+			gfx = Machine->gfx[bank];
 
                         index_x+=inc;
                 	index++;
 
 			drawgfxzoom(bitmap, gfx,
diff -U 5 --new-file --recursive src.ori/vidhrdw/voodoo.c src/vidhrdw/voodoo.c
--- src.ori/vidhrdw/voodoo.c	2005-02-04 21:36:32.000000000 +0100
+++ src/vidhrdw/voodoo.c	2005-03-28 18:29:51.000000000 +0200
@@ -16,11 +16,11 @@
  *
  *	Math trickery
  *
  *************************************/
 
-#ifndef _WIN32
+#if 1 /* AdvanceMAME: Use always the portable implementation */
 #define SETUP_FPU()
 #define RESTORE_FPU()
 #define TRUNC_TO_INT(f) (float) (floor(f))
 #else
 #include <float.h>
diff -U 5 --new-file --recursive src.ori/x86drc.c src/x86drc.c
--- src.ori/x86drc.c	2005-03-27 15:42:14.000000000 +0200
+++ src/x86drc.c	2005-03-28 18:29:51.000000000 +0200
@@ -677,10 +677,11 @@
 
 
 /*------------------------------------------------------------------
 	drc_x86_get_features()
 ------------------------------------------------------------------*/
+#if 0
 UINT32 drc_x86_get_features(void)
 {
 	UINT32 features = 0;
 #ifdef _MSC_VER
 	__asm 
@@ -706,10 +707,11 @@
 	: "%ebx", "%ecx", "%edx"	/* clobbers ebx, ecx and edx */
 	);
 #endif /* MSC_VER */
 	return features;
 }
+#endif
 
 
 
 /*------------------------------------------------------------------
 	log_dispatch
