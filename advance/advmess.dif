diff -U 5 --new-file --recursive srcmess.ori/advance.pat srcmess/advance.pat
--- srcmess.ori/advance.pat	1970-01-01 01:00:00.000000000 +0100
+++ srcmess/advance.pat	2005-03-19 21:19:26.000000000 +0100
@@ -0,0 +1 @@
+These files are patched for the use with the Advance emulator.
diff -U 5 --new-file --recursive srcmess.ori/common.c srcmess/common.c
--- srcmess.ori/common.c	2005-02-12 17:10:22.000000000 +0100
+++ srcmess/common.c	2005-03-19 21:19:26.000000000 +0100
@@ -593,10 +593,11 @@
 	the given filename
 -------------------------------------------------*/
 
 void save_screen_snapshot_as(mame_file *fp, struct mame_bitmap *bitmap)
 {
+#if 0 /* AdvanceMAME has its snapshot code */
 	struct rectangle bounds;
 	struct mame_bitmap *osdcopy;
 	UINT32 saved_rgb_components[3];
 
 	/* allow the artwork system to override certain parameters */
@@ -691,20 +692,24 @@
 	memcpy(direct_rgb_components, saved_rgb_components, sizeof(saved_rgb_components));
 
 	/* if the OSD system allocated a bitmap; free it */
 	if (osdcopy)
 		bitmap_free(osdcopy);
+#endif
 }
 
 
 
 /*-------------------------------------------------
 	save_screen_snapshot - save a screen snapshot
 -------------------------------------------------*/
 
 void save_screen_snapshot(struct mame_bitmap *bitmap)
 {
+#if 1 /* AdvanceMAME has its snapshot code */
+	osd_save_snapshot();
+#else
 	char name[20];
 	mame_file *fp;
 
 	/* avoid overwriting existing files */
 	/* first of all try with "gamename.png" */
@@ -721,10 +726,11 @@
 	if ((fp = mame_fopen(Machine->gamedrv->name, name, FILETYPE_SCREENSHOT, 1)) != NULL)
 	{
 		save_screen_snapshot_as(fp, bitmap);
 		mame_fclose(fp);
 	}
+#endif
 }
 
 
 
 /***************************************************************************
@@ -1079,11 +1085,11 @@
 		}
 		else
 			strcat(romdata->errorbuf, "WARNING: the game might not run correctly.\n");
 
 		/* display the result */
-		printf("%s", romdata->errorbuf);
+		osd_display_loading_rom_message(romdata->errorbuf, 0);
 
 		/* if we're not getting out of here, wait for a keypress */
 		if (!options.gui_host && !options.skip_warnings && !bailing)
 		{
 			int k;
diff -U 5 --new-file --recursive srcmess.ori/cpuexec.c srcmess/cpuexec.c
--- srcmess.ori/cpuexec.c	2004-12-17 22:04:14.000000000 +0100
+++ srcmess/cpuexec.c	2005-03-19 21:19:26.000000000 +0100
@@ -323,10 +323,13 @@
 	watchdog_setup();
 
 	/* reset sound chips */
 	sound_reset();
 
+	/* reset the osd level */
+	osd_reset();
+
 	/* first pass over CPUs */
 	for (cpunum = 0; cpunum < cpu_gettotalcpu(); cpunum++)
 	{
 		/* enable all CPUs (except for audio CPUs if the sound is off) */
 		if (!(Machine->drv->cpu[cpunum].cpu_flags & CPU_AUDIO_CPU) || Machine->sample_rate != 0)
diff -U 5 --new-file --recursive srcmess.ori/inptport.c srcmess/inptport.c
--- srcmess.ori/inptport.c	2005-02-15 21:54:48.000000000 +0100
+++ srcmess/inptport.c	2005-03-19 21:19:26.000000000 +0100
@@ -927,26 +927,21 @@
 
 	/* start with the raw defaults and ask the OSD to customize them in the backup array */
 	memcpy(inputport_list_backup, inputport_list_defaults, sizeof(inputport_list_backup));
 	osd_customize_inputport_list(inputport_list_backup);
 
-	/* load the controller-specific info -- note that even though we are still modifying */
-	/* the inputport_list_backup, token_to_port_type relies on inputport_list being valid */
-	memcpy(inputport_list, inputport_list_backup, sizeof(inputport_list));
-	if (options.controller != NULL)
-	{
-		loaded = config_load_controller(options.controller, inputport_list_backup);
-		if (!loaded)
-			osd_die("Could not load controller file %s.cfg\n", options.controller);
-	}
-
 	/* propogate that forward to the live list and apply the config on top of that */
 	memcpy(inputport_list, inputport_list_backup, sizeof(inputport_list));
-	config_load_default(inputport_list_backup, inputport_list);
 
-	/* now load the game-specific info */
-	loaded = config_load(Machine->input_ports_default, Machine->input_ports);
+	/* AdvanceMAME: Load user defined customization */
+	osd_config_load_default(inputport_list_backup, inputport_list);
+
+	/* AdvanceMAME: Load user defined customization */
+	osd_config_load(Machine->input_ports_default, Machine->input_ports);
+
+	/* AdvanceMAME: Report no setting loaded, always show the disclaimer */
+	loaded = 0;
 
 	/* initialize the various port states */
 	inputport_init();
 
 	/* if we didn't find a saved config, return 0 so the main core knows that it */
@@ -956,12 +951,16 @@
 
 
 void save_input_port_settings(void)
 {
 	/* save the default config and the game-specific config */
-	config_save_default(inputport_list_backup, inputport_list);
-	config_save(Machine->input_ports_default, Machine->input_ports);
+
+	/* AdvanceMAME: Save user defined customization */
+	osd_config_save_default(inputport_list_backup, inputport_list);
+
+	/* AdvanceMAME: Save user defined customization */
+	osd_config_save(Machine->input_ports_default, Machine->input_ports);
 }
 
 
 
 /*************************************
@@ -1487,12 +1486,18 @@
 {
 	int listnum;
 
 	/* search the defaults for the type */
 	for (listnum = 0; inputport_list[listnum].type != IPT_END; listnum++)
-		if (inputport_list[listnum].type == type && inputport_list[listnum].player == player)
-			return seq_pressed(&inputport_list[listnum].defaultseq);
+		if (inputport_list[listnum].type == type && inputport_list[listnum].player == player) {
+			int pressed = seq_pressed(&inputport_list[listnum].defaultseq);
+
+			/* AdvanceMAME: Filter all the input ports */
+			pressed = osd_input_port_filter(pressed, inputport_list[listnum].type, inputport_list[listnum].player, SEQ_TYPE_STANDARD);
+
+			return pressed;
+		}
 
 	return 0;
 }
 
 
@@ -1503,10 +1508,13 @@
 profiler_mark(PROFILER_INPUT);
 
 	/* get the status of this key (assumed to be only in the defaults) */
 	pressed = seq_pressed(input_port_default_seq(code, 0, SEQ_TYPE_STANDARD));
 
+	/* AdvanceMAME: Filter all the input ports */
+	pressed = osd_input_port_filter(pressed, code, 0, SEQ_TYPE_STANDARD);
+
 	/* if pressed, handle it specially */
 	if (pressed)
 	{
 		/* if this is the first press, leave pressed = 1 */
 		if (ui_memory[code] == 0)
@@ -1536,10 +1544,13 @@
 profiler_mark(PROFILER_INPUT);
 
 	/* get the status of this key (assumed to be only in the defaults) */
 	pressed = seq_pressed(input_port_default_seq(code, 0, SEQ_TYPE_STANDARD));
 
+	/* AdvanceMAME: Filter all the input ports */
+	pressed = osd_input_port_filter(pressed, code, 0, SEQ_TYPE_STANDARD);
+
 	/* if so, handle it specially */
 	if (pressed)
 	{
 		/* if this is the first press, set a 3x delay and leave pressed = 1 */
 		if (ui_memory[code] == 0)
@@ -1608,10 +1619,13 @@
 void inputport_vblank_start(void)
 {
 	int ui_visible = setup_active() || onscrd_active();
 	int portnum, bitnum;
 
+	/* AdvanceMAME: Never disable the input port. */
+	ui_visible = 0;
+
 profiler_mark(PROFILER_INPUT);
 
 	/* update the digital joysticks first */
 	update_digital_joysticks();
 
@@ -1642,11 +1656,16 @@
 
 			/* handle non-analog types, but only when the UI isn't visible */
 			else if (!IS_ANALOG(port) && !ui_visible)
 			{
 				/* if the sequence for this port is currently pressed.... */
-				if (seq_pressed(input_port_seq(port, SEQ_TYPE_STANDARD)))
+				int pressed = seq_pressed(input_port_seq(port, SEQ_TYPE_STANDARD));
+
+				/* AdvanceMAME: Filter all the input ports */
+				pressed = osd_input_port_filter(pressed, port->type, port->player, SEQ_TYPE_STANDARD);
+
+				if (pressed)
 				{
 #ifdef MESS
 					/* (MESS-specific) check for disabled keyboard */
 					if (port->type == IPT_KEYBOARD && osd_keyboard_disabled())
 						continue;
@@ -1774,17 +1793,18 @@
 			{
 				info->previous = info->current;
 				info->current = 0;
 
 				/* read all the associated ports */
-				if (info->port[JOYDIR_UP] != NULL && seq_pressed(input_port_seq(info->port[JOYDIR_UP], SEQ_TYPE_STANDARD)))
+				/* AdvanceMAME: Filter all the input ports */
+				if (info->port[JOYDIR_UP] != NULL && osd_input_port_filter(seq_pressed(input_port_seq(info->port[JOYDIR_UP], SEQ_TYPE_STANDARD)), info->port[JOYDIR_UP]->type, info->port[JOYDIR_UP]->player, SEQ_TYPE_STANDARD))
 					info->current |= JOYDIR_UP_BIT;
-				if (info->port[JOYDIR_DOWN] != NULL && seq_pressed(input_port_seq(info->port[JOYDIR_DOWN], SEQ_TYPE_STANDARD)))
+				if (info->port[JOYDIR_DOWN] != NULL && osd_input_port_filter(seq_pressed(input_port_seq(info->port[JOYDIR_DOWN], SEQ_TYPE_STANDARD)), info->port[JOYDIR_DOWN]->type, info->port[JOYDIR_DOWN]->player, SEQ_TYPE_STANDARD))
 					info->current |= JOYDIR_DOWN_BIT;
-				if (info->port[JOYDIR_LEFT] != NULL && seq_pressed(input_port_seq(info->port[JOYDIR_LEFT], SEQ_TYPE_STANDARD)))
+				if (info->port[JOYDIR_LEFT] != NULL && osd_input_port_filter(seq_pressed(input_port_seq(info->port[JOYDIR_LEFT], SEQ_TYPE_STANDARD)), info->port[JOYDIR_LEFT]->type, info->port[JOYDIR_LEFT]->player, SEQ_TYPE_STANDARD))
 					info->current |= JOYDIR_LEFT_BIT;
-				if (info->port[JOYDIR_RIGHT] != NULL && seq_pressed(input_port_seq(info->port[JOYDIR_RIGHT], SEQ_TYPE_STANDARD)))
+				if (info->port[JOYDIR_RIGHT] != NULL && osd_input_port_filter(seq_pressed(input_port_seq(info->port[JOYDIR_RIGHT], SEQ_TYPE_STANDARD)), info->port[JOYDIR_RIGHT]->type, info->port[JOYDIR_RIGHT]->player, SEQ_TYPE_STANDARD))
 					info->current |= JOYDIR_RIGHT_BIT;
 
 				/* lock out opposing directions (left + right or up + down) */
 				if ((info->current & (JOYDIR_UP_BIT | JOYDIR_DOWN_BIT)) == (JOYDIR_UP_BIT | JOYDIR_DOWN_BIT))
 					info->current &= ~(JOYDIR_UP_BIT | JOYDIR_DOWN_BIT);
@@ -1895,12 +1915,12 @@
 		int analog_type, keypressed = 0;
 
 		/* clamp the previous value to the min/max range and remember it */
 		info->previous = info->accum = apply_analog_min_max(info, info->accum);
 
-		/* get the new raw analog value and its type */
-		rawvalue = seq_analog_value(input_port_seq(port, SEQ_TYPE_STANDARD), &analog_type);
+		/* AdvanceMAME: Get the analog input for different players from the osd core. */
+		rawvalue = osd_get_analog_value(port->type, port->player, &analog_type);
 
 		/* if we got it from a relative device, use that as the starting delta */
 		/* also note that the last input was not a digital one */
 		if (analog_type == ANALOG_TYPE_RELATIVE && rawvalue != 0)
 		{
@@ -1908,18 +1928,20 @@
 			info->lastdigital = 0;
 		}
 
 		/* if the decrement code sequence is pressed, add the key delta to */
 		/* the accumulated delta; also note that the last input was a digital one */
-		if (seq_pressed(input_port_seq(info->port, SEQ_TYPE_DECREMENT)))
+		/* AdvanceMAME: Filter all the input ports */
+		if (osd_input_port_filter(seq_pressed(input_port_seq(info->port, SEQ_TYPE_DECREMENT)), info->port->type, info->port->player, SEQ_TYPE_DECREMENT))
 		{
 			delta -= (INT32)(port->analog.delta * info->keyscale);
 			keypressed = info->lastdigital = 1;
 		}
 
 		/* same for the increment code sequence */
-		if (seq_pressed(input_port_seq(info->port, SEQ_TYPE_INCREMENT)))
+		/* AdvanceMAME: Filter all the input ports */
+		if (osd_input_port_filter(seq_pressed(input_port_seq(info->port, SEQ_TYPE_INCREMENT)), info->port->type, info->port->player, SEQ_TYPE_INCREMENT))
 		{
 			delta += (INT32)(port->analog.delta * info->keyscale);
 			keypressed = info->lastdigital = 1;
 		}
 
diff -U 5 --new-file --recursive srcmess.ori/input.c srcmess/input.c
--- srcmess.ori/input.c	2004-09-21 20:02:10.000000000 +0200
+++ srcmess/input.c	2005-03-19 21:19:26.000000000 +0100
@@ -603,11 +603,33 @@
 	code_count = 0;
 	free(code_map);
 	code_map = NULL;
 }
 
+os_code_t code_to_oscode(input_code_t code)
+{
+	if (code_map[code].osinfo != NULL)
+		return code_map[code].osinfo->oscode;
+	else
+		return 0;
+}
 
+input_code_t oscode_to_code(os_code_t oscode)
+{
+	unsigned i;
+
+	for(i=0;i<code_count;++i) {
+		if (code_map[i].osinfo != NULL && code_map[i].osinfo->oscode == oscode) {
+			break;
+		}
+	}
+
+	if (i == code_count)
+		return CODE_NONE;
+
+	return i;
+}
 
 /*************************************
  *
  *	Return the analog value of a code.
  *
diff -U 5 --new-file --recursive srcmess.ori/input.h srcmess/input.h
--- srcmess.ori/input.h	2004-09-21 20:02:10.000000000 +0200
+++ srcmess/input.h	2005-03-19 21:19:26.000000000 +0100
@@ -479,10 +479,17 @@
 	CODE_NOT,					/* operators for sequences */
 	CODE_OR						/* operators for sequences */
 };
 
 
+/* AdvanceMAME: Remap the F1 key used by some debug code to an unused key. */
+#ifdef MESS
+#define KEYCODE_F1_REAL KEYCODE_F1
+#else
+#define KEYCODE_F1_REAL (KEYCODE_F2-1)
+#define KEYCODE_F1 KEYCODE_NUMLOCK
+#endif
 
 /*************************************
  *
  *	Type definitions
  *
@@ -530,10 +537,13 @@
 
 /* single code functions */
 int code_init(void);
 void code_close(void);
 
+os_code_t code_to_oscode(input_code_t code);
+input_code_t oscode_to_code(os_code_t oscode);
+
 INT32 code_analog_value(input_code_t code);
 int code_pressed(input_code_t code);
 int code_pressed_memory(input_code_t code);
 int code_pressed_memory_repeat(input_code_t code, int speed);
 input_code_t code_read_async(void);
diff -U 5 --new-file --recursive srcmess.ori/mame.c srcmess/mame.c
--- srcmess.ori/mame.c	2005-03-01 06:24:45.000000000 +0100
+++ srcmess/mame.c	2005-03-19 21:19:26.000000000 +0100
@@ -544,10 +544,15 @@
 		if (options.skip_warnings || showgamewarnings(artwork_get_ui_bitmap()) == 0)
 		{
 			/* show info about the game */
 			if (options.skip_gameinfo || showgameinfo(artwork_get_ui_bitmap()) == 0)
 			{
+				/* AdvanceMAME: Force a video update, otherwise with all the skip options the program crash */
+				fillbitmap(artwork_get_ui_bitmap(), get_black_pen(), NULL);
+				schedule_full_refresh();
+				update_video_and_audio();
+
 				init_user_interface();
 
 				/* enable artwork now */
 				artwork_enable(1);
 
diff -U 5 --new-file --recursive srcmess.ori/osdepend.h srcmess/osdepend.h
--- srcmess.ori/osdepend.h	2005-01-29 00:22:26.000000000 +0100
+++ srcmess/osdepend.h	2005-03-19 21:19:26.000000000 +0100
@@ -350,10 +350,48 @@
       __attribute__ ((format (printf, 1, 2)));
 #else
 void CLIB_DECL logerror(const char *text,...);
 #endif
 
+/* AdvanceMAME: Specific OSD interface */
+
+/* return the analog value of the specified input. */
+INT32 osd_get_analog_value(unsigned type, unsigned player, int* analog_type);
+
+/* called then the game is reset */
+void osd_reset(void);
+
+/* execute the specified menu (0,1,...) */
+int osd_menu(unsigned menu, struct mame_bitmap *bitmap, int sel);
+
+/* filter the main exit request */
+int osd_input_exit_filter(int result);
+
+/* filter the input port state */
+int osd_input_port_filter(int result, unsigned type, unsigned player, int seqtype);
+
+/* snapshot saving */
+void osd_save_snapshot(void);
+
+/* start and stop the video/sound recording. */
+void osd_record_start(void);
+void osd_record_stop(void);
+
+void osd_ui_menu(const char** items,const char** subitems, char* flag, int selected, int arrowize_subitem);
+void osd_ui_message(const char* text, int second);
+void osd_ui_osd(const char *text, int percentage, int default_percentage);
+void osd_ui_scroll(const char* text, int* pos);
+
+/* customize the inputport */
+void osd_config_load_default(struct InputPortDefinition* backup, struct InputPortDefinition* list);
+void osd_config_load(struct InputPort* backup, struct InputPort* list);
+void osd_config_save_default(struct InputPortDefinition* backup, struct InputPortDefinition* list);
+void osd_config_save(struct InputPort* backup, struct InputPort* list);
+
+/* handle the specific user interface */
+int osd_handle_user_interface(struct mame_bitmap *bitmap, int is_menu_active);
+
 #ifdef __cplusplus
 }
 #endif
 
 #endif
diff -U 5 --new-file --recursive srcmess.ori/rules.mak srcmess/rules.mak
--- srcmess.ori/rules.mak	2005-02-26 09:13:38.000000000 +0100
+++ srcmess/rules.mak	2005-03-19 21:19:26.000000000 +0100
@@ -1166,16 +1166,16 @@
 CPUOBJS += $(OBJ)/$(G6D)/g65816o1.o
 CPUOBJS += $(OBJ)/$(G6D)/g65816o2.o
 CPUOBJS += $(OBJ)/$(G6D)/g65816o3.o
 CPUOBJS += $(OBJ)/$(G6D)/g65816o4.o
 DBGOBJS += $(OBJ)/$(G6D)/g65816ds.o
-$(OBJ)/$(G6D)/g65816.o: $(G6D)/g65816.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
-$(OBJ)/$(G6D)/g65816o0.o: $(G6D)/g65816o0.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
-$(OBJ)/$(G6D)/g65816o1.o: $(G6D)/g65816o0.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
-$(OBJ)/$(G6D)/g65816o2.o: $(G6D)/g65816o0.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
-$(OBJ)/$(G6D)/g65816o3.o: $(G6D)/g65816o0.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
-$(OBJ)/$(G6D)/g65816o4.o: $(G6D)/g65816o0.c $(G6D)/g65816.h $(G6D)/g65816cm.h $(G6D)/g65816op.h
+$(OBJ)/$(G6D)/g65816.o: g65816.c g65816.h g65816cm.h g65816op.h
+$(OBJ)/$(G6D)/g65816o0.o: g65816o0.c g65816.h g65816cm.h g65816op.h
+$(OBJ)/$(G6D)/g65816o1.o: g65816o0.c g65816.h g65816cm.h g65816op.h
+$(OBJ)/$(G6D)/g65816o2.o: g65816o0.c g65816.h g65816cm.h g65816op.h
+$(OBJ)/$(G6D)/g65816o3.o: g65816o0.c g65816.h g65816cm.h g65816op.h
+$(OBJ)/$(G6D)/g65816o4.o: g65816o0.c g65816.h g65816cm.h g65816op.h
 else
 CPUDEFS += -DHAS_G65816=0
 endif
 
 CPU=$(strip $(findstring SPC700@,$(CPUS)))
@@ -1183,11 +1183,11 @@
 SPCD = cpu/spc700
 OBJDIRS += $(OBJ)/$(SPCD)
 CPUDEFS += -DHAS_SPC700=1
 CPUOBJS += $(OBJ)/$(SPCD)/spc700.o
 DBGOBJS += $(OBJ)/$(SPCD)/spc700ds.o
-$(OBJ)/$(SPCD)/spc700/spc700.o: $(SPCD)/spc700.c $(SPCD)/spc700.h
+$(OBJ)/$(SPCD)/spc700.o: spc700.c spc700.h
 else
 CPUDEFS += -DHAS_SPC700=0
 endif
 
 CPU=$(strip $(findstring E116T@,$(CPUS)))
@@ -1508,13 +1508,13 @@
 
 SOUND=$(strip $(findstring DISCRETE@,$(SOUNDS)))
 ifneq ($(SOUND),)
 SOUNDDEFS += -DHAS_DISCRETE=1
 SOUNDOBJS += $(OBJ)/sound/discrete.o
-$(OBJ)/sound/discrete.o: src/sound/discrete.c src/sound/discrete.h \
-		src/sound/disc_dev.c src/sound/disc_flt.c src/sound/disc_inp.c \
-		src/sound/disc_mth.c src/sound/disc_wav.c
+$(OBJ)/sound/discrete.o: discrete.c discrete.h \
+		disc_dev.c disc_flt.c disc_inp.c \
+		disc_mth.c disc_wav.c
 else
 SOUNDDEFS += -DHAS_DISCRETE=0
 endif
 
 SOUND=$(strip $(findstring AY8910@,$(SOUNDS)))
diff -U 5 --new-file --recursive srcmess.ori/ui_text.c srcmess/ui_text.c
--- srcmess.ori/ui_text.c	2004-08-22 21:14:00.000000000 +0200
+++ srcmess/ui_text.c	2005-03-19 21:19:26.000000000 +0100
@@ -191,10 +191,14 @@
 	"One match found - added to list",
 
 	/* refresh rate */
 	"Refresh rate",
 
+	/* AdvanceMAME: Extra user interface commands */
+	"Video",
+	"Audio",
+
 	NULL
 };
 
 
 
diff -U 5 --new-file --recursive srcmess.ori/ui_text.h srcmess/ui_text.h
--- srcmess.ori/ui_text.h	2004-07-28 22:26:24.000000000 +0200
+++ srcmess/ui_text.h	2005-03-19 21:19:26.000000000 +0100
@@ -185,10 +185,14 @@
 	UI_search_one_match_found_added,
 	
 	/* refresh rate */
 	UI_refresh_rate,
 
+	/* AdvanceMAME: Extra user interface commands */
+	UI_osd_1,
+	UI_osd_2,
+
 	UI_last_mame_entry
 };
 
 #ifdef MESS
 #include "mui_text.h"
diff -U 5 --new-file --recursive srcmess.ori/usrintrf.c srcmess/usrintrf.c
--- srcmess.ori/usrintrf.c	2005-03-11 05:24:37.000000000 +0100
+++ srcmess/usrintrf.c	2005-03-19 21:19:26.000000000 +0100
@@ -809,10 +809,13 @@
 
 
 
 void ui_displaymenu(struct mame_bitmap *bitmap,const char **items,const char **subitems,char *flag,int selected,int arrowize_subitem)
 {
+#if 1 /* AdvanceMAME: Use custom ui code */
+	osd_ui_menu(items, subitems, flag, selected, arrowize_subitem);
+#else
 	struct DisplayText dt[256];
 	int curr_dt;
 	const char *lefthilight = ui_getstring (UI_lefthilight);
 	const char *righthilight = ui_getstring (UI_righthilight);
 	const char *uparrow = ui_getstring (UI_uparrow);
@@ -979,15 +982,19 @@
 		if (long_y + long_dy > uirotheight)
 			long_y = topoffs + i * 3*uirotcharheight/2 - long_dy;
 
 		ui_multitextbox_ex(bitmap,subitems[selected],subitems[selected] + strlen(subitems[selected]), long_max, long_x,long_y,long_dx,long_dy, UI_COLOR_NORMAL);
 	}
+#endif
 }
 
 
 void ui_displaymessagewindow(struct mame_bitmap *bitmap,const char *text)
 {
+#if 1 /* AdvanceMAME: Use custom ui code */
+	osd_ui_scroll(text, 0);
+#else
 	struct DisplayText dt[256];
 	int curr_dt;
 	char *c,*c2;
 	int i,len,maxlen,lines;
 	char textcopy[2048];
@@ -1082,10 +1089,11 @@
 	}
 
 	dt[curr_dt].text = 0;	/* terminate array */
 
 	displaytext(bitmap,dt);
+#endif
 }
 
 
 
 static void showcharset(struct mame_bitmap *bitmap)
@@ -1759,15 +1767,17 @@
 					menu_item[total] = in->name;
 					total++;
 				}
 				else
 				{
+#if 0 /* AdvanceMAME: The analog configuration is done at OSD level */
 					entry[total] = &in->defaultseq;
 					defentry[total] = &indef->defaultseq;
 					sprintf(menu_item_buffer[total], "%s Analog", in->name);
 					menu_item[total] = menu_item_buffer[total];
 					total++;
+#endif
 
 					analog[total] = 0;
 					entry[total] = &in->defaultdecseq;
 					defentry[total] = &indef->defaultdecseq;
 					sprintf(menu_item_buffer[total], "%s Dec", in->name);
@@ -1946,16 +1956,18 @@
 				menu_subitem[total] = menu_subitem_buffer[total];
 				total++;
 			}
 			else
 			{
+#if 0 /* AdvanceMAME: The analog configuration is done at OSD level */
 				seq[total] = &in->seq;
 				sprintf(menu_item_buffer[total], "%s Analog", input_port_name(in));
 				menu_item[total] = menu_item_buffer[total];
 				seq_name(input_port_seq(in, SEQ_TYPE_STANDARD), menu_subitem_buffer[total], sizeof(menu_subitem_buffer[0]));
 				menu_subitem[total] = menu_subitem_buffer[total];
 				total++;
+#endif
 
 				analog[total] = 0;
 				seq[total] = &in->analog.decseq;
 				sprintf(menu_item_buffer[total], "%s Dec", input_port_name(in));
 				menu_item[total] = menu_item_buffer[total];
@@ -2808,10 +2820,13 @@
 }
 
 /* Display lines from buffer, starting with line 'scroll', in a width x height text window */
 static void display_scroll_message (struct mame_bitmap *bitmap, int *scroll, int width, int height, char *buf)
 {
+#if 1 /* AdvanceMAME: Use custom ui code */
+	osd_ui_scroll(buf, scroll);
+#else
 	struct DisplayText dt[256];
 	int curr_dt = 0;
 	const char *uparrow = ui_getstring (UI_uparrow);
 	const char *downarrow = ui_getstring (UI_downarrow);
 	char textcopy[2048];
@@ -2914,10 +2929,11 @@
 	}
 
 	dt[curr_dt].text = 0;	/* terminate array */
 
 	displaytext(bitmap,dt);
+#endif
 }
 
 
 /* Display text entry for current driver from history.dat and mameinfo.dat. */
 static int displayhistory (struct mame_bitmap *bitmap, int selected)
@@ -2945,11 +2961,13 @@
 		{
 			/* try to load entry */
 			if (load_driver_history (Machine->gamedrv, buf, bufsize) == 0)
 			{
 				scroll = 0;
+#if 0 /* AdvanceMAME: The text is internally wrapped */
 				wordwrap_text_buffer (buf, maxcols);
+#endif
 				strcat(buf,"\n\t");
 				strcat(buf,ui_getstring (UI_lefthilight));
 				strcat(buf," ");
 				strcat(buf,ui_getstring (UI_returntomain));
 				strcat(buf," ");
@@ -3158,16 +3176,16 @@
 
 
 #ifndef MESS
 enum { UI_SWITCH = 0,UI_DEFGROUP,UI_CODE,UI_ANALOG,UI_CALIBRATE,
 		UI_STATS,UI_GAMEINFO, UI_HISTORY,
-		UI_CHEAT,UI_RESET,UI_MEMCARD,UI_EXIT };
+		UI_CHEAT,UI_RESET,UI_MEMCARD,UI_EXIT,UI_OSD_1,UI_OSD_2 };
 #else
 enum { UI_SWITCH = 0,UI_DEFGROUP,UI_CODE,UI_ANALOG,UI_CALIBRATE,
 		UI_GAMEINFO, UI_IMAGEINFO,UI_FILEMANAGER,UI_TAPECONTROL,
-		UI_HISTORY,UI_CHEAT,UI_RESET,UI_MEMCARD,UI_EXIT,
-		UI_CONFIGURATION, UI_CATEGORIES };
+		UI_HISTORY,UI_CHEAT,UI_RESET,UI_MEMCARD,UI_EXIT,UI_OSD_1,UI_OSD_2,
+		UI_CONFIGURATION, UI_CATEGORIES, };
 #endif
 
 
 #define MAX_SETUPMENU_ITEMS 20
 static const char *menu_item[MAX_SETUPMENU_ITEMS];
@@ -3298,10 +3316,13 @@
 		memcard_intf.eject != NULL)
 	{
 		append_menu(UI_memorycard, UI_MEMCARD);
 	}
 
+	/* AdvanceMAME: Extra menu UI_OSD */
+	append_menu(UI_osd_1, UI_OSD_1);
+	append_menu(UI_osd_2, UI_OSD_2);
 	append_menu(UI_resetgame, UI_RESET);
 	append_menu(UI_returntogame, UI_EXIT);
 	menu_item[menu_total] = 0; /* terminate array */
 }
 
@@ -3366,10 +3387,15 @@
 				res = displayhistory(bitmap, sel >> SEL_BITS);
 				break;
 			case UI_CHEAT:
 				res = cheat_menu(bitmap, sel >> SEL_BITS);
 				break;
+			/* AdvanceMAME: Extra menu UI_OSD */
+			case UI_OSD_1 :
+			case UI_OSD_2 :
+				res = osd_menu(menu_action[sel & SEL_MASK] - UI_OSD_1, bitmap, sel >> SEL_BITS);
+				break;
 			case UI_MEMCARD:
 				res = memcard_menu(bitmap, sel >> SEL_BITS);
 				break;
 		}
 
@@ -3414,10 +3440,13 @@
 			case UI_CATEGORIES:
 #endif /* !MESS */
 			case UI_HISTORY:
 			case UI_CHEAT:
 			case UI_MEMCARD:
+			/* AdvanceMAME: Extra menu UI_OSD */
+			case UI_OSD_1 :
+			case UI_OSD_2 :
 				sel |= 1 << SEL_BITS;
 				schedule_full_refresh();
 				break;
 
 			case UI_RESET:
@@ -3454,10 +3483,13 @@
 
 *********************************************************************/
 
 static void displayosd(struct mame_bitmap *bitmap,const char *text,int percentage,int default_percentage)
 {
+#if 1 /* AdvanceMAME: Use custom ui code */
+	osd_ui_osd(text, percentage, default_percentage);
+#else
 	struct DisplayText dt[2];
 	int avail;
 
 
 	avail = (uirotwidth / uirotcharwidth) * 19 / 20;
@@ -3479,10 +3511,11 @@
 	dt[0].color = UI_COLOR_NORMAL;
 	dt[0].x = (uirotwidth - uirotcharwidth * strlen(text)) / 2;
 	dt[0].y = (uirotheight - 2*uirotcharheight) + 2;
 	dt[1].text = 0; /* terminate array */
 	displaytext(bitmap,dt);
+#endif
 }
 
 static void onscrd_adjuster(struct mame_bitmap *bitmap,int increment,int arg)
 {
 	struct InputPort *in = &Machine->input_ports[arg];
@@ -3512,17 +3545,17 @@
 	if (increment)
 	{
 		attenuation = osd_get_mastervolume();
 		attenuation += increment;
 		if (attenuation > 0) attenuation = 0;
-		if (attenuation < -32) attenuation = -32;
+		if (attenuation < -40) attenuation = -40;
 		osd_set_mastervolume(attenuation);
 	}
 	attenuation = osd_get_mastervolume();
 
 	sprintf(buf,"%s %3ddB", ui_getstring (UI_volume), attenuation);
-	displayosd(bitmap,buf,100 * (attenuation + 32) / 32,100);
+	displayosd(bitmap,buf,100 * (attenuation + 40) / 40,100);
 }
 
 static void onscrd_mixervol(struct mame_bitmap *bitmap,int increment,int arg)
 {
 	static void *driver = 0;
@@ -3867,10 +3900,13 @@
 *********************************************************************/
 
 
 static void displaymessage(struct mame_bitmap *bitmap,const char *text)
 {
+#if 1 /* AdvanceMAME: Use custom ui code */
+	osd_ui_message(text, 0);
+#else
 	struct DisplayText dt[2];
 	int avail;
 
 
 	if (uirotwidth < uirotcharwidth * strlen(text))
@@ -3890,10 +3926,11 @@
 	dt[0].color = UI_COLOR_NORMAL;
 	dt[0].x = (uirotwidth - uirotcharwidth * strlen(text)) / 2;
 	dt[0].y = uirotheight - 5*uirotcharheight/2;
 	dt[1].text = 0; /* terminate array */
 	displaytext(bitmap,dt);
+#endif
 }
 
 
 static char messagetext[200];
 static int messagecounter;
@@ -4015,10 +4052,11 @@
 	return show_profiler;
 }
 
 void ui_display_fps(struct mame_bitmap *bitmap)
 {
+#if 0 /* AdvanceMAME: Use custom ui code */
 	const char *text, *end;
 	char textbuf[256];
 	int done = 0;
 	int x, y = 0;
 	/* remember which area we cover so that we can
@@ -4075,32 +4113,31 @@
 	{
 		showfpstemp--;
 		if (!showfps && showfpstemp == 0)
 			schedule_full_refresh();
 	}
+#endif
 }
 
 
 
 int handle_user_interface(struct mame_bitmap *bitmap)
 {
 #ifdef MESS
 	extern int mess_pause_for_ui;
 #endif
 
+	if (osd_handle_user_interface(bitmap, setup_selected != 0) != 0)
+		return 1;
+
 	/* if the user pressed F12, save the screen to a file */
 	if (input_ui_pressed(IPT_UI_SNAPSHOT))
 		save_screen_snapshot(bitmap);
 
 	/* This call is for the cheat, it must be called once a frame */
 	if (options.cheat) DoCheat(bitmap);
 
-	/* if the user pressed ESC, stop the emulation */
-	/* but don't quit if the setup menu is on screen */
-	if (setup_selected == 0 && input_ui_pressed(IPT_UI_CANCEL))
-		return 1;
-
 	if (setup_selected == 0 && input_ui_pressed(IPT_UI_CONFIGURE))
 	{
 		setup_selected = -1;
 		if (osd_selected != 0)
 		{
@@ -4136,12 +4173,15 @@
 
 #ifndef MESS
 	if (single_step || input_ui_pressed(IPT_UI_PAUSE)) /* pause the game */
 	{
 #else
+
+#if 0 /* AdvanceMAME: The game is not paused when the UI is active */
 	if (setup_selected)
 		mess_pause_for_ui = 1;
+#endif
 
 	if (single_step || input_ui_pressed(IPT_UI_PAUSE) || mess_pause_for_ui) /* pause the game */
 	{
 #endif
 /*		osd_selected = 0;	   disable on screen display, since we are going   */
@@ -4174,11 +4214,11 @@
 			/* if the user pressed F4, show the character set */
 			if (input_ui_pressed(IPT_UI_SHOW_GFX))
 				showcharset(bitmap);
 
 			if (setup_selected == 0 && input_ui_pressed(IPT_UI_CANCEL))
-				return 1;
+				break;
 
 			if (setup_selected == 0 && input_ui_pressed(IPT_UI_CONFIGURE))
 			{
 				setup_selected = -1;
 				if (osd_selected != 0)
@@ -4257,16 +4297,18 @@
 	}
 
 	if (show_profiler) profiler_show(bitmap);
 
 
+#if 0 /* AdvanceMAME: The show_fps action is managed by the osd code */
 	/* show FPS display? */
 	if (input_ui_pressed(IPT_UI_SHOW_FPS))
 	{
 		/* toggle fps */
 		ui_show_fps_set(!ui_show_fps_get());
 	}
+#endif
 
 
 	/* if the user pressed F4, show the character set */
 	if (input_ui_pressed(IPT_UI_SHOW_GFX))
 	{
diff -U 5 --new-file --recursive srcmess.ori/x86drc.c srcmess/x86drc.c
--- srcmess.ori/x86drc.c	2004-11-23 18:05:40.000000000 +0100
+++ srcmess/x86drc.c	2005-03-19 21:19:26.000000000 +0100
@@ -677,10 +677,11 @@
 
 
 /*------------------------------------------------------------------
 	drc_x86_get_features()
 ------------------------------------------------------------------*/
+#if 0
 UINT32 drc_x86_get_features(void)
 {
 	UINT32 features = 0;
 #ifdef _MSC_VER
 	__asm 
@@ -706,10 +707,11 @@
 	: "%ebx", "%ecx", "%edx"	/* clobbers ebx, ecx and edx */
 	);
 #endif /* MSC_VER */
 	return features;
 }
+#endif
 
 
 
 /*------------------------------------------------------------------
 	log_dispatch
