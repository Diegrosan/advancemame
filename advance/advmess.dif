diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/advance.pat srcmess/advance.pat
--- srcmess.ori/advance.pat	1970-01-01 01:00:00.000000000 +0100
+++ srcmess/advance.pat	2003-02-12 02:11:49.000000000 +0100
@@ -0,0 +1 @@
+These files are patched for the use with the Advance emulator.
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/artwork.c srcmess/artwork.c
--- srcmess.ori/artwork.c	2002-11-20 21:11:00.000000000 +0100
+++ srcmess/artwork.c	2003-01-23 05:32:03.000000000 +0100
@@ -304,10 +304,13 @@
 #include "artwork.h"
 #include "vidhrdw/vector.h"
 #include <ctype.h>
 #include <math.h>
 
+#ifdef MESS
+#include "image.h"
+#endif
 
 /***************************************************************************
 
 	Constants & macros
 
@@ -582,10 +585,27 @@
 	}
 }
 
 
 
+/*-------------------------------------------------
+	use_artwork_system - decides whether it is
+	appropriate to use the artwork system or not
+-------------------------------------------------*/
+
+static int use_artwork_system(struct osd_create_params *params)
+{
+#ifdef MESS
+	if ((params->width < options.min_width) && (params->height < options.min_height))
+	{
+		options.artwork_res = 2;
+		return 1;
+	}
+#endif
+	return artwork_list != NULL;
+}
+
 #if 0
 #pragma mark -
 #pragma mark OSD FRONTENDS
 #endif
 
@@ -610,11 +630,11 @@
 
 	/* first load the artwork; if none, quit now */
 	artwork_list = NULL;
 	if (!artwork_load(Machine->gamedrv, original_width, original_height))
 		return 1;
-	if (!artwork_list)
+	if (!use_artwork_system(params))
 		return osd_create_display(params, rgb_components);
 
 	/* determine the game bitmap scale factor */
 	gamescale = options.artwork_res;
 	if (gamescale < 1 || (params->video_attributes & VIDEO_TYPE_VECTOR))
@@ -1958,10 +1978,41 @@
 			}
 		}
 	}
 }
 
+#ifdef MESS
+static char *override_artfile;
+
+void artwork_use_device_art(int device_type, int device_id, const char *defaultartfile)
+{
+	const char *fname;
+	const char *ext;
+	int len = -1;
+
+	fname = image_filename(device_type, device_id);
+	if (fname)
+	{
+		ext = strrchr(fname, '.');
+		if (ext)
+			len = ext - fname;
+	}
+	else
+	{
+		fname = defaultartfile;
+	}
+	if (len == -1)
+		len = strlen(fname);
+
+	override_artfile = malloc(len + 1);
+	if (!override_artfile)
+		return;
+	memcpy(override_artfile, fname, len);
+	override_artfile[len] = 0;
+}
+#endif
+
 
 
 #if 0
 #pragma mark -
 #pragma mark BITMAP LOADING/MANIPULATING
@@ -1998,10 +2049,19 @@
 	/* attempt to open the .ART file; if none, that's okay */
 	while (driver)
 	{
 		if (driver->name)
 		{
+#ifdef MESS
+			if (override_artfile)
+			{
+				sprintf(filename, "%s.art", override_artfile);
+				free(override_artfile);
+				override_artfile = NULL;
+			}
+			else	/* else do it the MAME way... */
+#endif /* MESS */
 			sprintf(filename, "%s.art", driver->name);
 			artfile = mame_fopen(driver->name, filename, FILETYPE_ARTWORK, 0);
 			if (artfile)
 				break;
 		}
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/artwork.h srcmess/artwork.h
--- srcmess.ori/artwork.h	2002-05-28 13:10:24.000000000 +0200
+++ srcmess/artwork.h	2002-08-23 01:58:35.000000000 +0200
@@ -84,6 +84,10 @@
 void artwork_enable(int enable);
 
 void artwork_set_overlay(const struct overlay_piece *overlist);
 void artwork_show(const char *tag, int show);
 
+#ifdef MESS
+void artwork_use_device_art(int device_type, int device_id, const char *defaultartfile);
+#endif /* MESS */
+
 #endif
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/cheat.c srcmess/cheat.c
--- srcmess.ori/cheat.c	2002-11-20 21:12:00.000000000 +0100
+++ srcmess/cheat.c	2003-01-23 05:32:04.000000000 +0100
@@ -10439,11 +10439,11 @@
 
 	for(deviceType = 0; deviceType < IO_COUNT; deviceType++)
 	{
 		for(deviceID = 0; deviceID < device_count(deviceType); deviceID++)
 		{
-			UINT32	crc = device_crc(deviceType, deviceID);
+			UINT32	crc = image_crc(deviceType, deviceID);
 			int		isUnique = 1;
 
 			for(listIdx = 0; listIdx < deviceCRCListLength; listIdx++)
 			{
 				if(deviceCRCList[listIdx] == crc)
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/common.c srcmess/common.c
--- srcmess.ori/common.c	2002-12-03 10:33:53.000000000 +0100
+++ srcmess/common.c	2003-02-12 02:27:09.000000000 +0100
@@ -1117,11 +1117,11 @@
 		}
 		else
 			strcat(romdata->errorbuf, "WARNING: the game might not run correctly.\n");
 
 		/* display the result */
-		printf("%s", romdata->errorbuf);
+		osd_display_loading_rom_message(romdata->errorbuf, 0);
 
 		/* if we're not getting out of here, wait for a keypress */
 		if (!options.gui_host && !bailing)
 		{
 			int k;
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/cpu/hd6309/6309dasm.c srcmess/cpu/hd6309/6309dasm.c
--- srcmess.ori/cpu/hd6309/6309dasm.c	2002-09-05 18:49:52.000000000 +0200
+++ srcmess/cpu/hd6309/6309dasm.c	2002-08-31 03:56:08.000000000 +0200
@@ -597,10 +597,11 @@
 	{ 0xF0,3,"SUBF",    EXT, EA_UINT8, EA_MEM_RD,    6},
 	{ 0xF1,3,"CMPF",    EXT, EA_UINT8, EA_MEM_RD,    6},
 	{ 0xF6,3,"LDF",     EXT, EA_UINT8, EA_MEM_RD,    6},
 	{ 0xF7,3,"STF",     EXT, EA_UINT8, EA_MEM_WR,    6},
 	{ 0xFB,3,"ADDF",    EXT, EA_UINT8, EA_MEM_RD,    6},
+	{ 0xFC,0,"EMUDBG",  INH, 0,        0,            0},
 
 };
 
 int numops6309[3] =
 {
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/cpu/hd6309/6309ops.c srcmess/cpu/hd6309/6309ops.c
--- srcmess.ori/cpu/hd6309/6309ops.c	2002-09-05 18:49:40.000000000 +0200
+++ srcmess/cpu/hd6309/6309ops.c	2002-11-14 07:04:56.000000000 +0100
@@ -4149,11 +4149,11 @@
 {
 	PAIR	t;
 	UINT32	r;
 	IMMWORD(t);
 	r = D + t.w.l + (CC & CC_C);
-	CLR_HNZVC;
+	CLR_NZVC;
 	SET_FLAGS16(D,t.w.l,r);
 	D = r;
 }
 
 /* $cA ORB immediate -**0- */
@@ -4491,15 +4491,17 @@
 }
 
 /* $1099 adcd direct ***** */
 INLINE void adcd_di( void )
 {
-	UINT32 t,r;
-	DIRBYTE(t);
-	r = D + t + (CC & CC_C);
-	CLR_HNZVC;
-	SET_FLAGS16(D,t,r);
+	UINT32	r;
+	PAIR	t;
+	
+	DIRWORD(t);
+	r = D + t.w.l + (CC & CC_C);
+	CLR_NZVC;
+	SET_FLAGS16(D,t.w.l,r);
 	D = r;
 }
 
 /* $dA ORB direct -**0- */
 INLINE void orb_di( void )
@@ -4882,16 +4884,17 @@
 }
 
 /* $10a9 ADCD indexed ***** */
 INLINE void adcd_ix( void )
 {
-	UINT32 t,r;
+	UINT32	r;
+	PAIR	t;
 	fetch_effective_address();
-	t = RM(EAD);
-	r = D + t + (CC & CC_C);
-	CLR_HNZVC;
-	SET_FLAGS16(D,t,r);
+	t.d = RM16(EAD);
+	r = D + t.d + (CC & CC_C);
+	CLR_NZVC;
+	SET_FLAGS16(D,t.d,r);
 	D = r;
 }
 
 /* $eA ORB indexed -**0- */
 INLINE void orb_ix( void )
@@ -5261,15 +5264,16 @@
 }
 
 /* $10b9 ADCD extended ***** */
 INLINE void adcd_ex( void )
 {
-	UINT32 t,r;
-	EXTBYTE(t);
-	r = D + t + (CC & CC_C);
-	CLR_HNZVC;
-	SET_FLAGS16(D,t,r);
+	UINT32	r;
+	PAIR	t;
+	EXTWORD(t);
+	r = D + t.w.l + (CC & CC_C);
+	CLR_NZVC;
+	SET_FLAGS16(D,t.w.l,r);
 	D = r;
 }
 
 /* $fA ORB extended -**0- */
 INLINE void orb_ex( void )
@@ -5370,10 +5374,19 @@
 	SET_NZ16(S);
 	EXTENDED;
 	WM16(EAD,&pS);
 }
 
+/* $11fc Emulation debug (emu_dbg) */
+INLINE void emu_dbg( void )
+{
+#ifdef MAME_DEBUG
+	extern int debug_key_pressed;
+	debug_key_pressed = 1;
+#endif
+}
+
 /* $10xx opcodes */
 INLINE void pref10( void )
 {
 	UINT8 ireg2 = ROP(PCD);
 	PC++;
@@ -5622,11 +5635,12 @@
 		case 0xf0: subf_ex();		break;
 		case 0xf1: cmpf_ex();		break;
 		case 0xf6: ldf_ex();		break;
 		case 0xf7: stf_ex();		break;
 		case 0xfb: addf_ex();		break;
-
+		case 0xfc: emu_dbg();		break;
+		
 		default:   IIError();		break;
 	}
 #else
 
 	(*hd6309_page11[ireg2])();
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/cpu/hd6309/6309tbl.c srcmess/cpu/hd6309/6309tbl.c
--- srcmess.ori/cpu/hd6309/6309tbl.c	2002-09-05 18:50:35.000000000 +0200
+++ srcmess/cpu/hd6309/6309tbl.c	2002-09-05 02:43:34.000000000 +0200
@@ -436,10 +436,11 @@
 INLINE void lds_ex( void );
 INLINE void stu_ex( void );
 INLINE void sts_ex( void );
 INLINE void pref10( void );
 INLINE void pref11( void );
+INLINE void emu_dbg( void );
 
 static UINT8 flags8i[256]=	 /* increment */
 {
 CC_Z,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
@@ -805,10 +806,10 @@
 
 /* 0xEX */  subf_ix, cmpf_ix, IIError, IIError, IIError, IIError, ldf_ix,  stf_ix,
 			IIError, IIError, IIError, addf_ix, IIError, IIError, IIError, IIError,
 
 /* 0xFX */  subf_ex, cmpf_ex, IIError, IIError, IIError, IIError, ldf_ex,  stf_ex,
-			IIError, IIError, IIError, addf_ex, IIError, IIError, IIError, IIError
+			IIError, IIError, IIError, addf_ex, emu_dbg, IIError, IIError, IIError
 
 };
 
 #endif /* BIG_SWITCH */
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/cpu/i8085/8085dasm.c srcmess/cpu/i8085/8085dasm.c
--- srcmess.ori/cpu/i8085/8085dasm.c	2002-03-06 16:26:34.000000000 +0100
+++ srcmess/cpu/i8085/8085dasm.c	2002-07-21 18:24:44.000000000 +0200
@@ -521,19 +521,19 @@
 		case 0xdd: sprintf (buff,"jnx  $%04x (*)", ARGW(pc)); pc+=2; break;
 		case 0xde: sprintf (buff,"sbi  $%02x", ARG(pc)); pc++;       break;
 		case 0xdf: sprintf (buff,"rst  3");                          break;
 		case 0xe0: sprintf (buff,"rpe");                             break;
 		case 0xe1: sprintf (buff,"pop  h");                          break;
-		case 0xe2: sprintf (buff,"jpe  $%04x", ARGW(pc)); pc+=2;     break;
+		case 0xe2: sprintf (buff,"jpo  $%04x", ARGW(pc)); pc+=2;     break;
 		case 0xe3: sprintf (buff,"xthl");                            break;
 		case 0xe4: sprintf (buff,"cpe  $%04x", ARGW(pc)); pc+=2;     break;
 		case 0xe5: sprintf (buff,"push h");                          break;
 		case 0xe6: sprintf (buff,"ani  $%02x", ARG(pc)); pc++;       break;
 		case 0xe7: sprintf (buff,"rst  4");                          break;
 		case 0xe8: sprintf (buff,"rpo");                             break;
 		case 0xe9: sprintf (buff,"pchl");                            break;
-		case 0xea: sprintf (buff,"jpo  $%04x", ARGW(pc)); pc+=2;     break;
+		case 0xea: sprintf (buff,"jpe  $%04x", ARGW(pc)); pc+=2;     break;
 		case 0xeb: sprintf (buff,"xchg");                            break;
 		case 0xec: sprintf (buff,"cpo  $%04x", ARGW(pc)); pc+=2;     break;
 		case 0xed: sprintf (buff,"lhlx d (*)");                      break;
 		case 0xee: sprintf (buff,"xri  $%02x", ARG(pc)); pc++;       break;
 		case 0xef: sprintf (buff,"rst  5");                          break;
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/cpu/i8085/i8085.c srcmess/cpu/i8085/i8085.c
--- srcmess.ori/cpu/i8085/i8085.c	2002-08-25 00:51:27.000000000 +0200
+++ srcmess/cpu/i8085/i8085.c	2003-02-12 02:11:49.000000000 +0100
@@ -57,14 +57,39 @@
  * - 8085 emulation was in fact never used. It's been treated as a plain 8080.
  * - protected IRQ0 vector from being overwritten
  * - modified interrupt handler to properly process 8085-specific IRQ's
  * - corrected interrupt masking, RIM and SIM behaviors according to Intel's documentation
  *
+ * 20-07-2002 Krzysztof Strzecha
+ *
+ * - SBB r instructions should affect parity flag.
+ *   Fixed only for non x86 asm version (#define i8080_EXACT 1).
+ *   There are probably more opcodes which should affect this flag, but don't.
+ * - JPO nnnn and JPE nnnn opcodes in disassembler were misplaced. Fixed.
+ * - Undocumented i8080 opcodes added:
+ *   08h, 10h, 18h, 20h, 28h, 30h, 38h  -  NOP
+ *   0CBh                               -  JMP
+ *   0D9h                               -  RET
+ *   0DDh, 0EDh, 0FDh                   -  CALL
+ *   Thanks for the info go to Anton V. Ignatichev.
+ *
+ * 08-12-2002 Krzysztof Strzecha
+ *
+ * - ADC r instructions should affect parity flag.
+ *   Fixed only for non x86 asm version (#define i8080_EXACT 1).
+ *   There are probably more opcodes which should affect this flag, but don't.
+ * 
  *****************************************************************************/
 
 /*int survival_prot = 0; */
 
+#if defined(__GNUC__) && __GNUC__ >= 3
+/* Disable all the asm macro and the big switch */
+#undef X86_ASM
+#define BIG_SWITCH 0
+#endif
+
 #define VERBOSE 0
 
 #include "driver.h"
 #include "state.h"
 #include "osd_cpu.h"
@@ -141,11 +166,14 @@
 	w += cpu_readop_arg(I.PC.d) << 8;
 	I.PC.w.l++;
 	return w;
 }
 
-#define RM(a) cpu_readmem16(a)
+static UINT8 RM(UINT32 a)
+{
+	return cpu_readmem16(a);
+}
 
 static void WM(UINT32 a, UINT8 v)
 {
 	cpu_writemem16(a, v);
 }
@@ -191,12 +219,11 @@
 		case 0x08:
 			if( I.cputype ) {
 				i8085_ICount -= 10;		/* DSUB */
 				M_DSUB();
 			} else {
-				i8085_ICount -= 4;
-				illegal(); 				/* ???? */
+				i8085_ICount -= 4;		/* NOP undocumented */
 			}
 			break;
 		case 0x09: i8085_ICount -= 10;	/* DAD	B */
 			M_DAD(BC);
 			break;
@@ -224,12 +251,11 @@
 			if( I.cputype ) {
 				i8085_ICount -= 7;		/* ASRH */
 				I.AF.b.l = (I.AF.b.l & ~CF) | (I.HL.b.l & CF);
 				I.HL.w.l = (I.HL.w.l >> 1);
 			} else {
-				i8085_ICount -= 8;		/* ????  */
-				illegal();
+				i8085_ICount -= 4;		/* NOP undocumented */
 			}
 			break;
 		case 0x11: i8085_ICount -= 10;	/* LXI	D,nnnn */
 			I.DE.w.l = ARG16();
 			break;
@@ -259,12 +285,11 @@
 				I.AF.b.l = (I.AF.b.l & ~(CF | VF)) | (I.DE.b.h >> 7);
 				I.DE.w.l = (I.DE.w.l << 1) | (I.DE.w.l >> 15);
 				if (0 != (((I.DE.w.l >> 15) ^ I.AF.b.l) & CF))
 					I.AF.b.l |= VF;
 			} else {
-				i8085_ICount -= 7;		/* ????? */
-				illegal();
+				i8085_ICount -= 4;		/* NOP undocumented */
 			}
 			break;
 		case 0x19: i8085_ICount -= 10;	/* DAD	D */
 			M_DAD(DE);
 			break;
@@ -293,11 +318,11 @@
 				i8085_ICount -= 7;		/* RIM	*/
 				I.AF.b.h = I.IM;
 				I.AF.b.h |= RIM_IEN; RIM_IEN = 0; //AT: read and clear IEN status latch
 /*				survival_prot ^= 0x01; */
 			} else {
-				i8085_ICount -= 7;		/* ???	*/
+				i8085_ICount -= 4;		/* NOP undocumented */
 			}
 			break;
 		case 0x21: i8085_ICount -= 10;	/* LXI	H,nnnn */
 			I.HL.w.l = ARG16();
 			break;
@@ -332,12 +357,11 @@
 			if( I.cputype ) {
 				i8085_ICount -= 10;		/* LDEH nn */
 				I.XX.d = ARG();
 				I.DE.d = (I.HL.d + I.XX.d) & 0xffff;
 			} else {
-				i8085_ICount -= 7;		/* ???? */
-				illegal();
+				i8085_ICount -= 4;		/* NOP undocumented */
 			}
 			break;
 		case 0x29: i8085_ICount -= 10;	/* DAD	H */
 			M_DAD(HL);
 			break;
@@ -378,11 +402,11 @@
 				if (I.AF.b.h & 0x08)
 					I.IM = (I.IM & ~(IM_RST55+IM_RST65+IM_RST75)) | (I.AF.b.h & (IM_RST55+IM_RST65+IM_RST75));
 //ZT
 				if (I.AF.b.h & 0x80) I.IM |= IM_SOD;
 			} else {
-				i8085_ICount -= 4;		/* ???	*/
+				i8085_ICount -= 4;		/* NOP undocumented */
 			}
 			break;
 		case 0x31: i8085_ICount -= 10;	/* LXI SP,nnnn */
 			I.SP.w.l = ARG16();
 			break;
@@ -416,12 +440,11 @@
 			if( I.cputype ) {
 				i8085_ICount -= 10;		/* LDES nn */
 				I.XX.d = ARG();
 				I.DE.d = (I.SP.d + I.XX.d) & 0xffff;
 			} else {
-				i8085_ICount -= 7;		/* ???? */
-				illegal();
+				i8085_ICount -= 4;		/* NOP undocumented */
 			}
 			break;
 		case 0x39: i8085_ICount -= 10;	/* DAD SP */
 			M_DAD(SP);
 			break;
@@ -891,12 +914,12 @@
 					M_RST(8);			/* call 0x40 */
 				} else {
 					i8085_ICount -= 6;	/* RST  V */
 				}
 			} else {
-				i8085_ICount -= 4;		/* ???? */
-				illegal();
+				i8085_ICount -= 7;	/* JMP	nnnn undocumented*/
+				M_JMP(1);
 			}
 			break;
 		case 0xcc: i8085_ICount -= 11;	/* CZ	nnnn */
 			M_CALL( I.AF.b.l & ZF );
 			break;
@@ -946,12 +969,12 @@
 				I.XX.w.l = I.DE.w.l;
 				WM(I.XX.d, I.HL.b.l);
 				I.XX.w.l++;
 				WM(I.XX.d, I.HL.b.h);
 			} else {
-				i8085_ICount -= 4;		/* ???? */
-				illegal();
+				i8085_ICount -= 4;	/* RET undocumented */
+				M_RET(1);
 			}
 			break;
 		case 0xda: i8085_ICount -= 7;	/* JC	nnnn */
 			M_JMP( I.AF.b.l & CF );
 			break;
@@ -964,12 +987,12 @@
 		case 0xdd:
 			if( I.cputype ) {
 				i8085_ICount -= 7;		/* JNX  nnnn */
 				M_JMP( !(I.AF.b.l & XF) );
 			} else {
-				i8085_ICount -= 4;		/* ???? */
-				illegal();
+				i8085_ICount -= 11;	/* CALL nnnn undocumented */
+				M_CALL(1);
 			}
 			break;
 		case 0xde: i8085_ICount -= 7;	/* SBI	nn */
 			I.XX.b.l = ARG();
 			M_SBB(I.XX.b.l);
@@ -982,11 +1005,11 @@
 			M_RET( !(I.AF.b.l & VF) );
 			break;
 		case 0xe1: i8085_ICount -= 10;	/* POP	H */
 			M_POP(HL);
 			break;
-		case 0xe2: i8085_ICount -= 7;	/* JPE	nnnn */
+		case 0xe2: i8085_ICount -= 7;	/* JPO	nnnn */
 			M_JMP( !(I.AF.b.l & VF) );
 			break;
 		case 0xe3: i8085_ICount -= 18;	/* XTHL */
 			M_POP(XX);
 			M_PUSH(HL);
@@ -1011,11 +1034,11 @@
 			break;
 		case 0xe9: i8085_ICount -= 5;	/* PCHL */
 			I.PC.d = I.HL.w.l;
 			change_pc16(I.PC.d);
 			break;
-		case 0xea: i8085_ICount -= 7;	/* JPO	nnnn */
+		case 0xea: i8085_ICount -= 7;	/* JPE	nnnn */
 			M_JMP( I.AF.b.l & VF );
 			break;
 		case 0xeb: i8085_ICount -= 4;	/* XCHG */
 			I.XX.d = I.DE.d;
 			I.DE.d = I.HL.d;
@@ -1030,14 +1053,13 @@
 				I.XX.w.l = I.DE.w.l;
 				I.HL.b.l = RM(I.XX.d);
 				I.XX.w.l++;
 				I.HL.b.h = RM(I.XX.d);
 			} else {
-				i8085_ICount -= 4;		/* ???? */
-				illegal();
+				i8085_ICount -= 11;	/* CALL nnnn undocumented */
+				M_CALL(1);
 			}
-			illegal();
 			break;
 		case 0xee: i8085_ICount -= 7;	/* XRI	nn */
 			I.XX.b.l = ARG();
 			M_XRA(I.XX.b.l);
 			break;
@@ -1136,12 +1158,12 @@
 		case 0xfd:
 			if( I.cputype ) {
 				i8085_ICount -= 7;		/* JX   nnnn */
 				M_JMP( I.AF.b.l & XF );
 			} else {
-				i8085_ICount -= 4;		/* ???? */
-				illegal();
+				i8085_ICount -= 11;	/* CALL nnnn undocumented */
+				M_CALL(1);
 			}
 			break;
 		case 0xfe: i8085_ICount -= 7;	/* CPI	nn */
 			I.XX.b.l = ARG();
 			M_CMP(I.XX.b.l);
@@ -1637,11 +1659,11 @@
 				r->AF.b.l & 0x08 ? '?':'.',
 				r->AF.b.l & 0x04 ? 'P':'.',
 				r->AF.b.l & 0x02 ? 'N':'.',
 				r->AF.b.l & 0x01 ? 'C':'.');
 			break;
-		case CPU_INFO_NAME: return "I8085A";
+		case CPU_INFO_NAME: return "8085A";
 		case CPU_INFO_FAMILY: return "Intel 8080";
 		case CPU_INFO_VERSION: return "1.1";
 		case CPU_INFO_FILE: return __FILE__;
 		case CPU_INFO_CREDITS: return "Copyright (c) 1999 Juergen Buchmueller, all rights reserved.";
 		case CPU_INFO_REG_LAYOUT: return (const char *)i8085_reg_layout;
@@ -1733,11 +1755,11 @@
 void i8080_set_irq_callback(int (*callback)(int irqline)) { i8085_set_irq_callback(callback); }
 const char *i8080_info(void *context, int regnum)
 {
 	switch( regnum )
 	{
-		case CPU_INFO_NAME: return "I8080";
+		case CPU_INFO_NAME: return "8080";
 		case CPU_INFO_VERSION: return "1.2";
 		case CPU_INFO_REG_LAYOUT: return (const char *)i8080_reg_layout;
 		case CPU_INFO_WIN_LAYOUT: return (const char *)i8080_win_layout;
 	}
 	return i8085_info(context,regnum);
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/cpu/i8085/i8085cpu.h srcmess/cpu/i8085/i8085cpu.h
--- srcmess.ori/cpu/i8085/i8085cpu.h	2002-10-03 15:28:52.000000000 +0200
+++ srcmess/cpu/i8085/i8085cpu.h	2002-12-09 21:48:55.000000000 +0100
@@ -8,10 +8,13 @@
  *
  *      CPU related macros
  *
  *******************************************************/
 
+/* Set to 1 for a more exact i8080 emulation */
+#define I8080_EXACT	1
+
 #define SF              0x80
 #define ZF              0x40
 #define YF              0x20
 #define HF              0x10
 #define XF              0x08
@@ -86,32 +89,42 @@
 		(((R^I.AF.b.h^SF)&(R^q)&SF)>>5);						\
 	I.AF.b.h=q; 												\
 }
 #endif
 
+#if I8080_EXACT
+#define M_ADC(R) {						\
+	int q = I.AF.b.h+R+(I.AF.b.l&CF);			\
+	I.AF.b.l=ZSP[q&255]|((q>>8)&CF)| 			\
+		((I.AF.b.h^q^R)&HF)|				\
+		(((R^I.AF.b.h^SF)&(R^q)&SF)>>5);		\
+	I.AF.b.h=q; 						\
+}
+#else
 #ifdef X86_ASM
 #define M_ADC(R)												\
  asm (															\
  " shrb $1,%%al         \n"                                     \
  " adcb %2,%0           \n"                                     \
  " lahf                 \n"                                     \
  " setob %%al           \n" /* al = 1 if overflow */            \
  " shlb $2,%%al         \n" /* shift to P/V bit position */     \
  " andb $0xd1,%%ah      \n" /* sign, zero, half carry, carry */ \
  " orb %%ah,%%al        \n" /* combine with P/V */              \
- :"=mq" (I.AF.b.h), "=a" (I.AF.b.l)                              \
+ :"=mq" (I.AF.b.h), "=a" (I.AF.b.l)				\
  :"q" (R), "a" (I.AF.b.l), "0" (I.AF.b.h)                       \
  )
 #else
-#define M_ADC(R) {												\
-	int q = I.AF.b.h+R+(I.AF.b.l&CF);							\
-	I.AF.b.l=ZS[q&255]|((q>>8)&CF)| 							\
-		((I.AF.b.h^q^R)&HF)|									\
-		(((R^I.AF.b.h^SF)&(R^q)&SF)>>5);						\
-	I.AF.b.h=q; 												\
+#define M_ADC(R) {						\
+	int q = I.AF.b.h+R+(I.AF.b.l&CF);			\
+	I.AF.b.l=ZSP[q&255]|((q>>8)&CF)| 			\
+		((I.AF.b.h^q^R)&HF)|				\
+		(((R^I.AF.b.h^SF)&(R^q)&SF)>>5);		\
+	I.AF.b.h=q; 						\
 }
 #endif
+#endif
 
 #ifdef X86_ASM
 #define M_SUB(R)												\
  asm (															\
  " subb %2,%0           \n"                                     \
@@ -132,33 +145,43 @@
 		(((R^I.AF.b.h)&(I.AF.b.h^q)&SF)>>5);					\
 	I.AF.b.h=q; 												\
 }
 #endif
 
+#if I8080_EXACT
+#define M_SBB(R) {                                              \
+	int q = I.AF.b.h-R-(I.AF.b.l&CF);			\
+	I.AF.b.l=ZSP[q&255]|((q>>8)&CF)|NF|			\
+		((I.AF.b.h^q^R)&HF)|				\
+		(((R^I.AF.b.h)&(I.AF.b.h^q)&SF)>>5);		\
+	I.AF.b.h=q; 						\
+}
+#else
 #ifdef X86_ASM
-#define M_SBB(R)												\
- asm (															\
+#define M_SBB(R)						\
+ asm (								\
  " shrb $1,%%al         \n"                                     \
  " sbbb %2,%0           \n"                                     \
  " lahf                 \n"                                     \
  " setob %%al           \n" /* al = 1 if overflow */            \
  " shlb $2,%%al         \n" /* shift to P/V bit position */     \
  " andb $0xd1,%%ah      \n" /* sign, zero, half carry, carry */ \
  " orb $2,%%al          \n" /* set N flag */                    \
  " orb %%ah,%%al        \n" /* combine with P/V */              \
- :"=mq" (I.AF.b.h), "=a" (I.AF.b.l)                              \
+ :"=mq" (I.AF.b.h), "=a" (I.AF.b.l)				\
  :"q" (R), "a" (I.AF.b.l), "0" (I.AF.b.h)                       \
  )
 #else
 #define M_SBB(R) {                                              \
-	int q = I.AF.b.h-R-(I.AF.b.l&CF);							\
-	I.AF.b.l=ZS[q&255]|((q>>8)&CF)|NF|							\
-		((I.AF.b.h^q^R)&HF)|									\
-		(((R^I.AF.b.h)&(I.AF.b.h^q)&SF)>>5);					\
-	I.AF.b.h=q; 												\
+	int q = I.AF.b.h-R-(I.AF.b.l&CF);			\
+	I.AF.b.l=ZSP[q&255]|((q>>8)&CF)|NF|			\
+		((I.AF.b.h^q^R)&HF)|				\
+		(((R^I.AF.b.h)&(I.AF.b.h^q)&SF)>>5);		\
+	I.AF.b.h=q; 						\
 }
 #endif
+#endif
 
 #ifdef X86_ASM
 #define M_CMP(R)												\
  asm (															\
  " cmpb %2,%0          \n"                                      \
@@ -166,11 +189,11 @@
  " setob %%al          \n" /* al = 1 if overflow */             \
  " shlb $2,%%al        \n" /* shift to P/V bit position */      \
  " andb $0xd1,%%ah     \n" /* sign, zero, half carry, carry */  \
  " orb $2,%%al         \n" /* set N flag */                     \
  " orb %%ah,%%al       \n" /* combine with P/V */               \
- :"=mq" (I.AF.b.h), "=a" (I.AF.b.l)                              \
+ :"=mq" (I.AF.b.h), "=a" (I.AF.b.l)				\
  :"q" (R), "0" (I.AF.b.h)                                       \
  )
 #else
 #define M_CMP(R) {                                              \
 	int q = I.AF.b.h-R; 										\
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/cpu/m68000/make68k.c srcmess/cpu/m68000/make68k.c
--- srcmess.ori/cpu/m68000/make68k.c	2002-11-15 19:08:25.000000000 +0100
+++ srcmess/cpu/m68000/make68k.c	2003-02-12 02:11:49.000000000 +0100
@@ -188,11 +188,11 @@
 
 
 #define NORMAL 0
 #define PCREL  1
 
-#ifdef __ELF__
+#if defined(USE_OBJ_ELF)
 #define PREF ""
 #else
 #define PREF "_"
 #endif
 
@@ -249,17 +249,17 @@
 
 
 
 /* External register preservation */
 
-#ifdef DOS
+#if defined(USE_COMPILER_GNUC)
 
 /* Registers normally saved around C routines anyway */
 /* GCC 2.9.1 (dos) seems to preserve EBX,EDI and EBP */
 static char SavedRegs[] = "-B--SDB";
 
-#elif defined(WIN32)
+#elif defined(USE_COMPILER_VISUALC)
 
 /* visual C++, win32, says it preserves ebx, edi, esi, and ebp */
 /* ---------- VC++ deosn't preserve EDI? (Kenjo, 110399) ---------- */
 static char SavedRegs[] = "-B--S-B";
 
@@ -8037,11 +8037,11 @@
 	fprintf(fp, "\t\tDW   0,0,0\n\n");
 
 
 /* If Win32, put the table area in .data section (Kenjo) */
 
-#ifdef WIN32
+#if defined(USE_OS_WINDOWS)
 
 	fprintf(fp, "%s_OPCODETABLE\tTIMES  65536  DD 0\n\n", CPUtype);
 
 #else
 
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/cpu/tms9900/9900dasm.c srcmess/cpu/tms9900/9900dasm.c
--- srcmess.ori/cpu/tms9900/9900dasm.c	2000-01-29 10:44:14.000000000 +0100
+++ srcmess/cpu/tms9900/9900dasm.c	2003-02-04 04:30:39.000000000 +0100
@@ -21,10 +21,12 @@
 
 #include <stdio.h>
 #include <string.h>
 #include "memory.h"
 
+#include "tms9900.h"
+
 #define RDOP(A) (cpu_readop(A) << 8) + (cpu_readop((A+1) & 0xffff))
 #define RDWORD(A) (cpu_readop_arg(A) << 8) + (cpu_readop_arg((A+1) & 0xffff))
 
 #define BITS_0to3	((OP>>12) & 0xf)
 #define BITS_2to5	((OP>>10) & 0xf)
@@ -36,207 +38,710 @@
 #define BITS_0to4	((OP>>11) & 0x1f)
 #define BITS_0to2	((OP>>13) & 0x7)
 #define BITS_0to5	((OP>>10) & 0x3f)
 
 #define	MASK	0x0000ffff
-#define OPBITS(n1,n2)	((OP>>(15-(n2))) & (MASK>>(15-((n2)-(n1)))))
+#define BITS(val,n1,n2)	((val>>(15-(n2))) & (MASK>>(15-((n2)-(n1)))))
+
+typedef enum
+{
+	format_1,	/* 2 address instructions */
+	format_2a,	/* jump instructions */
+	format_2b,	/* bit I/O instructions */
+	format_3_9,	/* logical, multiply, and divide instructions */
+	format_4,	/* CRU instructions */
+	format_5,	/* register shift instructions */
+	format_6,	/* single address instructions */
+	format_7,	/* instructions without operands */
+	format_8a,	/* immediate instructions (destination register) */
+	format_8b,	/* immediate instructions (no destination register) */
+	format_9,	/* extended operation instruction */
+	format_10,	/* memory map file instruction */
+	format_11,	/* multiple precision instructions */
+	format_12,	/* string instructions */
+	format_13,	/* multiple precision shift instructions */
+	format_14,	/* bit testing instructions */
+	format_15,	/* invert order of field instruction */
+	format_16,	/* field instructions */
+	format_17,	/* alter register and jump instructions */
+	format_18,	/* single register operand instructions */
+	format_19,	/* move address instruction */
+	format_20,	/* list search instructions */
+	format_21,	/* extend precision instruction */
+
+	illegal
+} format_t;
+
+/* definitions for flags */
+enum
+{
+	/* processor set on which opcodes are available */
+	ps_any		= 0x01,		/* every processor in the tms9900/ti990 family */
+	ps_mapper	= 0x02,		/* processors with memory mapper (ti990/10, ti990/12,
+									and tms99000 with mapper coprocessor) */
+	ps_tms9995	= 0x04,		/* ti990/12, tms9995, and later */
+	ps_tms99000	= 0x08,		/* ti990/12, tms99000, and later */
+	ps_ti990_12	= 0x10,		/* ti990/12 only */
+
+	/* additional flags for special decoding */
+	sd_11		= 0x100,	/* bit 11 should be cleared in li, ai, andi, ori, ci, stwp, stst */
+	sd_11_15	= 0x300		/* bits 11-15 should be cleared in lwpi, limi, idle, rset, rtwp, ckon, ckof, lrex */
+};
+
+typedef struct description_t
+{
+	const char *mnemonic;
+	format_t format;
+	int flags;
+} description_t;
 
 
 enum opcodes {
+	/* basic instruction set */
 	_a=0,	_ab,	_c,		_cb,	_s,		_sb,	_soc,	_socb,	_szc,	_szcb,
 	_mov,	_movb,	_coc,	_czc,	_xor,	_mpy,	_div,	_xop,	_b,		_bl,
 	_blwp,	_clr,	_seto,	_inv,	_neg,	_abs,	_swpb,	_inc,	_inct,	_dec,
 	_dect,	_x,		_ldcr,	_stcr,	_sbo,	_sbz,	_tb,	_jeq,	_jgt,	_jh,
 	_jhe,	_jl,	_jle,	_jlt,	_jmp,	_jnc,	_jne,	_jno,	_joc,	_jop,
 	_sla,	_sra,	_src,	_srl,	_ai,	_andi,	_ci,	_li,	_ori,	_lwpi,
-	_limi,	_stst,	_stwp,	_rtwp,	_idle,	_rset,	_ckof,	_ckon,	_lrex,	_ill
+	_limi,	_stst,	_stwp,	_rtwp,	_idle,	_rset,	_ckof,	_ckon,	_lrex,
+
+	/* mapper instruction set */
+	_lds,	_ldd,	_lmf,
+
+	/* tms9995 instruction set */
+	_divs,	_mpys,	_lst,	_lwp,
+
+	/* tms99000 instruction set */
+	_bind,
+
+	/* ti990/12 instruction set */
+	_sram,	_slam,	_rto,	_lto,	_cnto,	_slsl,	_slsp,	_bdc,	_dbc,	_swpm,
+	_xorm,	_orm,	_andm,	_sm,	_am,	_mova,	_emd,	_eint,	_dint,	_stpc,
+	_cs,	_seqb,	_movs, 	_lim,	_lcs,	_blsk,	_mvsr,	_mvsk,	_pops,	_pshs,
+
+	_cri,	_cdi,	_negr,	_negd,	_cre,	_cde,	_cer,	_ced,	_nrm,	_tmb,
+	_tcmb,	_tsmb,	_srj,	_arj,	_xit,	_insf,	_xv,	_xf,	_ar,	_cir,
+	_sr,	_mr,	_dr,	_lr,	_str,	_iof,	_sneb,	_crc,	_ts,	_ad,
+	_cid,	_sd,	_md,	_dd,	_ld,	_std,	_ep,
+
+	_ill
+};
+
+
+static const description_t descriptions[144+1] =
+{
+	/* basic instruction set */
+	{ "a",		format_1,	ps_any },			{ "ab",		format_1,	ps_any },
+	{ "c",		format_1,	ps_any },			{ "cb",		format_1,	ps_any },
+	{ "s",		format_1,	ps_any },			{ "sb",		format_1,	ps_any },
+	{ "soc",	format_1,	ps_any },			{ "socb",	format_1,	ps_any },
+	{ "szc",	format_1,	ps_any },			{ "szcb",	format_1,	ps_any },
+	{ "mov",	format_1,	ps_any },			{ "movb",	format_1,	ps_any },
+	{ "coc",	format_3_9,	ps_any },			{ "czc",	format_3_9,	ps_any },
+	{ "xor",	format_3_9,	ps_any },			{ "mpy",	format_3_9,	ps_any },
+	{ "div",	format_3_9,	ps_any },			{ "xop",	format_9,	ps_any },
+	{ "b",		format_6,	ps_any },			{ "bl",		format_6,	ps_any },
+	{ "blwp",	format_6,	ps_any },			{ "clr",	format_6,	ps_any },
+	{ "seto",	format_6,	ps_any },			{ "inv",	format_6,	ps_any },
+	{ "neg",	format_6,	ps_any },			{ "abs",	format_6,	ps_any },
+	{ "swpb",	format_6,	ps_any },			{ "inc",	format_6,	ps_any },
+	{ "inct",	format_6,	ps_any },			{ "dec",	format_6,	ps_any },
+	{ "dect",	format_6,	ps_any },			{ "x",		format_6,	ps_any },
+	{ "ldcr",	format_4,	ps_any },			{ "stcr",	format_4,	ps_any },
+	{ "sbo",	format_2b,	ps_any },			{ "sbz",	format_2b,	ps_any },
+	{ "tb",		format_2b,	ps_any },			{ "jeq",	format_2a,	ps_any },
+	{ "jgt",	format_2a,	ps_any },			{ "jh",		format_2a,	ps_any },
+	{ "jhe",	format_2a,	ps_any },			{ "jl",		format_2a,	ps_any },
+	{ "jle",	format_2a,	ps_any },			{ "jlt",	format_2a,	ps_any },
+	{ "jmp",	format_2a,	ps_any },			{ "jnc",	format_2a,	ps_any },
+	{ "jne",	format_2a,	ps_any },			{ "jno",	format_2a,	ps_any },
+	{ "joc",	format_2a,	ps_any },			{ "jop",	format_2a,	ps_any },
+	{ "sla",	format_5,	ps_any },			{ "sra",	format_5,	ps_any },
+	{ "src",	format_5,	ps_any },			{ "srl",	format_5,	ps_any },
+	{ "ai",		format_8a,	ps_any|sd_11 },		{ "andi",	format_8a,	ps_any|sd_11 },
+	{ "ci",		format_8a,	ps_any|sd_11 },		{ "li",		format_8a,	ps_any|sd_11 },
+	{ "ori",	format_8a,	ps_any|sd_11 },		{ "lwpi",	format_8b,	ps_any|sd_11_15 },
+	{ "limi",	format_8b,	ps_any|sd_11_15 },	{ "stst",	format_18,	ps_any|sd_11 },
+	{ "stwp",	format_18,	ps_any|sd_11 },		{ "rtwp",	format_7,	ps_any|sd_11_15 },
+	{ "idle",	format_7,	ps_any|sd_11_15 },	{ "rset",	format_7,	ps_any|sd_11_15 },
+	{ "ckof",	format_7,	ps_any|sd_11_15 },	{ "ckon",	format_7,	ps_any|sd_11_15 },
+	{ "lrex",	format_7,	ps_any|sd_11_15 },	
+
+	/* mapper instruction set */
+	{ "lds",	format_6,	ps_mapper },		{ "ldd",	format_6,	ps_mapper },
+	{ "lmf",	format_10,	ps_mapper },
+
+	/* tms9995 instruction set */
+	{ "divs",	format_6,	ps_tms9995 },		{ "mpys",	format_6,	ps_tms9995 },
+	{ "lst",	format_18,	ps_tms9995 },		{ "lwp",	format_18,	ps_tms9995 },
+
+	/* tms99000 instruction set */
+	{ "bind",	format_6,	ps_tms99000 },
+
+	/* ti990/12 instruction set */
+	{ "sram",	format_13,	ps_ti990_12 },		{ "slam",	format_13,	ps_ti990_12 },
+	{ "rto",	format_11,	ps_ti990_12 },		{ "lto",	format_11,	ps_ti990_12 },
+	{ "cnto",	format_11,	ps_ti990_12 },		{ "slsl",	format_20,	ps_ti990_12 },
+	{ "slsp",	format_20,	ps_ti990_12 },		{ "bdc",	format_11,	ps_ti990_12 },
+	{ "dbc",	format_11,	ps_ti990_12 },		{ "swpm",	format_11,	ps_ti990_12 },
+	{ "xorm",	format_11,	ps_ti990_12 },		{ "orm",	format_11,	ps_ti990_12 },
+	{ "andm",	format_11,	ps_ti990_12 },		{ "sm",		format_11,	ps_ti990_12 },
+	{ "am",		format_11,	ps_ti990_12 },		{ "mova",	format_19,	ps_ti990_12 },
+	{ "emd",	format_7,	ps_ti990_12 },		{ "eint",	format_7,	ps_ti990_12 },
+	{ "dint",	format_7,	ps_ti990_12 },		{ "stpc",	format_18,	ps_ti990_12 },
+	{ "cs",		format_12,	ps_ti990_12 },		{ "seqb",	format_12,	ps_ti990_12 },
+	{ "movs", 	format_12,	ps_ti990_12 },		{ "lim",	format_18,	ps_ti990_12 },
+	{ "lcs",	format_18,	ps_ti990_12 },		{ "blsk",	format_8a,	ps_ti990_12 },
+	{ "mvsr",	format_12,	ps_ti990_12 },		{ "mvsk",	format_12,	ps_ti990_12 },
+	{ "pops",	format_12,	ps_ti990_12 },		{ "pshs",	format_12,	ps_ti990_12 },
+	{ "cri",	format_7,	ps_ti990_12 },		{ "cdi",	format_7,	ps_ti990_12 },
+	{ "negr",	format_7,	ps_ti990_12 },		{ "negd",	format_7,	ps_ti990_12 },
+	{ "cre",	format_7,	ps_ti990_12 },		{ "cde",	format_7,	ps_ti990_12 },
+	{ "cer",	format_7,	ps_ti990_12 },		{ "ced",	format_7,	ps_ti990_12 },
+	{ "nrm",	format_11,	ps_ti990_12 },		{ "tmb",	format_14,	ps_ti990_12 },
+	{ "tcmb",	format_14,	ps_ti990_12 },		{ "tsmb",	format_14,	ps_ti990_12 },
+	{ "srj",	format_17,	ps_ti990_12 },		{ "arj",	format_17,	ps_ti990_12 },
+	{ "xit",	format_7,	ps_ti990_12 },		{ "insf",	format_16,	ps_ti990_12 },
+	{ "xv",		format_16,	ps_ti990_12 },		{ "xf",		format_16,	ps_ti990_12 },
+	{ "ar",		format_6,	ps_ti990_12 },		{ "cir",	format_6,	ps_ti990_12 },
+	{ "sr",		format_6,	ps_ti990_12 },		{ "mr",		format_6,	ps_ti990_12 },
+	{ "dr",		format_6,	ps_ti990_12 },		{ "lr",		format_6,	ps_ti990_12 },
+	{ "str",	format_6,	ps_ti990_12 },		{ "iof",	format_15,	ps_ti990_12 },
+	{ "sneb",	format_12,	ps_ti990_12 },		{ "crc",	format_12,	ps_ti990_12 },
+	{ "ts",		format_12,	ps_ti990_12 },		{ "ad",		format_6,	ps_ti990_12 },
+	{ "cid",	format_6,	ps_ti990_12 },		{ "sd",		format_6,	ps_ti990_12 },
+	{ "md",		format_6,	ps_ti990_12 },		{ "dd",		format_6,	ps_ti990_12 },
+	{ "ld",		format_6,	ps_ti990_12 },		{ "std",	format_6,	ps_ti990_12 },
+	{ "ep",		format_21,	ps_ti990_12 },
+
+	{ NULL,		illegal,	ps_any }
+};
+
+
+static const enum opcodes ops_4000_ffff_s12[12]=
+{
+	_szc,	_szcb,	_s,		_sb,									/*4000-7000*/
+	_c,		_cb,	_a,		_ab,	_mov,	_movb,	_soc,	_socb	/*8000-f000*/
+};
+
+
+static const enum opcodes ops_2000_3fff_s10[8]=
+{
+	_coc,	_czc,	_xor,	_xop,	_ldcr,	_stcr,	_mpy,	_div	/*2000-3800*/
+};
+
+
+static const enum opcodes ops_1000_1fff_s8[16]=
+{
+	_jmp,	_jlt,	_jle,	_jeq,	_jhe,	_jgt,	_jne,	_jnc,	/*1000-1700*/
+	_joc,	_jno,	_jl,	_jh,	_jop,	_sbo,	_sbz,	_tb		/*1800-1f00*/
+};
+
+
+static const enum opcodes ops_0e40_0fff_s6[7]=
+{
+			_ad,	_cid,	_sd,	_md,	_dd,	_ld,	_std	/*0e40-0fc0*/
+};
+
+
+static const enum opcodes ops_0e00_0e3f_s4[4]=
+{
+	_iof,	_sneb,	_crc,	_ts										/*0e00-0e30*/
+};
+
+
+static const enum opcodes ops_0c40_0dff_s6[7]=
+{
+			_ar,	_cir,	_sr,	_mr,	_dr,	_lr,	_str	/*0c40-0dc0*/
+};
+
+
+static const enum opcodes ops_0c10_0c3f_s4[3]=
+{
+			_insf,	_xv,	_xf										/*0c10-0c30*/
 };
 
 
-static const char *token[]=
+static const enum opcodes ops_0c00_0c0f_s0[16]=
 {
-	"a",	"ab",	"c",	"cb",	"s",	"sb",	"soc",	"socb",	"szc",	"szcb",
-	"mov",	"movb",	"coc",	"czc",	"xor",	"mpy",	"div",	"xop",	"b",	"bl",
-	"blwp",	"clr",	"seto",	"inv",	"neg",	"abs",	"swpb",	"inc",	"inct",	"dec",
-	"dect",	"x",	"ldcr",	"stcr",	"sbo",	"sbz",	"tb",	"jeq",	"jgt",	"jh",
-	"jhe",	"jl",	"jle",	"jlt",	"jmp",	"jnc",	"jne",	"jno",	"joc",	"jop",
-	"sla",	"sra",	"src",	"srl",	"ai",	"andi",	"ci",	"li",	"ori",	"lwpi",
-	"limi",	"stst",	"stwp",	"rtwp",	"idle",	"rset",	"ckof",	"ckon",	"lrex",	"ill"
+	_cri,	_cdi,	_negr,	_negd,	_cre,	_cde,	_cer,	_ced,	/*0c00-0c07*/
+	_nrm,	_tmb,	_tcmb,	_tsmb,	_srj,	_arj,	_xit,	_xit	/*0c08-0c0f*/
 };
 
 
-static const enum opcodes ops0to3[16]=
+
+static const enum opcodes ops_0800_0bff_s8[4]=
+{
+	_sra,	_srl,	_sla,	_src									/*0800-0b00*/
+};
+
+
+static const enum opcodes ops_0400_07ff_s6[16]=
 {
-	_ill,	_ill,	_ill,	_ill,	_szc,	_szcb,	_s,		_sb,	/*0000-0111*/
-	_c,		_cb,	_a,		_ab,	_mov,	_movb,	_soc,	_socb	/*1000-1111*/
+	_blwp,	_b,		_x,		_clr,	_neg,	_inv,	_inc,	_inct,	/*0400-05c0*/
+	_dec,	_dect,	_bl,	_swpb,	_seto,	_abs,	_lds,	_ldd	/*0600-07c0*/
 };
 
 
-static const enum opcodes ops2to5[16]=
+static const enum opcodes ops_0200_03ff_s5[16]=
 {
-	_ill,	_ill,	_ill,	_ill,	_ill,	_ill,	_ill,	_ill,	/*0000-0111*/
-	_coc,	_czc,	_xor,	_xop,	_ldcr,	_stcr,	_mpy,	_div	/*1000-1111*/
+	_li,	_ai,	_andi,	_ori,	_ci,	_stwp,	_stst,	_lwpi,	/*0200-02e0*/
+	_limi,	_lmf,	_idle,	_rset,	_rtwp,	_ckon,	_ckof,	_lrex	/*0300-03e0*/
 };
 
 
-static const enum opcodes ops5to9[32]=
+static const enum opcodes ops_0100_01ff_s6[4]=
 {
-	_ill,	_ill,	_ill,	_ill,	_ill,	_ill,	_ill,	_ill,	/*00000-00111*/
-	_ill,	_ill,	_ill,	_ill,	_ill,	_ill,	_ill,	_ill,	/*01000-01111*/
-	_blwp,	_b,		_x,		_clr,	_neg,	_inv,	_inc,	_inct,	/*10000-10111*/
-	_dec,	_dect,	_bl,	_swpb,	_seto,	_abs,	_ill,	_ill	/*11000-11111*/
+	_ill,	_bind,	_divs,	_mpys									/*0100-01c0*/
 };
 
 
-static const enum opcodes ops3to7[32]=
+static const enum opcodes ops_0030_00ff_s4[13]=
 {
-	_ill,	_ill,	_ill,	_ill,	_ill,	_ill,	_ill,	_ill,	/*00000-00111*/
-	_sra,	_srl,	_sla,	_src,	_ill,	_ill,	_ill,	_ill,	/*01000-01111*/
-	_jmp,	_jlt,	_jle,	_jeq,	_jhe,	_jgt,	_jne,	_jnc,	/*10000-10111*/
-	_joc,	_jno,	_jl,	_jh,	_jop,	_sbo,	_sbz,	_tb		/*11000-11111*/
+							_stpc,	_cs,	_seqb,	_movs,	_lim,	/*0030-0070*/
+	_lst,	_lwp,	_lcs,	_blsk,	_mvsr,	_mvsk,	_pops,	_pshs	/*0080-00f0*/
 };
 
 
-static const enum opcodes ops6to10[32]=
+static const enum opcodes ops_001c_002f_s0[20]=
 {
-	_ill,	_ill,	_ill,	_ill,	_ill,	_ill,	_ill,	_ill,	/*00000-00111*/
-	_ill,	_ill,	_ill,	_ill,	_ill,	_ill,	_ill,	_ill,	/*01000-01111*/
-	_li,	_ai,	_andi,	_ori,	_ci,	_stwp,	_stst,	_lwpi,	/*10000-10111*/
-	_limi,	_ill,	_idle,	_rset,	_rtwp,	_ckon,	_ckof,	_lrex	/*11000-11111*/
+									_sram,	_slam,	_rto,	_lto,	/*001c-001f*/
+	_cnto,	_slsl,	_slsp,	_bdc,	_dbc,	_swpm,	_xorm,	_orm,	/*0020-0027*/
+	_andm,	_sm,	_am,	_mova,	_ill,	_emd,	_eint,	_dint	/*0028-002f*/
 };
 
+
+
 static int PC;
 
 
-static char *print_arg (int mode, int arg)
+static int print_arg (char *dest, int mode, int arg)
 {
-	static char temp[20];
 	int	base;
 
 	switch (mode)
 	{
 		case 0x0:	/* workspace register */
-			sprintf (temp, "R%d", arg);
+			return sprintf (dest, "R%d", arg);
 			break;
 		case 0x1:	/* workspace register indirect */
-			sprintf (temp, "*R%d", arg);
+			return sprintf (dest, "*R%d", arg);
 			break;
 		case 0x2:	/* symbolic|indexed */
 			base = RDWORD(PC); PC+=2;
 			if (arg) 	/* indexed */
-				sprintf (temp, "@>%04x(R%d)", base, arg);
+				return sprintf (dest, "@>%04x(R%d)", base, arg);
 			else		/* symbolic (direct) */
-				sprintf (temp, "@>%04x", base);
+				return sprintf (dest, "@>%04x", base);
 			break;
 		case 0x3:	/* workspace register indirect auto increment */
-			sprintf (temp, "*R%d+", arg);
+			return sprintf (dest, "*R%d+", arg);
 			break;
 	}
-	return temp;
+
+	return 0;
 }
 
 
 /*****************************************************************************
  *	Disassemble a single command and return the number of bytes it uses.
  *****************************************************************************/
-int Dasm9900 (char *buffer, int pc)
+unsigned Dasm9900 (char *buffer, unsigned pc, int model_id)
 {
-	int	OP, opc;
+	int	OP, OP2, opc;
 	int sarg, darg, smode, dmode;
+	signed char displacement;
+	int byte_count, checkpoint;
+	int bit_position, bit_width;
+
+	const char *mnemonic;
+	format_t format;
+	int flags;
+
+	/*
+		Under tms9900, opcodes >0400->07FF are incompletely decoded: bits 11 is ignored, and so are
+		bits 12-15 for instructions which do not require a register.  On the other hand, ti990/10
+		generates an illegal instruction error when bit 11 is set, but still ignores bits 12-15.
+		Additionnally, ti990/12 and tms9995 will generate an illegal error when bits 12-15 are
+		non-zero.
+	*/
+	#define BETTER_0200_DECODING (model_id == TI990_10_ID)
+	#define COMPLETE_0200_DECODING (/*(model_id == TI990_12_ID) ||*/ (model_id >= TMS9995_ID))
+
+	int processor_mask = ps_any;
+
+	if ((model_id == TI990_10_ID) /*|| (model_id == TI990_12_ID)*/ || (model_id >= TMS99000_ID))
+		processor_mask |= ps_mapper;		/* processors with memory mapper (ti990/10, ti990/12,
+												and tms99000 with mapper coprocessor) */
+	if (/*(model_id == TI990_12_ID) ||*/ (model_id >= TMS9995_ID))
+		processor_mask |= ps_tms9995;		/* ti990/12, tms9995, and later */
+
+	if (/*(model_id == TI990_12_ID) ||*/ (model_id >= TMS99000_ID))
+		processor_mask |= ps_tms99000;		/* ti990/12, tms99000, and later */
+
+	/*if ((model_id == TI990_12_ID))
+		processor_mask |= ps_ti990_12;*/	/* ti990/12, tms99000, and later */
 
 	PC = pc;
-	OP = RDOP(PC); PC+=2;
+ 	OP = RDOP(PC); PC+=2;
 
-	if ((opc = ops0to3[BITS_0to3]) != _ill)
+	/* let's identify the opcode */
+	if (OP >= 0x4000)
+		opc = ops_4000_ffff_s12[(OP - 0x4000) >> 12];
+	else if (OP >= 0x2000)
+		opc = ops_2000_3fff_s10[(OP - 0x2000) >> 10];
+	else if (OP >= 0x1000)
+		opc = ops_1000_1fff_s8[(OP - 0x1000) >> 8];
+	else if (OP >= 0x0C00)
+	{
+		if (OP >= 0x0E40)
+			opc = ops_0e40_0fff_s6[(OP - 0x0E40) >> 6];
+		else if (OP >= 0x0E00)
+			opc = ops_0e00_0e3f_s4[(OP - 0x0E00) >> 4];
+		else if (OP >= 0x0C40)
+			opc = ops_0c40_0dff_s6[(OP - 0x0C40) >> 6];
+		else if (OP >= 0x0C10)
+			opc = ops_0c10_0c3f_s4[(OP - 0x0C10) >> 4];
+		else
+			opc = ops_0c00_0c0f_s0[OP - 0x0C00];
+	}
+	else if (OP >= 0x0800)
+		opc = ops_0800_0bff_s8[(OP - 0x0800) >> 8];
+	else if (OP >= 0x0400)
+		opc = ops_0400_07ff_s6[(OP - 0x0400) >> 6];
+	else if (OP >= 0x0200)
 	{
-		smode = OPBITS(10,11);
-		sarg = OPBITS(12,15);
-		dmode = OPBITS(4,5);
-		darg = OPBITS(6,9);
+		opc = ops_0200_03ff_s5[(OP - 0x0200) >> 5];
+		if (BETTER_0200_DECODING || COMPLETE_0200_DECODING)
+		{
+			flags = descriptions[opc].flags;
+			if ( (COMPLETE_0200_DECODING && (flags & sd_11_15) && (OP & 0x001f))
+					|| ((flags & sd_11) && (OP & 0x0010)) )
+			{
+				opc = _ill;
+				if (OP >= 0x03f0)
+					opc = _ep;	/* the ep opcode is located in a "hole" */
+			}
+		}
+	}
+	else if (OP >= 0x0100)
+		opc = ops_0100_01ff_s6[(OP - 0x0100) >> 6];
+	else if (OP >= 0x0030)
+		opc = ops_0030_00ff_s4[(OP - 0x0030) >> 4];
+	else if (OP >= 0x001C)
+		opc = ops_001c_002f_s0[OP - 0x001C];
+	else
+		opc = _ill;
 
- 		sprintf (buffer, "%-4s ", token[opc]);
-		strcat (buffer, print_arg (smode, sarg));
-		strcat (buffer, ",");
-		strcat (buffer, print_arg (dmode, darg));
+	/* read flags */
+	flags = descriptions[opc].flags;
+	/* set as illegal if the processor does not implement this instruction */
+	if (! (flags & processor_mask))
+	{
+		opc = _ill;
+		flags = descriptions[opc].flags;	/* read new flags */
 	}
-	else if (BITS_0to1==0 && (opc = ops2to5[BITS_2to5]) != _ill)
+
+	mnemonic = descriptions[opc].mnemonic;
+	format = descriptions[opc].format;
+
+	switch (format)
 	{
-		smode = OPBITS(10,11);
-		sarg = OPBITS(12,15);
-		darg = OPBITS(6,9);
+	case format_1:		/* 2 address instructions */
+		smode = BITS(OP,10,11);
+		sarg = BITS(OP,12,15);
+		dmode = BITS(OP,4,5);
+		darg = BITS(OP,6,9);
+
+		buffer += sprintf (buffer, "%-4s ", mnemonic);
+		buffer += print_arg (buffer, smode, sarg);
+		buffer += sprintf (buffer, ",");
+		buffer += print_arg (buffer, dmode, darg);
+		break;
+
+	case format_2a:		/* jump instructions */
+		displacement = (signed char)BITS(OP,8,15);
+		sprintf (buffer, "%-4s >%04x", mnemonic, 0xffff & (PC + displacement * 2));
+		break;
+
+	case format_2b:		/* bit I/O instructions */
+		displacement = (signed char)BITS(OP,8,15);
+		sprintf (buffer, "%-4s >%04x", mnemonic, 0xffff & displacement);
+		break;
+
+	case format_3_9:	/* logical, multiply, and divide instructions */
+	case format_4:		/* CRU instructions */
+	case format_9:		/* extended operation instruction */
+		smode = BITS(OP,10,11);
+		sarg = BITS(OP,12,15);
+		darg = BITS(OP,6,9);
 
-		if (darg==0 && (opc==_ldcr || opc==_stcr))
+		if (darg==0 && (format == format_4))
 			darg = 16;
 
-		if (opc==_xop || opc==_ldcr || opc==_stcr)
-			sprintf (buffer, "%-4s %s,%d", token[opc], print_arg (smode, sarg), darg);
-		else	/* _coc, _czc, _xor, _mpy, _div */
-			sprintf (buffer, "%-4s %s,R%d", token[opc], print_arg (smode, sarg), darg);
-	}
-	else if (BITS_0to2==0 && (opc = ops3to7[BITS_3to7]) != _ill)
-	{
-		switch (opc)
+		if (format == format_3_9)
 		{
-			case _sra: case _srl: case _sla: case _src:
-				sarg = OPBITS(12,15);
-				darg = OPBITS(8,11);
-
-				sprintf (buffer, "%-4s R%d,%d", token[opc], sarg, darg);
-				break;
-			case _jmp: case _jlt: case _jle: case _jeq: case _jhe: case _jgt:
-			case _jne: case _jnc: case _joc: case _jno: case _jl:  case _jh: case _jop:
-				{
-					signed char displacement;
-
-					displacement = (signed char)OPBITS(8,15);
-					sprintf (buffer, "%-4s >%04x", token[opc], 0xffff & (PC + displacement * 2));
-				}
-				break;
-			case _sbo: case _sbz: case _tb:
-				{
-					signed char displacement;
-
-					displacement = (signed char)OPBITS(8,15);
-					sprintf (buffer, "%-4s >%04x", token[opc], 0xffff & displacement);
-				}
-				break;
+			buffer += sprintf (buffer, "%-4s ", mnemonic);
+			buffer += print_arg (buffer, smode, sarg);
+			buffer += sprintf (buffer, ",R%d", darg);
 		}
-	}
-	else if (BITS_0to4==0 && (opc = ops5to9[BITS_5to9]) != _ill)
-	{
-		smode = OPBITS(10,11);
-		sarg = OPBITS(12,15);
+		else
+		{
+			buffer += sprintf (buffer, "%-4s ", mnemonic);
+			buffer += print_arg (buffer, smode, sarg);
+			buffer += sprintf (buffer, ",%d", darg);
+		}
+		break;
 
-		sprintf (buffer, "%-4s %s", token[opc], print_arg (smode, sarg));
-	}
-	else if (BITS_0to5==0 && (opc = ops6to10[BITS_6to10]) != _ill)
-	{
-		switch (opc)
+	case format_5:		/* register shift instructions */
+		sarg = BITS(OP,12,15);
+		darg = BITS(OP,8,11);
+
+		sprintf (buffer, darg ? "%-4s R%d,%d" : "%-4s R%d,R%d", mnemonic, sarg, darg);
+		break;
+
+	case format_6:		/* single address instructions */
+		smode = BITS(OP,10,11);
+		sarg = BITS(OP,12,15);
+
+		buffer += sprintf (buffer, "%-4s ", mnemonic);
+		buffer += print_arg (buffer, smode, sarg);
+		break;
+
+	case format_7:		/* instructions without operands */
+		sprintf (buffer, "%s", mnemonic);
+		break;
+
+	case format_8a:		/* immediate instructions (destination register) */
+		darg = BITS(OP,12,15);
+		sarg = RDWORD(PC); PC+=2;
+
+		sprintf (buffer, "%-4s R%d,>%04x", mnemonic, darg, sarg);
+		break;
+
+	case format_8b:		/* immediate instructions (no destination register) */
+		sarg = RDWORD(PC); PC+=2;
+
+		sprintf (buffer, "%-4s >%04x", mnemonic, sarg);
+		break;
+
+	case format_10:		/* memory map file instruction */
+		sarg = BITS(OP,12,15);
+		darg = BITS(OP,11,11);
+
+		sprintf (buffer, "%-4s R%d,%d", mnemonic, sarg, darg);
+		break;
+
+	case format_11:		/* multiple precision instructions */
+		OP2 = RDOP(PC); PC+=2;
+
+		smode = BITS(OP2,10,11);
+		sarg = BITS(OP2,12,15);
+		dmode = BITS(OP2,4,5);
+		darg = BITS(OP2,6,9);
+		byte_count = BITS(OP2,0,3);
+
+		buffer += sprintf (buffer, "%-4s ", mnemonic);
+		buffer += print_arg (buffer, smode, sarg);
+		buffer += sprintf (buffer, ",");
+		buffer += print_arg (buffer, dmode, darg);
+		buffer += sprintf (buffer, byte_count ? ",%d" : ",R%d", byte_count);
+		break;
+
+	case format_12:		/* string instructions */
+		OP2 = RDOP(PC); PC+=2;
+
+		smode = BITS(OP2,10,11);
+		sarg = BITS(OP2,12,15);
+		dmode = BITS(OP2,4,5);
+		darg = BITS(OP2,6,9);
+		byte_count = BITS(OP2,0,3);
+		checkpoint = BITS(OP,12,15);
+
+		buffer += sprintf (buffer, "%-4s ", mnemonic);
+		buffer += print_arg (buffer, smode, sarg);
+		buffer += sprintf (buffer, ",");
+		buffer += print_arg (buffer, dmode, darg);
+		buffer += sprintf (buffer, byte_count ? ",%d,R%d" : ",R%d,R%d", byte_count, checkpoint);
+		break;
+
+	case format_13:		/* multiple precision shift instructions */
+		OP2 = RDOP(PC); PC+=2;
+
+		smode = BITS(OP2,10,11);
+		sarg = BITS(OP2,12,15);
+		darg = BITS(OP2,6,9);
+		byte_count = BITS(OP2,0,3);
+
+		buffer += sprintf (buffer, "%-4s ", mnemonic);
+		buffer += print_arg (buffer, smode, sarg);
+		buffer += sprintf (buffer, byte_count ? ",%d" : ",R%d", byte_count);
+		buffer += sprintf (buffer, darg ? ",%d" : ",R%d", darg);
+		break;
+
+	case format_14:		/* bit testing instructions */
+		OP2 = RDOP(PC); PC+=2;
+
+		smode = BITS(OP2,10,11);
+		sarg = BITS(OP2,12,15);
+		darg = BITS(OP2,0,9);
+
+		buffer += sprintf (buffer, "%-4s ", mnemonic);
+		buffer += print_arg (buffer, smode, sarg);
+		if (darg == 0x3ff)
+			buffer += sprintf (buffer, ",R0");
+		else
+			buffer += sprintf (buffer, ",%d", darg);
+		break;
+
+	case format_15:		/* invert order of field instruction */
+		OP2 = RDOP(PC); PC+=2;
+
+		smode = BITS(OP2,10,11);
+		sarg = BITS(OP2,12,15);
+		bit_position = BITS(OP2,0,3);
+		bit_width = BITS(OP,12,15);
+
+		buffer += sprintf (buffer, "%-4s ", mnemonic);
+		buffer += print_arg (buffer, smode, sarg);
+		buffer += sprintf (buffer, bit_position ? ",(%d," : ",(R%d,", bit_position);
+		buffer += sprintf (buffer, bit_width ? "%d)" : "R%d)", bit_width);
+		break;
+
+	case format_16:		/* field instructions */
+		OP2 = RDOP(PC); PC+=2;
+
+		smode = BITS(OP2,10,11);
+		sarg = BITS(OP2,12,15);
+		dmode = BITS(OP2,4,5);
+		darg = BITS(OP2,6,9);
+		bit_position = BITS(OP2,0,3);
+		bit_width = BITS(OP,12,15);
+
+		buffer += sprintf (buffer, "%-4s ", mnemonic);
+		buffer += print_arg (buffer, smode, sarg);
+		buffer += sprintf (buffer, ",");
+		buffer += print_arg (buffer, dmode, darg);
+		buffer += sprintf (buffer, bit_position ? ",(%d," : ",(%d,", bit_position);
+		buffer += sprintf (buffer, bit_width ? "%d)" : "R%d)", bit_width);
+		break;
+
+	case format_17:		/* alter register and jump instructions */
+		OP2 = RDOP(PC); PC+=2;
+
+		displacement = (signed char)BITS(OP2,8,15);
+		sarg = BITS(OP2,4,7);
+		darg = BITS(OP2,0,3);
+		if (darg)
+		sprintf (buffer, darg ? "%-4s >%04x,%d,R%d" : "%-4s >%04x,R%d,R%d",
+							mnemonic, 0xffff & (PC + displacement * 2), sarg, darg);
+		break;
+
+	case format_18:		/* single register operand instructions */
+		sarg = BITS(OP,12,15);
+
+		sprintf (buffer, "%-4s R%d", mnemonic, sarg);
+		break;
+
+	case format_19:		/* move address instruction */
+		OP2 = RDOP(PC); PC+=2;
+
+		smode = BITS(OP2,10,11);
+		sarg = BITS(OP2,12,15);
+		dmode = BITS(OP2,4,5);
+		darg = BITS(OP2,6,9);
+
+		buffer += sprintf (buffer, "%-4s ", mnemonic);
+		buffer += print_arg (buffer, smode, sarg);
+		buffer += sprintf (buffer, ",");
+		buffer += print_arg (buffer, dmode, darg);
+		break;
+
+	case format_20:		/* list search instructions */
 		{
-			case _li:   case _ai:   case _andi: case _ori:  case _ci:
-				darg = OPBITS(12,15);
-				sarg = RDWORD(PC); PC+=2;
+			const char *condition_code;
 
-				sprintf (buffer, "%-4s R%d,>%04x", token[opc], darg, sarg);
-				break;
-			case _lwpi: case _limi:
-				sarg = RDWORD(PC); PC+=2;
+			OP2 = RDOP(PC); PC+=2;
 
-				sprintf (buffer, "%-4s >%04x", token[opc], sarg);
+			smode = BITS(OP2,10,11);
+			sarg = BITS(OP2,12,15);
+			dmode = BITS(OP2,4,5);
+			darg = BITS(OP2,6,9);
+
+			switch (BITS(OP2,0,3))
+			{
+			case 0:
+				condition_code = "eq";
 				break;
-			case _stwp: case _stst:
-				sarg = OPBITS(12,15);
-
-				sprintf (buffer, "%-4s R%d", token[opc], sarg);
+			case 1:
+				condition_code = "ne";
+				break;
+			case 2:
+				condition_code = "he";
+				break;
+			case 3:
+				condition_code = "l";
+				break;
+			case 4:
+				condition_code = "ge";
+				break;
+			case 5:
+				condition_code = "lt";
+				break;
+			case 6:
+				condition_code = "le";
 				break;
-			case _idle: case _rset: case _rtwp: case _ckon: case _ckof: case _lrex:
-				sprintf (buffer, "%-4s", token[opc]);
+			case 7:
+				condition_code = "h";
 				break;
+			case 8:
+				condition_code = "lte";
+				break;
+			case 9:
+				condition_code = "gt";
+				break;
+			default:
+				condition_code = "??";
+				break;
+			}
+
+			buffer += sprintf (buffer, "%-4s %s,", mnemonic, condition_code);
+			buffer += print_arg (buffer, smode, sarg);
+			buffer += sprintf (buffer, ",");
+			buffer += print_arg (buffer, dmode, darg);
+			break;
 		}
+
+	case format_21:		/* extend precision instruction */
+	{
+		int dest_byte_count;
+
+		OP2 = RDOP(PC); PC+=2;
+
+		smode = BITS(OP2,10,11);
+		sarg = BITS(OP2,12,15);
+		dmode = BITS(OP2,4,5);
+		darg = BITS(OP2,6,9);
+		byte_count = BITS(OP2,0,3);
+		dest_byte_count = BITS(OP,12,15);
+
+		buffer += sprintf (buffer, "%-4s ", mnemonic);
+		buffer += print_arg (buffer, smode, sarg);
+		buffer += sprintf (buffer, ",");
+		buffer += print_arg (buffer, dmode, darg);
+		buffer += sprintf (buffer, byte_count ? ",%d" : ",R%d", byte_count);
+		buffer += sprintf (buffer, dest_byte_count ? ",%d" : ",R%d", dest_byte_count);
+		break;
 	}
-	else
+
+	default:
+		logerror("debbugger internal error, file %s, line %d\n", __FILE__, __LINE__);
+	case illegal:
 		sprintf (buffer, "data >%04x", OP);
+		break;
+	}
 
 	return PC - pc;
 }
 
 
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/cpu/tms9900/99xxcore.h srcmess/cpu/tms9900/99xxcore.h
--- srcmess.ori/cpu/tms9900/99xxcore.h	2002-02-16 12:55:18.000000000 +0100
+++ srcmess/cpu/tms9900/99xxcore.h	2003-01-20 11:28:40.000000000 +0100
@@ -1,64 +1,94 @@
 /*
 	99xxcore.h : generic tms99xx emulation
 
-	The TMS99XX_MODEL switch tell which emulator we want to build.  Set the switch, then include
-	99xxcore.h, and you will have an emulator for this processor.
+	The TMS99XX_MODEL switch tells which emulator we want to build.  Set the
+	switch, then include 99xxcore.h, and you will have an emulator for this
+	processor.
 
-	Only tms9900, tms9980a/9981, and tms9995 work OK for now.  Note that tms9995 has not been tested
-	extensively.
+	Only ti990/10, tms9900, tms9980a/9981, and tms9995 work OK for now.  Note
+	that tms9995 has not been tested extensively.
 
-	I think all software aspects of tms9940, tms9985 and tms9989 are implemented (though there
-	must be some mistakes, particularily in tms9940 BCD support).  You'll just have to implement
-	bus interfaces, provided you know them.  (I don't...)
+	tms9940 is WIP: it is probably still buggy (particularily the BCD support),
+	as it has not been tested.  tms9985 has been implemented as a 9940 with
+	a data bus, which should be mostly correct.
+
+	I think all software aspects of tms9985 and tms9989 are implemented.
+	You just need to implement bus interfaces, provided you know them.
+	(I don't...)
+
+	tms99000 cannot be implemented fully yet, due to lack of documentation.
+
+	ti990/12 is not supported at all, and it should probably be implemented as
+	a separate processor core, anyway.
 
 	Original tms9900 emulator by Edward Swartz
 	Smoothed out by Raphael Nabet
 	Originally converted for Mame by M.Coates
 	Processor timing, support for tms9980 and tms9995, and many bug fixes by R Nabet
 */
 
 /*
-	tms9900 is derived from the TI990/x minicomputer series (with multi-chip processors, except with
-	cheaper or later models, which used microprocessors).  However, tms99xx (and even extension-less
-	tms99xxx) only implement a reduced subset of the huge instruction set available on big TI990
-	systems.
-
-	AFAIK, tms9900, tms9980, and tms9985 have exactly the same programming model, and are actually
-	the same CPU with different bus interfaces.  The former affirmation is (almost) true with
-	tms9940, so I guess the later is true, too.  (The only problem with tms9940 is I have no idea
-	what its bus interfaces are - I have a pinout, but it does not help much, although it is obvious
-	that the beast is a microcontroller.)  tms9985 had on-chip RAM and timer, like tms9995, although
-	I don't know how the memory and CRU were mapped exactly.
-
-	tms9989 is mostly alien to me.  I assumed it was more related to tms9900 than tms9995, although
-	it has most of the additionnal features tms9995 has.
-
-	tms9995 belongs to another generation.  As a matter of fact, it quite faster than tms9900.
-
-	tms99xxx include all tms9995 advances, and add some advances of their own.  I know they support
-	many extra opcodes (84 instructions types on tms99105a, vs. 69 on tms9900), and support
-	privileges (i.e. supervisor mode), flags in multiprocessor environment, 32-bit operations...
-	There was yet other features (Macrostore to define custom instructions, op code compression...),
-	which are completely alien to me.
-
-	I have written code to recognize every tms99xxx opcode, and all other TI990 instructions I have
-	heard of.  I cannot complete this code, since I have no documentation on tms99xxx.  I am not
-	even sure the instruction set I guessed for tms99xxx is correct.  Also, the proposed meaning for
-	these extra memnonics could be wrong.
+	The first member of the family was actually the ti990/10 minicomputer,
+	released in 1975.  tms9900 was released in 1976, and has the same
+	instruction set as ti990/10: however, tms9900 is slower, it does not
+	support privileges and memory mapping, and illegal instructions do not
+	cause an error interrupt.
+
+	The ti990 family later evoluted into the huge ti990/12 system, with support
+	for 144 different instructions, and microcode programming in case some user
+	found it was not enough.  ti990/10 was eventually replaced by a cheaper
+	ti990/10a board, built around a tms99000 microprocessor.
+
+	The tms9980 processor is merely a tms9900 with a 8-bit data bus (instead of
+	16-bit on tms9900).
+
+	tms9940 is a microcontroller, and is mostly similar to 9900/9980.  The
+	variant I know has 2kb of ROM, 128 bytes of RAM, a timer, 32 I/O line, some
+	of which can be reconfigured as a CRU bus, but no external memory bus.  It
+	includes three additional opcodes, which are not supported by any other
+	member of the family (with the probable exception of TMS9985).
+
+	tms9985 is similar to tms9940, but it supports an external 8-bit-wide
+	memory bus.  At least one variant included 8kb of ROM, 256 bytes of RAM.
+	It was ill-fated, as it was never released due to technical problems.
+
+	tms9989 is mostly alien to me.  I guess it is a close relative of tms9995,
+	although I am not sure.  I have read that the SBP68689 supports tms9995
+	opcodes, but that tms9989 does not.
+
+	tms9995 belongs to another generation.  It is quite faster than tms9900,
+	and supports 4 extra opcodes.  Its external bus is 8-bit-wide, and it has
+	256 bytes of internal 16-bit RAM.
+
+	tms99000 is the successor to both ti9900 and ti990/10.  It supports
+	privileges, and has a coprocessor interface which enables the use of an
+	external memory mapper.  Additionnally,  it can use a Macrostore ROM to
+	emulate additional instructions.
+
+	This feature allowed TI to expand the 99000 family with the tms99105 (which
+	was said to support 84 instructions types), the tms99110 (which supported
+	floating point instructions), and possibly another chip (tms99220???) which
+	included parts of the UCSD P-system in Macrostore.
 
 References :
 * 9900 family systems design, chapter 6, 7, 8
 * TMS 9980A/ TMS 9981 Product Data Book
 * TMS 9995 16-Bit Microcomputer Data Manual
+* Model 990/10A computer general description, section 4 (p/n 2302633-9701 A)
+* 990/99000 assembly language reference manual (p/n 2270509-9701 A)
+* Chapter 18 of unidentified book is the only reference on tms9940 I have found so far (Paperport format)
+	<ftp://ftp.whtech.com//datasheets/Hardware manuals/tms9900 9901 9904 9940 9980 (by a osborne).max>
+
+Other references can be found on spies.com:
+<http://www.spies.com/arcade/simulation/processors/index.html>
+<http://www.spies.com/~aek/pdf/ti/>
 
-Tons of thanks to the guy who posted these, whoever he is...
-<http://www.stormaster.com/Spies/arcade/simulation/processors/index.html>
 */
 
 /* Set this to 1 to support HOLD_LINE */
-/* This is a weird HOLD_LINE, actually : we hold the interrupt line only until IAQ
+/* This is a weird HOLD_LINE, actually: we hold the interrupt line only until IAQ
 	(instruction acquisition) is enabled.  Well, this scheme could possibly exist on
 	a tms9900-based system, unlike a real HOLD_LINE.  (OK, this is just a pretext, I was just too
 	lazy to implement a true HOLD_LINE ;-) .) */
 /* BTW, this only works with tms9900 ! */
 #define SILLY_INTERRUPT_HACK 0
@@ -72,11 +102,33 @@
 #include "mamedbg.h"
 #include "tms9900.h"
 #include <math.h>
 
 
-#if (TMS99XX_MODEL == TMS9900_ID)
+#if (TMS99XX_MODEL == TI990_10_ID)
+
+	/*#define TMS99XX_PREFIX ti990_10
+	#define TMS99XX_ICOUNT TMS99XX_PREFIX##_ICount	// generates TMS99XX_PREFIX_ICount
+	#define dummy(a) a
+	#define TMS99XX_ICOUNT dummy(TMS99XX_PREFIX)##_ICount	// generates ti990_10_ICount*/
+
+	#define TMS99XX_ICOUNT ti990_10_ICount
+	#define TMS99XX_INIT ti990_10_init
+	#define TMS99XX_RESET ti990_10_reset
+	#define TMS99XX_EXIT ti990_10_exit
+	#define TMS99XX_EXECUTE ti990_10_execute
+	#define TMS99XX_GET_CONTEXT ti990_10_get_context
+	#define TMS99XX_SET_CONTEXT ti990_10_set_context
+	#define TMS99XX_GET_REG ti990_10_get_reg
+	#define TMS99XX_SET_REG ti990_10_set_reg
+	#define TMS99XX_SET_IRQ_CALLBACK ti990_10_set_irq_callback
+	#define TMS99XX_INFO ti990_10_info
+	#define TMS99XX_DASM ti990_10_dasm
+
+	#define TMS99XX_CPU_NAME "TI990/10"
+
+#elif (TMS99XX_MODEL == TMS9900_ID)
 
 	#define TMS99XX_ICOUNT tms9900_ICount
 	#define TMS99XX_INIT tms9900_init
 	#define TMS99XX_RESET tms9900_reset
 	#define TMS99XX_EXIT tms9900_exit
@@ -180,59 +232,129 @@
 	#define TMS99XX_INFO tms9995_info
 	#define TMS99XX_DASM tms9995_dasm
 
 	#define TMS99XX_CPU_NAME "TMS9995"
 
-#elif (TMS99XX_MODEL == TMS99105A_ID)
+#elif (TMS99XX_MODEL == TMS99000_ID)
 
-	#define TMS99XX_ICOUNT tms99105a_ICount
-	#define TMS99XX_INIT tms99105a_init
-	#define TMS99XX_RESET tms99105a_reset
-	#define TMS99XX_EXIT tms99105a_exit
-	#define TMS99XX_EXECUTE tms99105a_execute
-	#define TMS99XX_GET_CONTEXT tms99105a_get_context
-	#define TMS99XX_SET_CONTEXT tms99105a_set_context
-	#define TMS99XX_GET_REG tms99105a_get_reg
-	#define TMS99XX_SET_REG tms99105a_set_reg
-	#define TMS99XX_SET_IRQ_CALLBACK tms99105a_set_irq_callback
-	#define TMS99XX_INFO tms99105a_info
-	#define TMS99XX_DASM tms99105a_dasm
-
-	#define TMS99XX_CPU_NAME "TMS99105A"
-
-	#error "tms99105a is not yet supported"
-
-#elif (TMS99XX_MODEL == TMS99110A_ID)
-
-	#define TMS99XX_ICOUNT tms99110a_ICount
-	#define TMS99XX_INIT tms99110a_init
-	#define TMS99XX_RESET tms99110a_reset
-	#define TMS99XX_EXIT tms99110a_exit
-	#define TMS99XX_EXECUTE tms99110a_execute
-	#define TMS99XX_GET_CONTEXT tms99110a_get_context
-	#define TMS99XX_SET_CONTEXT tms99110a_set_context
-	#define TMS99XX_GET_REG tms99110a_get_reg
-	#define TMS99XX_SET_REG tms99110a_set_reg
-	#define TMS99XX_SET_IRQ_CALLBACK tms99110a_set_irq_callback
-	#define TMS99XX_INFO tms99110a_info
-	#define TMS99XX_DASM tms99110a_dasm
+	#define TMS99XX_ICOUNT tms99000_ICount
+	#define TMS99XX_INIT tms99000_init
+	#define TMS99XX_RESET tms99000_reset
+	#define TMS99XX_EXIT tms99000_exit
+	#define TMS99XX_EXECUTE tms99000_execute
+	#define TMS99XX_GET_CONTEXT tms99000_get_context
+	#define TMS99XX_SET_CONTEXT tms99000_set_context
+	#define TMS99XX_GET_REG tms99000_get_reg
+	#define TMS99XX_SET_REG tms99000_set_reg
+	#define TMS99XX_SET_IRQ_CALLBACK tms99000_set_irq_callback
+	#define TMS99XX_INFO tms99000_info
+	#define TMS99XX_DASM tms99000_dasm
 
-	#define TMS99XX_CPU_NAME "TMS99110A"
+	#define TMS99XX_CPU_NAME "TMS99000"
 
-	#error "tms99110a is not yet supported"
+	#error "tms99000 is not yet supported"
 
 #endif
 
 
+/*
+	I include this macro because we may eventually support other 99000 variants such as tms99110,
+	and this macro will remain true for every 99000 family member, even when we have
+	(TMS99XX_MODEL != TMS99000_ID).
+*/
+#define IS_99000 (TMS99XX_MODEL == TMS99000_ID)
+
+/*
+	On microprocessor implementations (other than TMS9940 and, probably, TMS9985), the CKOF, CKON,
+	IDLE, LREX and RSET cause an external CRU write.  CKOF, CKON and LREX do nothing apart of this,
+	therefore they must be implemented with external hardware (CKON and CKOF are supposed to
+	enable/disable a line clock interrupt, and LREX to trigger a LOAD interrupt).  IDLE and RSET
+	are functional, but, on the one hand, the design allowed to light a diagnostic LED when
+	the processor is in IDLE state, and, on the other hand, the RSET instruction is supposed
+	to reset external devices as well.
+
+	On the TI990/10 and TI990/12 minicomputers, there is no such CRU write.  The line clock
+	interrupt latch is part of the CPU board, LREX is fully functional, the IDLE led is connected
+	to the board, and the RSET line is part of the TILINE bus connector.
+
+	On the TMS9940, CKOF, CKON, LREX and RSET are not supported.  IDLE, on the other hand, is
+	supported, and the CPU can be configured to output its IDLE state on the P16 I/O pin.
+*/
+#define EXTERNAL_INSTRUCTION_DECODING (TMS99XX_MODEL != TI990_10_ID) && (TMS99XX_MODEL != TI9940_ID) && (TMS99XX_MODEL != TI9985_ID)
+#define EXTERNAL_INSTRUCTION_CALLBACK (TMS99XX_MODEL == TI990_10_ID)
+
+/*
+	ti990/10, ti990/12 and tms99000 support privileges
+
+	privileged instructions:
+	CKOF, CKON, IDLE, LIMI, LREX, RSET,
+	LDD, LDS, LMF, (memory mapping instructions)
+	DINT, EINT, EMD , LCS, LIM, SLSP. (990/12 instructions)
+
+	instructions which are privileged when the effective CRU address is higher than 0xE00:
+	LDCR, SBO, SBZ, STCR, TB.
+
+	instructions whose behaviour is modified in user mode (only user flags in ST are affected):
+	RTWP,
+	LST. (ti990/12 and tms99000 instruction)
+*/
+#define HAS_PRIVILEGE ((TMS99XX_MODEL == TI990_10_ID) || IS_99000)
+
+/*
+	opcode groups
+
+	* 69 basic opcodes implemented on all family members
+	* 3 memory mapping opcodes implemented on ti990/10 with mapping option, ti990/12, and
+	  the tim99610 mapper in conjunction with any tms99000 family member: LMF, LDS, LDD
+	* 3 opcodes implemented on tms9940 (and probably tms9985) only: DCA, DCS, LIIM
+	* 4 opcodes implemented on ti990/12, tms9989 and above: MPYS, DIVS, LST, LWP
+	* 1 opcode implemented on ti990/12, and tms99000: BIND
+	* 72 opcodes implemented on ti990/12 only (some of which are emulated by tms99105 & tms99110)
+*/
+
+#define HAS_MAPPING ((TMS99XX_MODEL == TI990_10_ID) /*|| IS_99000*/)
+#define HAS_9995_OPCODES ((TMS99XX_MODEL == TMS9989_ID) || (TMS99XX_MODEL == TMS9995_ID) || IS_99000)
+#define HAS_BIND_OPCODE IS_99000
+
+#define HAS_OVERFLOW_INTERRUPT ((TMS99XX_MODEL == TMS9995_ID) || IS_99000)
+
+/*
+	Under tms9900, opcodes >0200->03FF are incompletely decoded: bits 11 is ignored, and so are
+	bits 12-15 for instructions which do not require a register.  On the other hand, ti990/10
+	generates an illegal instruction error when bit 11 is set, but still ignores bits 12-15.
+	Additionally, ti990/12 and tms9995 will generate an illegal error when bits 12-15 are
+	non-zero.
+*/
+#define BETTER_0200_DECODING (TMS99XX_MODEL == TI990_10_ID)
+#define COMPLETE_0200_DECODING (TMS99XX_MODEL >= TMS9995_ID)
+
+/*
+	TI990/10 and tms9900 force unused bits in the ST register to 0.
+	TMS9995 does not.
+*/
+#define USE_ST_MASK (TMS99XX_MODEL <= TMS9985_ID)
+
+/*
+	TI990/10, TMS9900 and TMS99000 have a 16-bit-wide memory bus, and use 16-bus accessors.
+	TMS9940 use 16-bit accessors, too, as it has an internal 16-bit bus, and no external bus.
+*/
+#define USE_16_BIT_ACCESSORS ((TMS99XX_MODEL == TI990_10_ID) || (TMS99XX_MODEL == TMS9900_ID) || (TMS99XX_MODEL == TMS9940_ID) || (IS_99000))
+
+
 INLINE void execute(UINT16 opcode);
 
+#if EXTERNAL_INSTRUCTION_DECODING
 static void external_instruction_notify(int ext_op_ID);
-static UINT16 fetch(void);
+#endif
 static UINT16 decipheraddr(UINT16 opcode);
 static UINT16 decipheraddrbyte(UINT16 opcode);
 static void contextswitch(UINT16 addr);
-
+#if HAS_MAPPING || HAS_PRIVILEGE
+static void contextswitchX(UINT16 addr);
+#else
+#define contextswitchX(addr) contextswitch(addr)
+#endif
 static void field_interrupt(void);
 
 /***************************/
 /* Mame Interface Routines */
 /***************************/
@@ -282,41 +404,80 @@
 /* This bit is set by the XOP instruction. */
 #define ST_X   0x0200 /* Xop */
 
 #endif
 
-#if (TMS99XX_MODEL == TMS9940_ID)
+#if (TMS99XX_MODEL == TMS9940_ID) || (TMS99XX_MODEL == TMS9985_ID)
 
 /* This bit is set by arithmetic operations to support BCD */
 #define ST_DC  0x0100 /* Digit Carry */
 
 #endif
 
-#if (TMS99XX_MODEL == TMS99105A_ID)
+#if HAS_PRIVILEGE
 
 /* This bit is set in user (i.e. non-supervisor) mode */
-#define ST_PRIVILEGED 0x0100
+#define ST_PR  0x0100 /* PRivilege */
+
+#endif
+
+#if HAS_MAPPING
+
+/* This tells which map is currently in use */
+#define ST_MF  0x0080 /* Map File */
+
+#endif
+
+#if (HAS_OVERFLOW_INTERRUPT)
+
+/* This bit is set in ti990/12, TMS9995 and later chips to generate a level-2 interrupt when
+the Overflow status bit is set */
+#define ST_OVIE 0x0020 /* OVerflow Interrupt Enable */
 
 #endif
 
-#if (TMS99XX_MODEL >= TMS9995_ID)
+#if (IS_99000)
 
-/* This bit is set in TMS9995 and later chips to generate a level-2 interrupt when the Overflow
-status bit is set */
-#define ST_OV_EN 0x0020 /* OVerflow interrupt ENable */
+/* This bit enables the macrostore feature on tms99000 */
+/* (It is used on ti990/12 with a different meaning.) */
+#define ST_EMR 0x0010 /* Enable Macrostore Rom */
+
+#endif
+
+#if (TMS99XX_MODEL == TMS9940_ID) || (TMS99XX_MODEL == TMS9985_ID)
+
+#define ST_IM 0x0003 /* Interrupt Mask */
+
+#else
+
+#define ST_IM 0x000F /* Interrupt Mask */
 
 #endif
 
 /* On models before TMS9995 (TMS9989 ?), unused ST bits are always forced to 0, so we define
 a ST_MASK */
-#if TMS99XX_MODEL == TMS9940_ID
+#if (USE_ST_MASK)
+	#if (TMS99XX_MODEL == TI990_10_ID)
+		#define ST_MASK 0xFF8F
+	#elif (TMS99XX_MODEL == TMS9940_ID) || (TMS99XX_MODEL == TMS9985_ID)
+		#define ST_MASK 0xFD03
+	#else
+		#define ST_MASK 0xFE0F
+	#endif
+#endif
 
-#define ST_MASK 0xFD03
 
-#elif TMS99XX_MODEL <= TMS9985_ID
+/* error interrupt register bits */
 
-#define ST_MASK 0xFE0F
+#if (TMS99XX_MODEL == TI990_10_ID)
+
+/* This bit is set in user (i.e. non-supervisor) mode */
+#define EIR_MAPERR	0x0800	/* memory MAPping ERRor */
+#define EIR_MER		0x1000	/* Memory parity ERRor */
+#define EIR_ILLOP	0x2000	/* ILLegal OPcode */
+#define EIR_PRIVOP	0x4000	/* PRiviledged OPeration */
+#define EIR_TIMEOUT	0x8000	/* TILINE TIMEOUT */
 
 #endif
 
 
 /* Offsets for registers. */
@@ -335,10 +496,16 @@
 #define R12 24
 #define R13 26
 #define R14 28
 #define R15 30
 
+typedef struct map_file_t
+{
+	UINT16 L[3], B[3];			/* actual registers */
+	unsigned limit[3], bias[3];	/* equivalent in a more convenient form */
+} map_file_t;
+
 typedef struct
 {
 /* "actual" tms9900 registers : */
 	UINT16 WP;  /* Workspace pointer */
 	UINT16 PC;  /* Program counter */
@@ -347,18 +514,21 @@
 /* Now, data used for emulation */
 	UINT16 IR;  /* Instruction register, with the currently parsed opcode */
 
 	int interrupt_pending;  /* true if an interrupt must be honored... */
 
+#if ! ((TMS99XX_MODEL == TMS9940_ID) || (TMS99XX_MODEL == TMS9985_ID))
 	int load_state; /* nonzero if the LOAD* line is active (low) */
+#endif
 
-#if ((TMS99XX_MODEL == TMS9900_ID) || (TMS99XX_MODEL == TMS9980_ID))
+#if (TMS99XX_MODEL == TI990_10_ID) || ((TMS99XX_MODEL == TMS9900_ID) || (TMS99XX_MODEL == TMS9980_ID))
 	/* On tms9900, we cache the state of INTREQ* and IC0-IC3 here */
 	/* On tms9980/9981, we translate the state of IC0-IC2 to the equivalent state for a tms9900,
 	and store the result here */
 	int irq_level;	/* when INTREQ* is active, interrupt level on IC0-IC3 ; else always 16 */
 	int irq_state;	/* nonzero if the INTREQ* line is active (low) */
+					/* with TMS9940, bit 0 means INT1, bit 1 decrementer, bit 2 INT2 */
 #elif (TMS99XX_MODEL == TMS9995_ID)
 	/* tms9995 is quite different : it latches the interrupt inputs */
 	int irq_level;    /* We store the level of the request with the highest level here */
 	int int_state;    /* interrupt lines state */
 	int int_latch;	  /* interrupt latches state */
@@ -374,64 +544,336 @@
 
 #ifdef MAME_DEBUG
 	UINT16 FR[16];  /* contains a copy of the workspace for the needs of the debugger */
 #endif
 
+#if HAS_MAPPING
+	int mapping_on;			/* set by a CRU write */
+	map_file_t map_files[3];	/* internal mapper registers */
+	int cur_map;			/* equivalent to ST_MF status bit */
+	int cur_src_map;		/* set to 2 by LDS */
+	int cur_dst_map;		/* set to 2 by LDD */
+
+#if (TMS99XX_MODEL == TI990_10_ID)
+	int reset_maperr;		/* reset mapper error flag line (reset flags in 945417-9701 p. 3-90) */
+
+	UINT32 mapper_address_latch;	/* used to load the map file and for diagnostic purpose */
+	int mapper_cru_read_register;	/* read register select code for mapper cru interface */
+	int diaglat;					/* set when diagnostic address latch is done */
+	int latch_control[3];			/* latch control */
+
+#endif
+#endif
+
+#if (TMS99XX_MODEL == TI990_10_ID)
+	UINT16 error_interrupt_register;	/* one flag for each interrupt condition */
+	void (*error_interrupt_callback)(int state);
+#endif
+
 #if (TMS99XX_MODEL == TMS9985_ID) || (TMS99XX_MODEL == TMS9995_ID)
-	unsigned char RAM[256]; /* on-chip RAM (yes, sir !) */
+	unsigned char RAM[256]; /* on-chip RAM (I know this is weird, but the internal bus is 16-bit-wide, whereas the external bus is 8-bit-wide) */
 #endif
 
-#if (TMS99XX_MODEL == TMS9995_ID)
+#if (TMS99XX_MODEL == TMS9940_ID) || (TMS99XX_MODEL == TMS9985_ID) || (TMS99XX_MODEL == TMS9995_ID)
 	/* on-chip event counter/timer*/
 	int decrementer_enabled;
 	UINT16 decrementer_interval;
 	UINT16 decrementer_count;	/* used in event counter mode*/
 	void *timer;  /* used in timer mode */
 #endif
 
 #if (TMS99XX_MODEL == TMS9995_ID)
 	/* additionnal registers */
-	UINT16 flag; 	  /* flag register */
+	UINT16 flag;    /* flag register */
 	int MID_flag;   /* MID flag register */
-#endif
 
-#if (TMS99XX_MODEL == TMS9995_ID)
 	/* chip config, which can be set on reset */
 	int memory_wait_states_byte;
 	int memory_wait_states_word;
 #endif
-}	tms99xx_Regs;
+
+	/* Some instructions (i.e. XOP, BLWP, and MID) disable interrupt recognition until another
+	instruction is executed : so they set this flag */
+	int disable_interrupt_recognition;
+
+	/* notify the driver of changes in IDLE state */
+	void (*idle_callback)(int state);
+
+#if EXTERNAL_INSTRUCTION_CALLBACK
+	void (*rset_callback)(void);
+	void (*lrex_callback)(void);
+	void (*ckon_ckof_callback)(int state);
+#endif
+
+} tms99xx_Regs;
 
 static tms99xx_Regs I =
 {
 	0,0,0,0,  /* don't care */
 	0,        /* no pending interrupt */
 	0,        /* LOAD* inactive */
-  16, 0,    /* INTREQ* inactive */
+	16, 0,    /* INTREQ* inactive */
 };
 static UINT8 lastparity;  /* rather than handling ST_OP directly, we copy the last value which
                                   would set it here */
-/* Some instructions (i.e. XOP, BLWP, and MID) disable interrupt recognition until another
-instruction is executed : so they set this flag */
-static int disable_interrupt_recognition = 0;
+
+static char lds_flag, ldd_flag;
 
 #if (TMS99XX_MODEL == TMS9995_ID)
 static void reset_decrementer(void);
 #endif
 
-#if (TMS99XX_MODEL == TMS9900_ID)
-	/*16-bit data bus, 16-bit address bus*/
+
+#if (TMS99XX_MODEL == TI990_10_ID)
+
+/*
+	accessor for the internal ROM
+*/
+READ16_HANDLER(ti990_10_internal_r)
+{
+	//return I.ROM[offset];
+	return cpu_readmem24bew_word(0x1ffc00+offset);
+}
+
+#endif
+
+#if (TMS99XX_MODEL == TMS9995_ID)
+
+/*
+	accessor for the first 252 bytes of internal RAM
+*/
+READ_HANDLER(tms9995_internal1_r)
+{
+	return I.RAM[offset];
+}
+
+WRITE_HANDLER(tms9995_internal1_w)
+{
+	I.RAM[offset]=data;
+}
+
+/*
+	accessor for the last 4 bytes of internal RAM
+*/
+READ_HANDLER(tms9995_internal2_r)
+{
+	return I.RAM[offset+0xfc];
+}
+
+WRITE_HANDLER(tms9995_internal2_w)
+{
+	I.RAM[offset+0xfc]=data;
+}
+
+#endif
+
+#if (TMS99XX_MODEL == TI990_10_ID)
+
+	/* on-board ROMs are not emulated (we use a hack) */
+
+	static int write_inhibit;
+
+	#define readword(addr) readwordX((addr), I.cur_map)
+	static int readwordX(int addr, int map_file)
+	{
+		if ((map_file == 0) && (addr >= 0xf800))
+		{	/* intercept TPCS and CPU ROM */
+			if (addr < 0xfc00)
+				/* TPCS */
+				return cpu_readmem24bew_word(0x1f0000+addr);
+			else
+				/* CPU ROM */
+				return cpu_readmem24bew_word(0x1f0000+addr);	/* hack... */
+		}
+		else if (! I.mapping_on)
+		{
+			return cpu_readmem24bew_word(addr);
+		}
+		else
+		{
+			int map_index;
+
+			if (addr <= I.map_files[map_file].limit[0])
+				map_index = 0;
+			else if (addr <= I.map_files[map_file].limit[1])
+				map_index = 1;
+			else if (addr <= I.map_files[map_file].limit[2])
+				map_index = 2;
+			else
+			{	/* mapping error */
+				if ((! (I.error_interrupt_register & EIR_MAPERR)) && ! (I.diaglat))
+					I.mapper_address_latch = addr;
+				if ((! I.reset_maperr) && ! (I.error_interrupt_register & EIR_MAPERR))
+				{
+					I.error_interrupt_register |= EIR_MAPERR;
+					write_inhibit = 1;
+				}
+				return cpu_readmem24bew_word(addr);
+			}
+			if ((! (I.error_interrupt_register & EIR_MAPERR)) && ! (I.diaglat))
+				I.mapper_address_latch = I.map_files[map_file].bias[map_index]+addr;
+			if ((I.latch_control[map_index]) && (! I.reset_maperr))
+				I.diaglat = 1;
+			return cpu_readmem24bew_word(I.map_files[map_file].bias[map_index]+addr);
+		}
+	}
+
+	#define writeword(addr, data) writewordX((addr), (data), I.cur_map)
+	static void writewordX(int addr, int data, int map_file)
+	{
+		if ((map_file == 0) && (addr >= 0xf800))
+		{	/* intercept TPCS and CPU ROM */
+			if (addr < 0xfc00)
+				/* TPCS */
+				cpu_writemem24bew_word(0x1f0000+addr, data);
+			else
+				/* CPU ROM */
+				cpu_writemem24bew_word(0x1f0000+addr, data);	/* hack... */
+		}
+		else if (! I.mapping_on)
+		{
+			cpu_writemem24bew_word(addr, data);
+		}
+		else
+		{
+			int map_index;
+
+			if (addr <= I.map_files[map_file].limit[0])
+				map_index = 0;
+			else if (addr <= I.map_files[map_file].limit[1])
+				map_index = 1;
+			else if (addr <= I.map_files[map_file].limit[2])
+				map_index = 2;
+			else
+			{	/* mapping error */
+				if ((! (I.error_interrupt_register & EIR_MAPERR)) && ! (I.diaglat))
+					I.mapper_address_latch = addr;
+				if ((! I.reset_maperr) && ! (I.error_interrupt_register & EIR_MAPERR))
+				{
+					I.error_interrupt_register |= EIR_MAPERR;
+					write_inhibit = 1;
+				}
+				if (write_inhibit)
+					(void)cpu_readmem24bew_word(addr);
+				else
+					cpu_writemem24bew_word(addr, data);
+				return;
+			}
+			if ((! (I.error_interrupt_register & EIR_MAPERR)) && ! (I.diaglat))
+				I.mapper_address_latch = I.map_files[map_file].bias[map_index]+addr;
+			if ((I.latch_control[map_index]) && (! I.reset_maperr))
+				I.diaglat = 1;
+			cpu_writemem24bew_word(I.map_files[map_file].bias[map_index]+addr, data);
+		}
+	}
+
+	#define readbyte(addr) readbyteX((addr), I.cur_map)
+	static int readbyteX(int addr, int map_file)
+	{
+		if ((map_file == 0) && (addr >= 0xf800))
+		{	/* intercept TPCS and CPU ROM */
+			if (addr < 0xfc00)
+				/* TPCS */
+				return cpu_readmem24bew(0x1f0000+addr);
+			else
+				/* CPU ROM */
+				return cpu_readmem24bew(0x1f0000+addr);	/* hack... */
+		}
+		else if (! I.mapping_on)
+		{
+			return cpu_readmem24bew(addr);
+		}
+		else
+		{
+			int map_index;
+
+			if (addr <= I.map_files[map_file].limit[0])
+				map_index = 0;
+			else if (addr <= I.map_files[map_file].limit[1])
+				map_index = 1;
+			else if (addr <= I.map_files[map_file].limit[2])
+				map_index = 2;
+			else
+			{	/* mapping error */
+				if ((! (I.error_interrupt_register & EIR_MAPERR)) && ! (I.diaglat))
+					I.mapper_address_latch = addr;
+				if ((! I.reset_maperr) && ! (I.error_interrupt_register & EIR_MAPERR))
+				{
+					I.error_interrupt_register |= EIR_MAPERR;
+					write_inhibit = 1;
+				}
+				return cpu_readmem24bew(addr);
+			}
+			if ((! (I.error_interrupt_register & EIR_MAPERR)) && ! (I.diaglat))
+				I.mapper_address_latch = I.map_files[map_file].bias[map_index]+addr;
+			if ((I.latch_control[map_index]) && (! I.reset_maperr))
+				I.diaglat = 1;
+			return cpu_readmem24bew(I.map_files[map_file].bias[map_index]+addr);
+		}
+	}
+
+	#define writebyte(addr, data) writebyteX((addr), (data), I.cur_map)
+	static void writebyteX(int addr, int data, int map_file)
+	{
+		if ((map_file == 0) && (addr >= 0xf800))
+		{	/* intercept TPCS and CPU ROM */
+			if (addr < 0xfc00)
+				/* TPCS */
+				cpu_writemem24bew(0x1f0000+addr, data);
+			else
+				/* CPU ROM */
+				cpu_writemem24bew(0x1f0000+addr, data);	/* hack... */
+		}
+		else if (! I.mapping_on)
+		{
+			cpu_writemem24bew(addr, data);
+		}
+		else
+		{
+			int map_index;
+
+			if (addr <= I.map_files[map_file].limit[0])
+				map_index = 0;
+			else if (addr <= I.map_files[map_file].limit[1])
+				map_index = 1;
+			else if (addr <= I.map_files[map_file].limit[2])
+				map_index = 2;
+			else
+			{	/* mapping error */
+				if ((! (I.error_interrupt_register & EIR_MAPERR)) && ! (I.diaglat))
+					I.mapper_address_latch = addr;
+				if ((! I.reset_maperr) && ! (I.error_interrupt_register & EIR_MAPERR))
+				{
+					I.error_interrupt_register |= EIR_MAPERR;
+					write_inhibit = 1;
+				}
+				if (write_inhibit)
+					(void)cpu_readmem24bew(addr);
+				else
+					cpu_writemem24bew(addr, data);
+				return;
+			}
+			if ((! (I.error_interrupt_register & EIR_MAPERR)) && ! (I.diaglat))
+				I.mapper_address_latch = I.map_files[map_file].bias[map_index]+addr;
+			if ((I.latch_control[map_index]) && (! I.reset_maperr))
+				I.diaglat = 1;
+			cpu_writemem24bew(I.map_files[map_file].bias[map_index]+addr, data);
+		}
+	}
+
+#elif (TMS99XX_MODEL == TMS9900_ID) || (TMS99XX_MODEL == TMS9940_ID)
+	/*16-bit data bus, 16-bit address bus (internal bus in the case of TMS9940)*/
 	/*Note that tms9900 actually never accesses a single byte : when performing byte operations,
 	it reads a 16-bit word, changes the revelant byte, then write a complete word.  You should
 	remember this when writing memory handlers.*/
 	/*This does not apply to tms9995 and tms99xxx, but does apply to tms9980 (see below).*/
 
 	#define readword(addr)        cpu_readmem16bew_word(addr)
 	#define writeword(addr,data)  cpu_writemem16bew_word((addr), (data))
 
 	#define readbyte(addr)        cpu_readmem16bew(addr)
-	#define writebyte(addr,data)  cpu_writemem16bew((addr),(data))
+	#define writebyte(addr,data)  cpu_writemem16bew((addr), (data))
 
 #elif (TMS99XX_MODEL == TMS9980_ID)
 	/*8-bit data bus, 14-bit address*/
 	/*Note that tms9980 never accesses a single byte (however crazy it may seem).  Although this
 	makes memory access slower, I have emulated this feature, because if I did otherwise,
@@ -447,12 +889,12 @@
 #if 0
 	#define readbyte(addr)        (TMS99XX_ICOUNT -= 2, cpu_readmem14(addr))
 	#define writebyte(addr,data)  { TMS99XX_ICOUNT -= 2; cpu_writemem14((addr),(data)); }
 #else
 	/*This is how it really works*/
-	/*Note that every writebyte must match a readbyte (which is the case on a real-world tms9980)*/
-	static int extra_byte;
+	/*Note that every writebyte must match a readbyte (which is indeed the case)*/
+	static int extra_byte;	/* buffer holding the unused byte in a word read */
 
 	static int readbyte(int addr)
 	{
 		TMS99XX_ICOUNT -= 2;
 		if (addr & 1)
@@ -465,30 +907,102 @@
 			int val = cpu_readmem14(addr);
 			extra_byte = cpu_readmem14(addr+1);
 			return val;
 		}
 	}
-	static void writebyte (int addr, int data)
+	static void writebyte(int addr, int data)
 	{
 		TMS99XX_ICOUNT -= 2;
 		if (addr & 1)
 		{
-			extra_byte = cpu_readmem14(addr-1);
-
 			cpu_writemem14(addr-1, extra_byte);
 			cpu_writemem14(addr, data);
 		}
 		else
 		{
-			extra_byte = cpu_readmem14(addr+1);
-
 			cpu_writemem14(addr, data);
 			cpu_writemem14(addr+1, extra_byte);
 		}
 	}
 #endif
 
+#elif (TMS99XX_MODEL == TMS9985_ID)
+	/*Note that every writebyte must match a readbyte (which is indeed the case)*/
+	static int extra_byte;	/* buffer holding the unused byte in a word read */
+
+	static int readword(int addr)
+	{
+		if (addr < 0x2000)
+		{
+		}
+		else if ((addr >= 0x8300) && (addr < 0x8400))
+		{
+		}
+		else
+		{
+			TMS99XX_ICOUNT -= 2;
+			return (cpu_readmem16(addr) << 8) + cpu_readmem16(addr + 1);
+		}
+	}
+	static void writeword(int addr, int data)
+	{
+		if ((addr >= 0x8300) && (addr < 0x8400))
+		{
+		}
+		else if (!(addr < 0x2000))
+		{
+			TMS99XX_ICOUNT -= 2;
+			cpu_writemem16(addr, data >> 8);
+			cpu_writemem16(addr + 1, data & 0xff);
+		}
+	}
+
+	static int readbyte(int addr)
+	{
+		if (addr < 0x2000)
+		{
+		}
+		else if ((addr >= 0x8300) && (addr < 0x8400))
+		{
+		}
+		else
+		{
+			TMS99XX_ICOUNT -= 2;
+			if (addr & 1)
+			{
+				extra_byte = cpu_readmem14(addr-1);
+				return cpu_readmem14(addr);
+			}
+			else
+			{
+				int val = cpu_readmem14(addr);
+				extra_byte = cpu_readmem14(addr+1);
+				return val;
+			}
+		}
+	}
+	static void writebyte(int addr, int data)
+	{
+		if ((addr >= 0x8300) && (addr < 0x8400))
+		{
+		}
+		else if (!(addr < 0x2000))
+		{
+			TMS99XX_ICOUNT -= 2;
+			if (addr & 1)
+			{
+				cpu_writemem14(addr-1, extra_byte);
+				cpu_writemem14(addr, data);
+			}
+			else
+			{
+				cpu_writemem14(addr, data);
+				cpu_writemem14(addr+1, extra_byte);
+			}
+		}
+	}
+
 #elif (TMS99XX_MODEL == TMS9995_ID)
 	/*8-bit external data bus, with on-chip 16-bit RAM, and 16-bit address bus*/
 	/*The code is complex, so we use functions rather than macros*/
 
 	static int readword(int addr)
@@ -524,11 +1038,11 @@
 		{
 			return *(UINT16 *)(& I.RAM[addr - 0xff00]);
 		}
 	}
 
-	static void writeword (int addr, int data)
+	static void writeword(int addr, int data)
 	{
 		if (addr < 0xf000)
 		{
 			TMS99XX_ICOUNT -= I.memory_wait_states_word;
 			cpu_writemem16(addr, data >> 8);
@@ -596,11 +1110,11 @@
 		{
 			return I.RAM[BYTE_XOR_BE(addr - 0xff00)];
 		}
 	}
 
-	static void writebyte (int addr, int data)
+	static void writebyte(int addr, int data)
 	{
 		if (addr < 0xf000)
 		{
 			TMS99XX_ICOUNT -= I.memory_wait_states_byte;
 			cpu_writemem16(addr, data);
@@ -631,31 +1145,135 @@
 
 	#error "memory access not implemented"
 
 #endif
 
-#define READREG(reg)          readword(I.WP+reg)
-#define WRITEREG(reg,data)    writeword(I.WP+reg,data)
+#if !HAS_MAPPING
+	#define readwordX(addr, map_file) readword(addr)
+	#define writewordX(addr, data, map_file) writeword((addr), (data))
+	#define readbyteX(addr, map_file) readbyte(addr)
+	#define writebyteX(addr, data, map_file) writebyte((addr), (data))
+#endif
+
+#define READREG(reg)         readword((I.WP+(reg)) & 0xffff)
+#define WRITEREG(reg, data)  writeword((I.WP+(reg)) & 0xffff, (data))
+
+#if (TMS99XX_MODEL == TI990_10_ID)
+	READ16_HANDLER(ti990_10_mapper_cru_r)
+	{
+		int reply = 0;
+
+		switch(I.mapper_cru_read_register)
+		{
+		case 0xb000:
+			reply = I.map_files[I.cur_map].B[0];
+			break;
+		case 0xb001:
+			reply = I.map_files[I.cur_map].B[1];
+			break;
+		case 0xb010:
+			reply = I.map_files[I.cur_map].B[2];
+			break;
+		case 0xb011:
+			reply = I.map_files[I.cur_map].L[0];
+			break;
+		case 0xb100:
+			reply = I.map_files[I.cur_map].L[1];
+			break;
+		case 0xb101:
+			reply = I.map_files[I.cur_map].L[2];
+			break;
+		case 0xb110:
+			reply = I.mapper_address_latch;
+			break;
+		case 0xb111:
+			reply = I.mapper_address_latch >> 16;
+			break;
+		}
+
+		if (offset)
+			return (reply >> 8) & 0xff;
+		else
+			return reply & 0xff;
+	}
+
+	WRITE16_HANDLER(ti990_10_mapper_cru_w)
+	{
+		switch (offset)
+		{
+		case 0:
+		case 1:
+		case 2:
+			/* read register select */
+			if (data)
+				I.mapper_cru_read_register |= (1 << offset);
+			else
+				I.mapper_cru_read_register &= ~ (1 << offset);
+			break;
+		case 3:
+			/* enable mapping */
+			I.mapping_on = data;
+			break;
+		case 4:
+			/* reset flags */
+			I.reset_maperr = data;
+			if (data)
+			{
+				I.error_interrupt_register &= ~ EIR_MAPERR;
+				I.diaglat = 0;
+			}
+			break;
+		case 5:
+		case 6:
+		case 7:
+			/* latch control */
+			I.latch_control[7-offset] = data;
+			break;
+		}
+	}
+
+	INLINE void handle_error_interrupt(void)
+	{
+		if (I.error_interrupt_callback)
+			(*I.error_interrupt_callback)(I.error_interrupt_register ? 1 : 0);
+	}
+
+	READ16_HANDLER(ti990_10_eir_cru_r)
+	{
+		return (offset == 1) ? (I.error_interrupt_register & 0xff) : 0;
+	}
+
+	WRITE16_HANDLER(ti990_10_eir_cru_w)
+	{
+		if (offset < 4)	/* does not work for EIR_MAPERR */
+		{
+			I.error_interrupt_register &= ~ (1 << offset);
+
+			handle_error_interrupt();
+		}
+	}
+
 
-/* Interrupt mask */
-#if (TMS99XX_MODEL != TMS9940_ID)
-	#define IMASK       (I.STATUS & 0x0F)
-#else
-	#define IMASK       (I.STATUS & 0x03)
 #endif
 
+/* Interrupt mask */
+#define IMASK       (I.STATUS & ST_IM)
+
 /*
 	CYCLES macro : you provide timings for tms9900 and tms9995, and the macro chooses for you.
 
 	BTW, I have no idea what the timings are for tms9989 and tms99xxx...
 */
-#if TMS99XX_MODEL <= TMS9989_ID
+#if TMS99XX_MODEL == TI990_10_ID
+	/* Use TI990/10 timings*/
+	#define CYCLES(a,b,c) TMS99XX_ICOUNT -= a
+#elif TMS99XX_MODEL <= TMS9985_ID
 	/* Use TMS9900/TMS9980 timings*/
-	#define CYCLES(a,b) TMS99XX_ICOUNT -= a
+	#define CYCLES(a,b,c) TMS99XX_ICOUNT -= b
 #else
 	/* Use TMS9995 timings*/
-	#define CYCLES(a,b) TMS99XX_ICOUNT -= b*4
+	#define CYCLES(a,b,c) TMS99XX_ICOUNT -= c*4
 #endif
 
 #if (TMS99XX_MODEL == TMS9995_ID)
 
 static void set_flag0(int val);
@@ -673,134 +1291,126 @@
 /*
 	TMS9900 hard reset
 */
 void TMS99XX_INIT(void)
 {
-#if (TMS99XX_MODEL == TMS9995_ID)
-	void decrementer_callback(int ignored);
-	I.timer = timer_alloc(decrementer_callback);
-#endif
 }
 
-void TMS99XX_RESET(void *param)
+void TMS99XX_RESET(void *p)
 {
-	contextswitch(0x0000);
+#if (TMS99XX_MODEL == TI990_10_ID)
+	ti990_10reset_param *param = (ti990_10reset_param *) p;
+#elif (TMS99XX_MODEL == TMS9900_ID)
+	tms9900reset_param *param = (tms9900reset_param *) p;
+#elif (TMS99XX_MODEL == TMS9995_ID)
+	tms9995reset_param *param = (tms9995reset_param *) p;
+#endif
 
-	I.STATUS = 0; /* TMS9980 and TMS9995 Data Book say so */
-	setstat();
+	#if (TMS99XX_MODEL == TI990_10_ID)
+		I.idle_callback = param ? param->idle_callback : NULL;
+		I.rset_callback = param ? param->rset_callback : NULL;
+		I.lrex_callback = param ? param->lrex_callback : NULL;
+		I.ckon_ckof_callback = param ? param->ckon_ckof_callback : NULL;
 
-	I.IDLE = 0;   /* clear IDLE condition */
+		I.error_interrupt_callback = param ? param->error_interrupt_callback : NULL;
+	#endif
 
-#if (TMS99XX_MODEL == TMS9995_ID)
-	/* we can ask at reset time that the CPU always generates one wait state automatically */
-	if (param == NULL)
-	{	/* if no param, the default is currently "wait state added" */
-		I.memory_wait_states_byte = 4;
-		I.memory_wait_states_word = 12;
-	}
-	else
+	#if (TMS99XX_MODEL == TMS9900_ID)
+		I.idle_callback = param ? param->idle_callback : NULL;
+	#endif
+
+
+	contextswitchX(0x0000);
+
+	I.STATUS = 0; /* TMS9980 and TMS9995 Data Books say so */
+	getstat();
+
+	#if HAS_MAPPING
+		I.mapping_on = 0;
+		{
+			int i,j;
+
+			for (i=0; i<3; i++)
+				for (j=0; j<3; j++)
+				{
+					I.map_files[i].L[j] = 0;
+					I.map_files[i].limit[j] = 0xffff;
+					I.map_files[i].B[j] = 0;
+					I.map_files[i].bias[j] = 0;
+				}
+		}
+		I.cur_map = 0;			/* equivalent to ST_MF status bit */
+		I.cur_src_map = 0;		/* set to 2 by LDS */
+		I.cur_dst_map = 0;		/* set to 2 by LDD */
+
+		I.reset_maperr = 0;
+	#endif
+
+	if (I.IDLE)
 	{
-		I.memory_wait_states_byte = (((tms9995reset_param *) param)->auto_wait_state) ? 4 : 0;
-		I.memory_wait_states_word = (((tms9995reset_param *) param)->auto_wait_state) ? 12 : 4;
+		I.IDLE = 0;		/* clear IDLE condition */
+		if (I.idle_callback)
+			(*I.idle_callback)(0);
 	}
 
-	I.MID_flag = 0;
+	#if (TMS99XX_MODEL == TMS9995_ID)
+		/* we can ask at reset time that the CPU always generates one wait state automatically */
+		if (param == NULL)
+		{	/* if no param, the default is currently "wait state added" */
+			I.memory_wait_states_byte = 4;
+			I.memory_wait_states_word = 12;
+		}
+		else
+		{
+			I.memory_wait_states_byte = (param->auto_wait_state) ? 4 : 0;
+			I.memory_wait_states_word = (param->auto_wait_state) ? 12 : 4;
+		}
 
-	/* Clear flag bits 0 & 1 */
-	set_flag0(0);
-	set_flag1(0);
+		I.MID_flag = 0;
 
-	/* Clear internal interupt latches */
-	I.int_latch = 0;
-	I.flag &= 0xFFE3;
-#endif
+		/* Clear flag bits 0 & 1 */
+		set_flag0(0);
+		set_flag1(0);
+
+		/* Clear internal interrupt latches */
+		I.int_latch = 0;
+		I.flag &= 0xFFE3;
+	#endif
 
-	/* The ST register and interrupt latches changed, didn't it ? */
+	/* The ST register and interrupt latches changed, didn't they ? */
 	field_interrupt();
 
-	CYCLES(26, 14);
+	CYCLES(6, 26, 14);
 }
 
 void TMS99XX_EXIT(void)
 {
 	/* nothing to do ? */
 }
 
+/* fetch : read one word at * PC, and increment PC. */
+INLINE UINT16 fetch(void)
+{
+	UINT16 value = readword(I.PC);
+	I.PC += 2;
+	return value;
+}
+
+
 int TMS99XX_EXECUTE(int cycles)
 {
 	TMS99XX_ICOUNT = cycles;
 
+	lds_flag = 0;
+	ldd_flag = 0;
+
 	do
 	{
-
-		#ifdef MAME_DEBUG
-		{
-			if (mame_debug)
-			{
-				setstat();
-
-				I.FR[ 0] = READREG(R0);
-				I.FR[ 1] = READREG(R1);
-				I.FR[ 2] = READREG(R2);
-				I.FR[ 3] = READREG(R3);
-				I.FR[ 4] = READREG(R4);
-				I.FR[ 5] = READREG(R5);
-				I.FR[ 6] = READREG(R6);
-				I.FR[ 7] = READREG(R7);
-				I.FR[ 8] = READREG(R8);
-				I.FR[ 9] = READREG(R9);
-				I.FR[10] = READREG(R10);
-				I.FR[11] = READREG(R11);
-				I.FR[12] = READREG(R12);
-				I.FR[13] = READREG(R13);
-				I.FR[14] = READREG(R14);
-				I.FR[15] = READREG(R15);
-
-				#if 0		/* Trace */
-				logerror("> PC %4.4x :%4.4x %4.4x : R=%4.4x %4.4x %4.4x %4.4x %4.4x %4.4x %4.4x %4.4x %4.4x %4.4x%4.4x %4.4x %4.4x %4.4x %4.4x %4.4x :T=%d\n",I.PC,I.STATUS,I.WP,I.FR[0],I.FR[1],I.FR[2],I.FR[3],I.FR[4],I.FR[5],I.FR[6],I.FR[7],I.FR[8],I.FR[9],I.FR[10],I.FR[11],I.FR[12],I.FR[13],I.FR[14],I.FR[15],TMS99XX_ICOUNT);
-					#if 0	/* useful with TI99/4a driver */
-					{
-						extern int gpl_addr;
-						logerror("> GPL pointer %4.4x\n", gpl_addr);
-					}
-					#endif
-				#endif
-
-				MAME_Debug();
-			}
-		}
-		#endif
-
-		if (I.IDLE)
-		{	/* IDLE instruction has halted execution */
-			external_instruction_notify(2);
-			CYCLES(2, 2); /* 2 cycles per CRU write */
-		}
-		else
-		{	/* we execute an instruction */
-			disable_interrupt_recognition = 0;  /* default value */
-			I.IR = fetch();
-			execute(I.IR);
-
-#if (TMS99XX_MODEL >= TMS9995_ID)
-			/* Note that TI had some problem implementing this...  I don't know if this feature works on
-			a real-world TMS9995. */
-			if ((I.STATUS & ST_OV_EN) && (I.STATUS & ST_OV) && (I.irq_level > 2))
-				I.irq_level = 2;  /* interrupt request */
-#endif
-		}
-
-		/*
-		  We handle interrupts here because :
-		  a) LOAD and level-0 (reset) interrupts are non-maskable, so, AFAIK, if the LOAD* line or
-		     INTREQ* line (with IC0-3 == 0) remain active, we will execute repeatedly the first
-		     instruction of the interrupt routine.
-		  b) if we did otherwise, we could have weird, buggy behavior if IC0-IC3 changed more than
-		     once in too short a while (i.e. before tms9900 executes another instruction).  Yes, this
-		     is rather pedantic, the probability is really small.
-		*/
-		if (I.interrupt_pending)
+		/* all TMS9900 chips I know do not honor interrupts after XOP, BLWP or MID (after any
+		  interrupt-like instruction, actually), and they do not either after LDS and LDD
+		  (There are good reasons for this). */
+		if ((I.interrupt_pending) && (! I.disable_interrupt_recognition))
 		{
 			int level;
 
 #if SILLY_INTERRUPT_HACK
 			if (I.irq_level == IRQ_MAGIC_LEVEL)
@@ -815,48 +1425,55 @@
 			}
 			else
 #endif
 			level = I.irq_level;
 
+
 			if (I.load_state)
 			{	/* LOAD has the highest priority */
 
-				contextswitch(0xFFFC);  /* load vector, save PC, WP and ST */
+				contextswitchX(0xFFFC);  /* load vector, save PC, WP and ST */
 
-				I.STATUS &= 0xFFF0;     /* clear mask */
+				I.STATUS &= ~ST_IM;     /* clear interrupt mask */
 
 				/* clear IDLE status if necessary */
-				I.IDLE = 0;
+				if (I.IDLE)
+				{
+					I.IDLE = 0;		/* clear IDLE condition */
+					if (I.idle_callback)
+						(*I.idle_callback)(0);
+				}
 
-				CYCLES(22, 14);
+				CYCLES(6/*to be confirmed*/, 22, 14);
 			}
-			/* all TMS9900 chips I know do not honor interrupts after XOP, BLWP or MID (after any
-			  interrupt-like instruction, actually) */
-			else if (! disable_interrupt_recognition)
-			{
-				if (level <= IMASK)
-				{	/* a maskable interrupt is honored only if its level isn't greater than IMASK */
+			else if (level <= IMASK)
+			{	/* a maskable interrupt is honored only if its level isn't greater than IMASK */
 
-					contextswitch(level*4); /* load vector, save PC, WP and ST */
+				contextswitchX(level*4); /* load vector, save PC, WP and ST */
 
-					/* change interrupt mask */
-					if (level)
-					{
-						I.STATUS = (I.STATUS & 0xFFF0) | (level -1);  /* decrement mask */
-						I.interrupt_pending = 0;  /* as a consequence, the interrupt request will be subsequently ignored */
-					}
-					else
-						I.STATUS &= 0xFFF0; /* clear mask (is this correct ???) */
+				/* change interrupt mask */
+				if (level)
+				{
+					I.STATUS = (I.STATUS & ~ST_IM) | (level -1);  /* decrement mask */
+					I.interrupt_pending = 0;  /* as a consequence, the interrupt request will be subsequently ignored */
+				}
+				else
+					I.STATUS &= ~ST_IM; /* clear mask (is this correct???) */
 
-#if (TMS99XX_MODEL == TMS9995_ID)
+				#if (TMS99XX_MODEL == TMS9995_ID)
 					I.STATUS &= 0xFE00;
-#endif
+				#endif
 
-					/* clear IDLE status if necessary */
-					I.IDLE = 0;
+				/* clear IDLE status if necessary */
+				if (I.IDLE)
+				{
+					I.IDLE = 0;		/* clear IDLE condition */
+					if (I.idle_callback)
+						(*I.idle_callback)(0);
+				}
 
-#if (TMS99XX_MODEL == TMS9995_ID)
+				#if (TMS99XX_MODEL == TMS9995_ID)
 					/* Clear bit in latch */
 					/* I think tms9989 does this, too */
 					if (level != 2)
 					{	/* Only do this on level 1, 3, 4 interrupts */
 						int mask = 1 << level;
@@ -869,23 +1486,104 @@
 						if (level == 1)
 							(* I.irq_callback)(0);
 						else if (level == 4)
 							(* I.irq_callback)(1);
 					}
+				#endif
+
+				CYCLES(6, 22, 14);
+			}
+			else
+#if SILLY_INTERRUPT_HACK
+			if (I.interrupt_pending)  /* we may have just cleared this */
 #endif
+			{
+				logerror("tms9900.c : the interrupt_pending flag was set incorrectly\n");
+				I.interrupt_pending = 0;
+			}
+		}
 
-					CYCLES(22, 14);
+		#ifdef MAME_DEBUG
+		{
+			if (mame_debug)
+			{
+				I.FR[ 0] = READREG(R0);
+				I.FR[ 1] = READREG(R1);
+				I.FR[ 2] = READREG(R2);
+				I.FR[ 3] = READREG(R3);
+				I.FR[ 4] = READREG(R4);
+				I.FR[ 5] = READREG(R5);
+				I.FR[ 6] = READREG(R6);
+				I.FR[ 7] = READREG(R7);
+				I.FR[ 8] = READREG(R8);
+				I.FR[ 9] = READREG(R9);
+				I.FR[10] = READREG(R10);
+				I.FR[11] = READREG(R11);
+				I.FR[12] = READREG(R12);
+				I.FR[13] = READREG(R13);
+				I.FR[14] = READREG(R14);
+				I.FR[15] = READREG(R15);
+
+				#if 0		/* Trace */
+				logerror("> PC %4.4x :%4.4x %4.4x : R=%4.4x %4.4x %4.4x %4.4x %4.4x %4.4x %4.4x %4.4x %4.4x %4.4x%4.4x %4.4x %4.4x %4.4x %4.4x %4.4x :T=%d\n",I.PC,I.STATUS,I.WP,I.FR[0],I.FR[1],I.FR[2],I.FR[3],I.FR[4],I.FR[5],I.FR[6],I.FR[7],I.FR[8],I.FR[9],I.FR[10],I.FR[11],I.FR[12],I.FR[13],I.FR[14],I.FR[15],TMS99XX_ICOUNT);
+					#if 0	/* useful with TI99/4a driver */
+					{
+						extern int gpl_addr;
+						logerror("> GPL pointer %4.4x\n", gpl_addr);
+					}
+					#endif
+				#endif
+
+				MAME_Debug();
+			}
+		}
+		#endif
+
+		if (I.IDLE)
+		{	/* IDLE instruction has halted execution */
+			#if EXTERNAL_INSTRUCTION_DECODING
+				external_instruction_notify(2);
+				CYCLES(Moof!, 2, 2); /* 2 cycles per CRU write */
+			#else
+				TMS99XX_ICOUNT = 0;	/* much simpler... */
+			#endif
+		}
+		else
+		{	/* we execute an instruction */
+			I.disable_interrupt_recognition = 0;  /* default value */
+			I.IR = fetch();
+			execute(I.IR);
+			#if HAS_MAPPING
+				if (lds_flag)
+				{
+					lds_flag = 0;
+					I.cur_src_map = 2 /*(I.cur_src_map != 2) ? 2 : I.cur_map*/;
 				}
 				else
-#if SILLY_INTERRUPT_HACK
-				if (I.interrupt_pending)  /* we may have just cleared this */
-#endif
+					I.cur_src_map = I.cur_map;
+				if (ldd_flag)
 				{
-					logerror("tms9900.c : the interrupt_pending flag was set incorrectly\n");
-					I.interrupt_pending = 0;
+					ldd_flag = 0;
+					I.cur_dst_map = 2 /*(I.cur_src_map != 2) ? 2 : I.cur_map*/;
 				}
-			}
+				else
+					I.cur_dst_map = I.cur_map;
+				#if (TMS99XX_MODEL == TI990_10_ID)
+					write_inhibit = 0;
+				#endif
+			#endif
+
+			#if (HAS_OVERFLOW_INTERRUPT)
+				#if (TMS99XX_MODEL == TMS9995_ID)
+					/* Note that TI had some problem implementing this...  I don't know if this feature works on
+					a real-world TMS9995. */
+					if ((I.STATUS & ST_OVIE) && (I.STATUS & ST_OV) && (I.irq_level > 2))
+						I.irq_level = 2;  /* interrupt request */
+				#else
+					#warning "todo..."
+				#endif
+			#endif
 		}
 
 	} while (TMS99XX_ICOUNT > 0);
 
 	return cycles - TMS99XX_ICOUNT;
@@ -904,37 +1602,64 @@
 void TMS99XX_SET_CONTEXT(void *src)
 {
 	if( src )
 	{
 		I = *(tms99xx_Regs*)src;
-		/* We have to make additionnal checks this, because Mame debugger can foolishly initialize
+		/* We have to make additionnal checks, because Mame debugger can foolishly initialize
 		the context to all 0s */
-#if (TMS99XX_MODEL == TMS9900_ID)
-		if (! I.irq_state)
-			I.irq_level = 16;
-#elif ((TMS99XX_MODEL == TMS9980_ID) || (TMS99XX_MODEL == TMS9995_ID))
-		/* Our job is simpler, since there is no level-0 request... */
-		if (! I.irq_level)
-			I.irq_level = 16;
-#else
-		#warning "You may want to have a look at this problem"
-#endif
+		#if (TMS99XX_MODEL == TMS9900_ID) || (TMS99XX_MODEL == TI990_10_ID)
+			if (! I.irq_state)
+				I.irq_level = 16;
+		#elif ((TMS99XX_MODEL == TMS9980_ID) || (TMS99XX_MODEL == TMS9995_ID))
+			/* Our job is simpler, since there is no level-0 request... */
+			if (! I.irq_level)
+				I.irq_level = 16;
+		#elif ((TMS99XX_MODEL == TMS9940_ID) || (TMS99XX_MODEL == TMS9985_ID))
+			if (! I.irq_level)
+				I.irq_level = 4;
+		#else
+			#warning "You may want to have a look at this problem"
+		#endif
 
 		getstat();  /* set last_parity */
 	}
 }
 
 unsigned TMS99XX_GET_REG(int regnum)
 {
 	switch( regnum )
 	{
+#if (TMS99XX_MODEL == TI990_10_ID)
+		case REG_PC:
+			if ((I.cur_map == 0) && (I.PC >= 0xf800))
+				/* intercept TPCS and CPU ROM */
+				return 0x1f0000+I.PC;
+			else if (! I.mapping_on)
+				return I.PC;
+			else
+			{
+				int map_index;
+
+				if (I.PC <= I.map_files[I.cur_map].limit[0])
+					map_index = 0;
+				else if (I.PC <= I.map_files[I.cur_map].limit[1])
+					map_index = 1;
+				else if (I.PC <= I.map_files[I.cur_map].limit[2])
+					map_index = 2;
+				else
+					return I.PC;
+
+				return I.map_files[I.cur_map].bias[map_index]+I.PC;
+			}
+#else
 		case REG_PC:
+#endif
 		case TMS9900_PC: return I.PC;
 		case TMS9900_IR: return I.IR;
 		case REG_SP:
 		case TMS9900_WP: return I.WP;
-		case TMS9900_STATUS: return I.STATUS;
+		case TMS9900_STATUS: setstat(); return I.STATUS;
 #ifdef MAME_DEBUG
 		case TMS9900_R0: return I.FR[0];
 		case TMS9900_R1: return I.FR[1];
 		case TMS9900_R2: return I.FR[2];
 		case TMS9900_R3: return I.FR[3];
@@ -957,16 +1682,54 @@
 
 void TMS99XX_SET_REG(int regnum, unsigned val)
 {
 	switch( regnum )
 	{
+#if (TMS99XX_MODEL == TI990_10_ID)
 		case REG_PC:
+			{
+				const unsigned top = (I.cur_map == 0) ? 0xf800 : 0x10000;
+
+				if ((I.cur_map == 0) && (val >= 0x1ff800))
+					/* intercept TPCS and CPU ROM */
+					I.PC = val - 0x1f0000;
+				else if (! I.mapping_on)
+					I.PC = (val < top) ? val : 0;
+				else
+				{
+					if ((val >= I.map_files[I.cur_map].bias[0])
+							&& (val <= (I.map_files[I.cur_map].bias[0]+I.map_files[I.cur_map].limit[0])))
+						I.PC = val - I.map_files[I.cur_map].bias[0];
+					else if ((val > (I.map_files[I.cur_map].bias[1]+I.map_files[I.cur_map].limit[0]))
+							&& (val <= (I.map_files[I.cur_map].bias[1]+I.map_files[I.cur_map].limit[1])))
+						I.PC = val - I.map_files[I.cur_map].bias[1];
+					else if ((val > (I.map_files[I.cur_map].bias[2]+I.map_files[I.cur_map].limit[0]))
+							&& (val > (I.map_files[I.cur_map].bias[2]+I.map_files[I.cur_map].limit[1]))
+							&& (val <= (I.map_files[I.cur_map].bias[2]+I.map_files[I.cur_map].limit[2])))
+						I.PC = val - I.map_files[I.cur_map].bias[2];
+					else
+					{
+						if ((val < top)
+								&& (val > I.map_files[I.cur_map].limit[0])
+								&& (val > I.map_files[I.cur_map].limit[1])
+								&& (val > I.map_files[I.cur_map].limit[2]))
+							I.PC = val;
+						else
+							I.PC = 0;
+					}
+					if (val >= top)
+						I.PC = 0;
+				}
+			}
+#else
+		case REG_PC:
+#endif
 		case TMS9900_PC: I.PC = val; break;
 		case TMS9900_IR: I.IR = val; break;
 		case REG_SP:
 		case TMS9900_WP: I.WP = val; break;
-		case TMS9900_STATUS: I.STATUS = val; break;
+		case TMS9900_STATUS: I.STATUS = val; getstat(); break;
 #ifdef MAME_DEBUG
 		case TMS9900_R0: I.FR[0]= val; break;
 		case TMS9900_R1: I.FR[1]= val; break;
 		case TMS9900_R2: I.FR[2]= val; break;
 		case TMS9900_R3: I.FR[3]= val; break;
@@ -984,21 +1747,54 @@
 		case TMS9900_R15: I.FR[15]= val; break;
 #endif
 	}
 }
 
-#if (TMS99XX_MODEL == TMS9900_ID)
+#if (TMS99XX_MODEL == TI990_10_ID)
+
+void ti990_10_set_irq_line(int irqline, int state)
+{
+	if (irqline == IRQ_LINE_NMI)
+	{
+		I.load_state = state;   /* save new state */
+
+		field_interrupt();  /* interrupt status changed */
+	}
+	else
+	{
+		/*if (I.irq_state == state)
+			return;*/
+
+		I.irq_state = state;
+
+		if (state == CLEAR_LINE)
+			I.irq_level = 16;
+			/* trick : 16 will always be bigger than the IM (0-15), so there will never be interrupts */
+		else
+		{
+			#if SILLY_INTERRUPT_HACK
+				I.irq_level = IRQ_MAGIC_LEVEL;
+			#else
+				I.irq_level = (* I.irq_callback)(0);
+			#endif
+		}
+
+		field_interrupt();  /* interrupt state is likely to have changed */
+	}
+}
+
+#elif (TMS99XX_MODEL == TMS9900_ID)
 
 /*
 void tms9900_set_irq_line(IRQ_LINE_NMI, int state) : change the state of the LOAD* line
 
 	state == 0 -> LOAD* goes high (inactive)
 	state != 0 -> LOAD* goes low (active)
 
 	While LOAD* is low, we keep triggering LOAD interrupts...
 
-	A problem : some peripheral lower the LOAD* line for a fixed time interval (causing the 1st
+	A problem : some peripherals lower the LOAD* line for a fixed time interval (causing the 1st
 	instruction of the LOAD interrupt routine to be repeated while the line is low), and will be
 	perfectly happy with the current scheme, but others might be more clever and wait for the IAQ
 	(Instruction acquisition) line to go high, and this needs a callback function to emulate.
 */
 
@@ -1018,11 +1814,11 @@
 	the hardware (generally in response to an action performed by the interrupt routines).
 	On tms9995 (9989 ?), you can use PULSE_LINE, too, since the processor latches the line...
 
 	**Note** : HOLD_LINE *NEVER* makes sense on the TMS9900 (or 9980, 9995...).  The reason is the
 	TMS9900 does NOT tell the world it acknoledges an interrupt, so no matter how much hardware you
-	se, you cannot know when the CPU takes the interrupt, hence you cannot release the line when
+	use, you cannot know when the CPU takes the interrupt, hence you cannot release the line when
 	the CPU takes the interrupt.  Generally, the interrupt condition is cleared by the interrupt
 	routine (with some CRU or memory access).
 
 	Note that cpu_generate_interrupt uses HOLD_LINE, so your driver interrupt code
 	should always use the new style, i.e. return "ignore_interrupt()" and call
@@ -1110,11 +1906,14 @@
 		I.irq_state = 1;
 		I.irq_level = IRQ_MAGIC_LEVEL;*/
 #else
 		int level;
 
-		level = (* I.irq_callback)(0);
+		if (irqline == IRQ_LINE_NMI)
+			level = 2;	/* translate MAME's convention to CPU's representation */
+		else
+			level = (* I.irq_callback)(0);
 
 		switch (level)
 		{
 		case 0:
 		case 1:
@@ -1143,15 +1942,46 @@
 	}
 
 	field_interrupt();  /* interrupt state is likely to have changed */
 }
 
+#elif (TMS99XX_MODEL == TMS9940_ID) || (TMS99XX_MODEL == TMS9985_ID)
+/*
+	2 interrupt pins (int1 and int2)
+*/
+
+#if (TMS99XX_MODEL == TMS9940_ID)
+void tms9940_set_irq_line(int irqline, int state)
+#else
+void tms9985_set_irq_line(int irqline, int state)
+#endif
+{
+	int mask;
+
+	if (irqline == 0)
+		/* INT1 */
+		mask = 1;
+	else if (irqline == 1)
+		/* INT2 */
+		mask = 4;
+	else
+		/* What on earth??? */
+		return;
+
+	if (state)
+		I.irq_state |= mask;
+	else
+		I.irq_state &= ~mask;
+
+	field_interrupt();  /* interrupt state is likely to have changed */
+}
+
 #elif (TMS99XX_MODEL == TMS9995_ID)
 /*
   this call-back is called by MESS timer system when the timer reaches 0.
 */
-void decrementer_callback(int ignored)
+static void decrementer_callback(int ignored)
 {
 	/* request decrementer interrupt */
 	I.int_latch |= 0x8;
 	I.flag |= 0x8;
 
@@ -1259,14 +2089,31 @@
  *
  * By using this flag, we save some compares in the execution loop.  Subtle, isn't it ;-) ?
  *
  * R Nabet.
  */
-#if (TMS99XX_MODEL == TMS9900_ID) || (TMS99XX_MODEL == TMS9980_ID)
+#if (TMS99XX_MODEL == TI990_10_ID) || (TMS99XX_MODEL == TMS9900_ID) || (TMS99XX_MODEL == TMS9980_ID)
+
+static void field_interrupt(void)
+{
+	I.interrupt_pending = ((I.irq_level <= IMASK) || (I.load_state));
+}
+
+#elif (TMS99XX_MODEL == TMS9940_ID) || (TMS99XX_MODEL == TMS9985_ID)
 
 static void field_interrupt(void)
 {
+	if (I.irq_state & 1)
+		I.irq_level = 1;
+	else if (I.irq_state & 2)
+		I.irq_level = 2;
+	else if (I.irq_state & 4)
+		I.irq_level = 3;
+	else
+		I.irq_level = 4;
+		/* trick : 4 will always be bigger than the IM (0-3), so there will never be interrupts */
+
 	I.interrupt_pending = ((I.irq_level <= IMASK) || (I.load_state));
 }
 
 #elif (TMS99XX_MODEL == TMS9995_ID)
 
@@ -1379,18 +2226,60 @@
 
 unsigned TMS99XX_DASM(char *buffer, unsigned pc)
 {
 
 #ifdef MAME_DEBUG
-	return Dasm9900(buffer,pc);
+	return Dasm9900(buffer, pc, TMS99XX_MODEL);
 #else
 	sprintf( buffer, "$%04X", readword(pc) );
 	return 2;
 #endif
 }
 
-/**************************************************************************/
+
+/*****************************************************************************/
+/*
+	CRU support code
+
+	The CRU bus is a 1-bit-wide I/O bus.  The CPU can read or write bits at random address.
+	Special instructions are dedicated to reading and writing one or several consecutive bits.
+
+
+
+	Note that TMS99000 additionally supports parallel CRU operations, although I don't know how
+	this feature is implemented.
+*/
+
+enum
+{
+#if (TMS99XX_MODEL == TI990_10_ID)
+	/* 3 MSBs do exist, although they are not connected (don't ask...) */
+	CRUAddrBit = 15
+#elif (TMS99XX_MODEL == TMS9900_ID)
+	/* 3 MSBs are always 0 to support external instructions */
+	CRUAddrBit = 12
+#elif (TMS99XX_MODEL == TMS9980_ID)
+	/* 2 bits unused, and 2 MSBs are always 0 to support external instructions */
+	CRUAddrBit = 11
+#elif (TMS99XX_MODEL == TMS9940_ID)
+	/* 9 internal address lines (8 external) */
+	CRUAddrBit = 9
+#elif (TMS99XX_MODEL == TMS9995_ID)
+	/* no such problem here : data bus lines D0-D2 provide the external instruction code */
+	CRUAddrBit = 15
+#else
+	#warning "I don't know how your processor handle CRU."
+	CRUAddrBit = 15
+#endif
+};
+
+enum
+{
+	rCRUAddrMask = (1 << (CRUAddrBit - 3)) - 1,
+	wCRUAddrMask = (1 << CRUAddrBit) - 1
+};
+
 
 #if (TMS99XX_MODEL == TMS9995_ID)
 
 /* set decrementer mode flag */
 static void set_flag0(int val)
@@ -1414,96 +2303,197 @@
 	reset_decrementer();
 }
 
 #endif
 
-#if (TMS99XX_MODEL == TMS9900_ID)
-#define WRITEPORT(Port, data) cpu_writeport16bew_word((Port)<<1, (data))
+typedef enum
+{
+	CRU_OK = 0,
+	CRU_PRIVILEGE_VIOLATION = -1
+} cru_error_code;
+
+#if USE_16_BIT_ACCESSORS
+#define WRITEPORT(port, data) cpu_writeport16bew_word((port)<<1, (data))
 #else
-#define WRITEPORT(Port, data) cpu_writeport16(Port, data)
+#define WRITEPORT(port, data) cpu_writeport16(port, data)
 #endif
 
-
-/*
-	performs a normal write to CRU bus (used by SBZ, SBO, LDCR : address range 0 -> 0xFFF)
-*/
-static void writeCRU(int CRUAddr, int Number, UINT16 Value)
+#if (TMS99XX_MODEL == TMS9940_ID) || (TMS99XX_MODEL == TMS9985_ID)
+/* on tms9940, we have to handle internal CRU ports */
+static void write_single_CRU(int port, int data)
 {
-#if (TMS99XX_MODEL == TMS9900_ID)
-	/* 3 MSBs are always 0 to support external instructions */
-	#define wCRUAddrMask 0xFFF;
-#elif (TMS99XX_MODEL == TMS9980_ID)
-	/* 2 bits unused, and 2 MSBs are always 0 to support external instructions */
-	#define wCRUAddrMask 0x7FF;
+	int mask;
+
+	if (! (port & 0x100))
+	{
+		/*if (I.config & CB0)*/
+			/* External CRU */
+			WRITEPORT(port, (data & 0x01));
+	}
+	else
+	{
+		/* internal CRU */
+		switch ((port >> 4) & 0xf)
+		{
+		case 0x8:
+			if (port == 0x181)
+			{
+				/* clear decrementer interrupt */
+				I.irq_state &= ~2;
+			}
+			if (port >= 0x183) && (port <= 0x186)
+			{
+				/* write configuration register */
+				mask = 1 << (port - 0x183);
+				/* ... */
+			}
+			break;
+
+		case 0x9:
+			if (port <= 0x19D)
+			{
+				/* write decrementer latch */
+				mask = 1 << (port - 0x190);
+				/* ... */
+			}
+			else if (port == 0x19E)
+			{
+				/* set decrementer as timer (1) or event counter (0) */
+				/* ... */
+			}
+			break;
+
+		case 0xA:
+			/* multiprocessor system interface */
+			mask = 1 << (port - 0x1A0);
+			/* ... */
+			break;
+
+		case 0xB:
+			/* flags */
+			mask = 1 << (port - 0x1B0);
+			/* ... */
+			break;
+
+		case 0xC:
+		case 0xD:
+			/* direction for P0-P31 */
+			mask = 1 << (port - 0x1C0);
+			/* ... */
+			break;
+
+		case 0xE:
+		case 0xF:
+			/* data for P0-P31 */
+			mask = 1 << (port - 0x1E0);
+			/* ... */
+			break;
+		}
+	}
+}
 #elif (TMS99XX_MODEL == TMS9995_ID)
-	/* no such problem here : data bus lines D0-D2 provide the external instruction code */
-	#define wCRUAddrMask 0x7FFF;
+/* on tms9995, we have to handle internal CRU ports */
+static void write_single_CRU(int port, int data)
+{
+	switch (port)
+	{
+	case 0xF70:
+		set_flag0(data & 0x01);
+		break;
+	case 0xF71:
+		set_flag1(data & 0x01);
+		break;
+	case 0xF72:
+	case 0xF73:
+	case 0xF74:
+		break;     /* ignored */
+	case 0xF75:
+	case 0xF76:
+	case 0xF77:
+	case 0xF78:
+	case 0xF79:
+	case 0xF7A:
+	case 0xF7B:
+	case 0xF7C:
+	case 0xF7D:
+	case 0xF7E:
+	case 0xF7F:
+		{	/* user defined flags */
+			int mask = 1 << (port - 0xF70);
+			if (data & 0x01)
+				I.flag |= mask;
+			else
+				I.flag &= ~ mask;
+		}
+		break;
+
+	case 0x0FED:
+		/* MID flag */
+		I.MID_flag = data & 0x01;
+		break;
+	default:
+		/* External CRU */
+		WRITEPORT(port, (data & 0x01));
+		break;
+	}
+}
 #else
-	#warning "I don't know how your processor handle CRU."
-	#define wCRUAddrMask 0x7FFF;
+#define write_single_CRU(port, data) WRITEPORT(port, data)
 #endif
 
+/*
+	performs a normal write to CRU bus (used by SBZ, SBO, LDCR : address range 0 -> 0xFFF)
+*/
+static cru_error_code writeCRU(int CRUAddr, int Number, UINT16 Value)
+{
 	int count;
 
-	logerror("PC %4.4x Write CRU %x for %x =%x\n",I.PC,CRUAddr,Number,Value);
+	/*logerror("PC %4.4x Write CRU %x for %x =%x\n",I.PC,CRUAddr,Number,Value);*/
 
 	CRUAddr &= wCRUAddrMask;
 
 	/* Write Number bits from CRUAddr */
 
 	for(count=0; count<Number; count++)
 	{
-#if (TMS99XX_MODEL == TMS9995_ID)
-		if (CRUAddr == 0xF70)
-			set_flag0(Value & 0x01);
-		else if (CRUAddr == 0xF71)
-			set_flag1(Value & 0x01);
-		else if ((CRUAddr >= 0xF72) && (CRUAddr < 0xF75))
-			;     /* ignored */
-		else if ((CRUAddr >= 0xF75) && (CRUAddr < 0xF80))
-		{	/* user defined flags */
-			int mask = 1 << (CRUAddr - 0xF70);
-			if (Value & 0x01)
-				I.flag |= mask;
-			else
-				I.flag &= ~ mask;
-		}
-		else if (CRUAddr == 0x0FED)
-			/* MID flag */
-			I.MID_flag = Value & 0x01;
-		else
-			/* External CRU */
-#endif
-		WRITEPORT(CRUAddr, (Value & 0x01));
+		#if HAS_PRIVILEGE
+			if ((I.STATUS & ST_PR) && (CRUAddr >= 0xE00))
+				return CRU_PRIVILEGE_VIOLATION;
+		#endif
+
+		write_single_CRU(CRUAddr, (Value & 0x01));
 		Value >>= 1;
 		CRUAddr = (CRUAddr + 1) & wCRUAddrMask;
 	}
+
+	return CRU_OK;
 }
 
+#if EXTERNAL_INSTRUCTION_DECODING
 /*
 	Some opcodes perform a dummy write to a special CRU address, so that an external function may be
 	triggered.
 
 	Only the first 3 MSBs of the address matter : other address bits and the written value itself
 	are undefined.
 
-	How should we support this ? With callback functions ? Actually, as long as we do not support
+	How should we support this? With callback functions? Actually, as long as we do not support
 	hardware which makes use of this feature, it does not really matter :-) .
 */
 static void external_instruction_notify(int ext_op_ID)
 {
 #if 1
 	/* I guess we can support this like normal CRU operations */
-#if (TMS99XX_MODEL == TMS9900_ID)
-	WRITEPORT(ext_op_ID << 12, 0); /* or is it 1 ??? */
-#elif (TMS99XX_MODEL == TMS9980_ID)
-	cpu_writeport16((ext_op_ID & 3) << 11, (ext_op_ID & 4) ? 1 : 0);
-#elif (TMS99XX_MODEL == TMS9995_ID)
-	cpu_writeport16(ext_op_ID << 15, 0); /* or is it 1 ??? */
-#else
-	#warning "I don't know how your processor handle external opcodes (maybe you don't need them, though)."
-#endif
+	#if (TMS99XX_MODEL == TMS9900_ID)
+		WRITEPORT(ext_op_ID << 12, 0); /* or is it 1 ??? */
+	#elif (TMS99XX_MODEL == TMS9980_ID)
+		cpu_writeport16((ext_op_ID & 3) << 11, (ext_op_ID & 4) ? 1 : 0);
+	#elif (TMS99XX_MODEL == TMS9995_ID)
+		cpu_writeport16(ext_op_ID << 15, 0); /* or is it 1 ??? */
+	#else
+		#warning "I don't know how your processor handle external opcodes (maybe you don't need them, though)."
+	#endif
 
 #else
 	switch (ext_op_ID)
 	{
 		case 2: /* IDLE */
@@ -1530,119 +2520,245 @@
 			logerror("PC %4.4x : external_instruction_notify : unknown ext_op_ID",I.PC);
 			break;
 	}
 #endif
 }
+#endif
 
 /*
 	performs a normal read to CRU bus (used by TB, STCR : address range 0->0xFFF)
 
-	Note that on some hardware, e.g. TI99, all normal memory operations cause unwanted CRU
-	read at the same address.
-	This seems to be impossible to emulate efficiently.
-*/
-#if (TMS99XX_MODEL == TMS9900_ID)
-#define READPORT(Port) cpu_readport16bew_word((Port)<<1)
-#elif (TMS99XX_MODEL != TMS9995_ID)
-#define READPORT(Port) cpu_readport16(Port)
+	Note that on some hardware, e.g. TI99/4(a), all normal memory operations cause unwanted CRU
+	read at the same address.  This seems to be impossible to emulate efficiently, so, if you need
+	to emulate this, you're in trouble.
+*/
+#if USE_16_BIT_ACCESSORS
+#define READPORT(port) cpu_readport16bew_word((port)<<1)
 #else
-/* on tms9995, we have to handle internal CRU port */
-int READPORT(int Port)
+#define READPORT(port) cpu_readport16(port)
+#endif
+
+
+#if (TMS99XX_MODEL == TMS9940_ID) || (TMS99XX_MODEL == TMS9985_ID)
+/* on tms9940, we have to handle internal CRU ports */
+static int read_single_CRU(int port)
+{
+	int reply;
+	int shift;
+
+	if (! (port & 0x20))
+	{
+		/*if (I.config & CB0)*/
+			/* External CRU */
+			reply = READPORT(port, (data & 0x01));
+	}
+	else
+	{
+		/* internal CRU */
+		switch (port)
+		{
+		case 0x10:
+			/* read interrupt state */
+			reply = I.irq_state;
+			break;
+
+		case 0x12:
+			/* read decrementer LSB */
+			/* ... */
+			break;
+		case 0x13:
+			/* read decrementer MSB */
+			/* ... */
+			break;
+
+		case 0x14:
+			/* read multiprocessor system interface LSB */
+			/* ... */
+			break;
+		case 0x15:
+			/* read multiprocessor system interface MSB */
+			/* ... */
+			break;
+
+		case 0x16:
+			/* read flags LSB */
+			/* ... */
+			break;
+		case 0x17:
+			/* read flags MSB */
+			/* ... */
+			break;
+
+		case 0x18:
+		case 0x19:
+		case 0x1A:
+		case 0x1B:
+			/* direction for P0-P31 */
+			shift = (port - 0x18) << 3;
+			/* ... */
+			break;
+
+		case 0x1C:
+		case 0x1D:
+		case 0x1E:
+		case 0x1F:
+			/* data for P0-P31 */
+			shift = (port - 0x1C) << 3;
+			/* ... */
+			break;
+
+		default:
+			reply = 0;
+			break;
+		}
+	}
+
+	return reply;
+}
+#elif (TMS99XX_MODEL == TMS9995_ID)
+/* on tms9995, we have to handle internal CRU ports */
+static int read_single_CRU(int port)
 {
-	if (Port == 0x1EE)
+	switch (port)
+	{
+	case 0x1EE:
 		/* flag, bits 0-7 */
 		return I.flag & 0xFF;
-	else if (Port == 0x1EF)
+	case 0x1EF:
 		/* flag, bits 8-15 */
 		return (I.flag >> 8) & 0xFF;
-	else if (Port == 0x1FD)
-		/* MID flag, and extrernal devices */
+	case 0x1FD:
+		/* MID flag, and external devices */
 		if (I.MID_flag)
-			return cpu_readport16(Port) | 0x10;
+			return READPORT(port) | 0x10;
 		else
-			return cpu_readport16(Port) & ~ 0x10;
-	else
-		/* extrernal devices */
-		return cpu_readport16(Port);
+			return READPORT(port) & ~ 0x10;
+	default:
+		/* external devices */
+		return READPORT(port);
+	}
 }
-#endif
-
-static UINT16 readCRU(int CRUAddr, int Number)
-{
-#if (TMS99XX_MODEL == TMS9900_ID)
-	/* 3 MSBs are always 0 to support external instructions */
-	#define rCRUAddrMask 0x1FF
-#elif (TMS99XX_MODEL == TMS9980_ID)
-	/* 2 bits unused, and 2 MSBs are always 0 to support external instructions */
-	#define rCRUAddrMask 0x0FF
-#elif (TMS99XX_MODEL == TMS9995_ID)
-	/* no such problem here : data bus lines D0-D2 provide the external instruction code */
-	#define rCRUAddrMask 0xFFF
 #else
-	#warning "I don't know how your processor handle CRU."
-	#define rCRUAddrMask 0xFFF
+#define read_single_CRU(port) READPORT(port)
 #endif
 
+static int readCRU(int CRUAddr, int Number)
+{
 	static int BitMask[] =
 	{
 		0, /* filler - saves a subtract to find mask */
-		0x0100,0x0300,0x0700,0x0F00,0x1F00,0x3F00,0x7F00,0xFF00,
+		0x0001,0x0003,0x0007,0x000F,0x001F,0x003F,0x007F,0x00FF,
 		0x01FF,0x03FF,0x07FF,0x0FFF,0x1FFF,0x3FFF,0x7FFF,0xFFFF
 	};
 
-	int Offset,Location,Value;
+	int Offset, Location, Value;
 
-	logerror("Read CRU %x for %x\n",CRUAddr,Number);
+	/*logerror("Read CRU %x for %x\n",CRUAddr,Number);*/
 
-	Location = CRUAddr >> 3;
+	Location = (CRUAddr >> 3)  & rCRUAddrMask;
 	Offset   = CRUAddr & 07;
 
-	if (Number <= 8)
+	/* Read 8 bits */
+	#if HAS_PRIVILEGE
+		if ((I.STATUS & ST_PR) && (Location >= (0xE00 >> 3)))
+			return CRU_PRIVILEGE_VIOLATION;
+	#endif
+	Value = read_single_CRU(Location);
+
+	if ((Offset+Number) > 8)
 	{
-		/* Read 16 Bits */
-		Value = (READPORT((Location + 1) & rCRUAddrMask) << 8)
-		                                | READPORT(Location & rCRUAddrMask);
+		/* Read next 8 bits */
+		Location = (Location + 1) & rCRUAddrMask;
+		#if HAS_PRIVILEGE
+			if ((I.STATUS & ST_PR) && (Location >= (0xE00 >> 3)))
+				return CRU_PRIVILEGE_VIOLATION;
+		#endif
+		Value |= read_single_CRU(Location) << 8;
+
+		if ((Offset+Number) > 16)
+		{
+			/* Read next 8 bits */
+			Location = (Location + 1) & rCRUAddrMask;
+			#if HAS_PRIVILEGE
+				if ((I.STATUS & ST_PR) && (Location >= (0xE00 >> 3)))
+					return CRU_PRIVILEGE_VIOLATION;
+			#endif
+			Value |= read_single_CRU(Location) << 16;
+		}
+	}
 
-		/* Allow for Offset */
-		Value >>= Offset;
+	/* Allow for Offset */
+	Value >>= Offset;
 
-		/* Mask out what we want */
-		Value = (Value << 8) & BitMask[Number];
+	/* Mask out what we want */
+	Value &= BitMask[Number];
 
-		/* And update */
-		return (Value>>8);
-	}
-	else
-	{
-		/* Read 24 Bits */
-		Value = (READPORT((Location + 2) & rCRUAddrMask) << 16)
-		                                | (READPORT((Location + 1) & rCRUAddrMask) << 8)
-		                                | READPORT(Location & rCRUAddrMask);
+	/* And update */
+	return Value;
+}
+
+/*****************************************************************************/
 
-		/* Allow for Offset */
-		Value >>= Offset;
+#if HAS_MAPPING
+/* load a map file from memory */
+static void load_map_file(UINT16 src_addr, int src_map_file, int dst_file)
+{
+	int i;
 
-		/* Mask out what we want */
-		Value &= BitMask[Number];
 
-		/* and Update */
-		return Value;
+	/* load mapped address into the memory address register */
+	if ((src_map_file == 0) && (src_addr >= 0xf800))
+	{	/* intercept TPCS and CPU ROM */
+		if (src_addr < 0xfc00)
+			/* TPCS */
+			I.mapper_address_latch = 0x1f0000+src_addr;
+		else
+			/* CPU ROM */
+			I.mapper_address_latch = 0x1f0000+src_addr;	/* hack... */
 	}
-}
+	else if (! I.mapping_on)
+	{
+		I.mapper_address_latch = src_addr;
+	}
+	else
+	{
+		int map_index;
 
-/**************************************************************************/
+		if (src_addr <= I.map_files[src_map_file].limit[0])
+			map_index = 0;
+		else if (src_addr <= I.map_files[src_map_file].limit[1])
+			map_index = 1;
+		else if (src_addr <= I.map_files[src_map_file].limit[2])
+			map_index = 2;
+		else
+		{
+			if ((! I.reset_maperr) && ! (I.error_interrupt_register & EIR_MAPERR))
+			{
+				I.error_interrupt_register |= EIR_MAPERR;
+				write_inhibit = 1;
+			}
+			I.mapper_address_latch = src_addr;
+			map_index = -1;
+		}
+		if (map_index != -1)
+			I.mapper_address_latch = I.map_files[src_map_file].bias[map_index]+src_addr;
+	}
 
-/* fetch : read one word at * PC, and increment PC. */
 
-static UINT16 fetch(void)
-{
-	register UINT16 value = readword(I.PC);
-	I.PC += 2;
-	return value;
+	for (i=0; i<3; i++)
+	{
+		I.map_files[dst_file].L[i] = cpu_readmem24bew_word(I.mapper_address_latch) & 0xffe0;
+		I.map_files[dst_file].limit[i] = (I.map_files[dst_file].L[i] ^ 0xffe0) | 0x001f;
+		I.mapper_address_latch = (I.mapper_address_latch+2) & 0x1fffff;
+		I.map_files[dst_file].B[i] = cpu_readmem24bew_word(I.mapper_address_latch);
+		I.map_files[dst_file].bias[i] = ((unsigned int) I.map_files[dst_file].B[i]) << 5;
+		I.mapper_address_latch = (I.mapper_address_latch+2) & 0x1fffff;
+	}
 }
+#endif
 
-/* contextswitch : performs a BLWP, ie change PC, WP, and save PC, WP and ST... */
+/* contextswitch : performs a BLWP, i.e. load PC, WP, and save old PC, old WP and ST... */
 static void contextswitch(UINT16 addr)
 {
 	UINT16 oldWP, oldpc;
 
 	/* save old state */
@@ -1658,15 +2774,45 @@
 	WRITEREG(R14, oldpc);
 	setstat();
 	WRITEREG(R15, I.STATUS);
 }
 
+#if HAS_MAPPING || HAS_PRIVILEGE
+
+static void contextswitchX(UINT16 addr)
+{
+	UINT16 oldWP, oldpc, oldST;
+
+	/* save old state */
+	oldWP = I.WP;
+	oldpc = I.PC;
+	setstat();
+	oldST = I.STATUS;
+
+	/* load vector */
+	#if HAS_MAPPING || HAS_PRIVILEGE
+		I.STATUS = oldST & ~ (ST_PR | ST_MF);
+	#else
+		#warning "Todo..."
+	#endif
+	getstat();
+	I.WP = readword(addr) & ~1;
+	I.PC = readword(addr+2) & ~1;
+
+	/* write old state to regs */
+	WRITEREG(R13, oldWP);
+	WRITEREG(R14, oldpc);
+	WRITEREG(R15, oldST);
+}
+
+#endif
+
 /*
  * decipheraddr : compute and return the effective adress in word instructions.
  *
- * NOTA : the LSB is always ignored in word adresses,
- * but we do not set to 0 because of XOP...
+ * NOTA : the LSBit is always ignored in word adresses,
+ * but we do not set it to 0 because of XOP...
  */
 static UINT16 decipheraddr(UINT16 opcode)
 {
 	register UINT16 ts = opcode & 0x30;
 	register UINT16 reg = opcode & 0xF;
@@ -1676,37 +2822,37 @@
 	if (ts == 0)
 		/* Rx */
 		return(reg + I.WP);
 	else if (ts == 0x10)
 	{	/* *Rx */
-		CYCLES(4, 1);
+		CYCLES(0, 4, 1);
 		return(readword(reg + I.WP));
 	}
 	else if (ts == 0x20)
 	{
 		register UINT16 imm;
 
 		imm = fetch();
 
 		if (reg)
 		{	/* @>xxxx(Rx) */
-			CYCLES(8, 3);
+			CYCLES(1, 8, 3);
 			return(readword(reg + I.WP) + imm);
 		}
 		else
 		{	/* @>xxxx */
-			CYCLES(8, 1);
+			CYCLES(3, 8, 1);
 			return(imm);
 		}
 	}
 	else /*if (ts == 0x30)*/
 	{	/* *Rx+ */
 		register UINT16 response;
 
 		reg += I.WP;    /* reg now contains effective address */
 
-		CYCLES(8, 3);
+		CYCLES(1, 8, 3);
 
 		response = readword(reg);
 		writeword(reg, response+2); /* we increment register content */
 		return(response);
 	}
@@ -1723,76 +2869,101 @@
 	if (ts == 0)
 		/* Rx */
 		return(reg + I.WP);
 	else if (ts == 0x10)
 	{	/* *Rx */
-		CYCLES(4, 1);
+		CYCLES(0, 4, 1);
 		return(readword(reg + I.WP));
 	}
 	else if (ts == 0x20)
 	{
 		register UINT16 imm;
 
 		imm = fetch();
 
 		if (reg)
 		{	/* @>xxxx(Rx) */
-			CYCLES(8, 3);
+			CYCLES(1, 8, 3);
 			return(readword(reg + I.WP) + imm);
 		}
 		else
 		{	/* @>xxxx */
-			CYCLES(8, 1);
+			CYCLES(3, 8, 1);
 			return(imm);
 		}
 	}
 	else /*if (ts == 0x30)*/
 	{	/* *Rx+ */
 		register UINT16 response;
 
 		reg += I.WP;    /* reg now contains effective address */
 
-		CYCLES(6, 3);
+		CYCLES(1, 6, 3);
 
 		response = readword(reg);
 		writeword(reg, response+1); /* we increment register content */
 		return(response);
 	}
 }
 
 
 /*************************************************************************/
 
-#if TMS99XX_MODEL <= TMS9989_ID
+#if (TMS99XX_MODEL == TI990_10_ID)
+	/* TI990/10 generates an error interrupt */
+	/* timings are unknown */
+	#define HANDLE_ILLEGAL													\
+	{																		\
+		I.error_interrupt_register |= EIR_ILLOP;							\
+		if (I.error_interrupt_callback)										\
+			(*I.error_interrupt_callback)(1);								\
+	}
+#elif TMS99XX_MODEL <= TMS9989_ID
 	/* TMS9900/TMS9980 merely ignore the instruction */
 	#define HANDLE_ILLEGAL TMS99XX_ICOUNT -= 6
 #elif TMS99XX_MODEL == TMS9995_ID
 	/* TMS9995 generates a MID interrupt */
 	#define HANDLE_ILLEGAL \
 	{ \
 		I.MID_flag = 1; \
-		contextswitch(0x0008); \
+		contextswitchX(0x0008); \
 		I.STATUS = (I.STATUS & 0xFE00) | 0x1; \
-		disable_interrupt_recognition = 1; \
+		I.disable_interrupt_recognition = 1; \
 	}
 #else
-#define HANDLE_ILLEGAL
-#warning "don't know"
+	#define HANDLE_ILLEGAL
+	#warning "don't know"
+#endif
+
+#if HAS_PRIVILEGE
+	#if (TMS99XX_MODEL == TI990_10_ID)
+		/* TI990/10 generates an error interrupt */
+		/* timings are unknown */
+		#define HANDLE_PRIVILEGE_VIOLATION									\
+		{																	\
+			I.error_interrupt_register |= EIR_PRIVOP;						\
+			if (I.error_interrupt_callback)									\
+				(*I.error_interrupt_callback)(1);							\
+		}
+	#else
+		#define HANDLE_PRIVILEGE_VIOLATION
+		#warning "don't know"
+	#endif
 #endif
 
 /*==========================================================================
    Illegal instructions                                        >0000->01FF (not for 9989 and later)
-                                                               >0C00->0FFF (not for 99xxx)
+                                                               >0C00->0FFF (not for 990/12 and 99110)
 ============================================================================*/
 
 static void illegal(UINT16 opcode)
 {
 	HANDLE_ILLEGAL;
 }
 
 
-#if (TMS99XX_MODEL >= TMS99105A_ID)
+#if 0		/* ti990/12 only */
 /*==========================================================================
    Additionnal instructions,                                   >0000->002F
    Additionnal single-register instruction,                    >0030->003F
  ---------------------------------------------------------------------------
 
@@ -1800,102 +2971,82 @@
     ---------------------------------
     |     o p c o d e               |
     |     o p c o d e       | reg # |
     ---------------------------------
 
-tms99xxx : SRAM, SLAM, AM, SM
 ============================================================================*/
 static void h0000(UINT16 opcode)
 {
-#if 0
-	if (opcode & 0x30)
+	if (opcode >= 0x30)
 	{	/* STPC STore Program Counter */
 
 	}
 	else
-#endif
-
-	switch (opcode /*& 0x3F*/)
 	{
-	case 0x1C:  /* SRAM */
-		/* SRAM -- Shift Right Arithmetic Multiple */
-		/* right shift on a 32-bit operand */
-		/* ... */
-		break;
-	case 0x1D:  /* SLAM */
-		/* SLAM -- Shift Left Arithmetic Multiple */
-		/* left shift on a 32-bit operand */
-		/* ... */
-		break;
-
-	case 0x29:  /* AM (or SM ?) */
-		/* AM ---- Add Multiple */
-		/* add with 32-bit operands */
-		/* ... */
-		break;
-	case 0x2A:  /* SM (or AM ?) */
-		/* SM ---- Subtract Multiple */
-		/* substract with 32-bit operands */
-		/* ... */
-		break;
-
-#if 0
-	case 0x1E:
-		/* RTO --- Right Test for One */
-	case 0x1F:
-		/* LTO --- Left Test for One */
-	case 0x20:
-		/* CNTO -- CouNT Ones */
-	case 0x21:
-		/* SLSL -- Search LiSt Logical address */
-	case 0x22:
-		/* SLSP -- Search LiSt Physical address */
-	case 0x23:
-		/* BDC --- Binary to Decimal ascii Conversion */
-	case 0x24:
-		/* DBC --- Decimal ascii to Binary Conversion */
-	case 0x25:
-		/* SWPM -- SWaP Multiple precision */
-	case 0x26:
-		/* XORM -- eXclusive OR Multiple precision */
-	case 0x27:
-		/* ORM --- OR Multiple precision */
-	case 0x28:
-		/* ANDM -- AND Multiple precision */
-
-	case 0x2B:
-		/* MOVA -- MOVe Address */
-	case 0x2D:
-		/* EMD --- Execute Micro-Diagnostics */
-	case 0x2E:
-		/* EINT -- Enable INTerrupts */
-	case 0x2F:
-		/* DINT -- Disable INTerrupts */
+		switch (opcode /*& 0x3F*/)
+		{
+		case 0x1C:  /* SRAM */
+			/* SRAM -- Shift Right Arithmetic Multiple precision */
+		case 0x1D:  /* SLAM */
+			/* SLAM -- Shift Left Arithmetic Multiple precision */
+		case 0x1E:
+			/* RTO --- Right Test for Ones */
+		case 0x1F:
+			/* LTO --- Left Test for Ones */
+		case 0x20:
+			/* CNTO -- CouNT Ones */
+		case 0x21:
+			/* SLSL -- Search LiSt Logical address */
+		case 0x22:
+			/* SLSP -- Search LiSt Physical address */
+		case 0x23:
+			/* BDC --- Binary to Decimal ascii Conversion */
+		case 0x24:
+			/* DBC --- Decimal to Binary ascii Conversion */
+		case 0x25:
+			/* SWPM -- SWaP Multiple precision */
+		case 0x26:
+			/* XORM -- eXclusive OR Multiple precision */
+		case 0x27:
+			/* ORM --- OR Multiple precision */
+		case 0x28:
+			/* ANDM -- AND Multiple precision */
+		case 0x29:  /* SM */
+			/* SM ---- Subtract Multiple precision integer */
+		case 0x2A:  /* AM */
+			/* AM ---- Add Multiple precision integer */
+		case 0x2B:
+			/* MOVA -- MOVe Address */
+		case 0x2D:
+			/* EMD --- Execute Micro-Diagnostics */
+		case 0x2E:
+			/* EINT -- Enable INTerrupts */
+		case 0x2F:
+			/* DINT -- Disable INTerrupts */
 
-		break;
-#endif
+			break;
 
-	default:
-		HANDLE_ILLEGAL;
-		break;
+		default:
+			HANDLE_ILLEGAL;
+			break;
+		}
 	}
 }
 #endif
 
 
-#if (TMS99XX_MODEL >= TMS9989_ID)
+#if HAS_9995_OPCODES
 /*==========================================================================
    Additionnal single-register instructions,                   >0040->00FF
  ---------------------------------------------------------------------------
 
      0 1 2 3-4 5 6 7+8 9 A B-C D E F
     ---------------------------------
     |     o p c o d e       | reg # |
     ---------------------------------
 
 tms9989 and later : LST, LWP
-tms99xxx : BLSK
 ============================================================================*/
 static void h0040(UINT16 opcode)
 {
 	register UINT16 addr;
 
@@ -1905,26 +3056,28 @@
 	switch ((opcode & 0xF0) >> 4)
 	{
 	case 8:   /* LST */
 		/* LST --- Load STatus register */
 		/* ST = *Reg */
-		I.STATUS = readword(addr);
+		#if HAS_PRIVILEGE
+			if (I.STATUS & ST_PR)
+				I.STATUS = (I.STATUS & 0x01DF) | (readword(addr) & 0xFE20);
+			else
+				I.STATUS = readword(addr);
+		#else
+			I.STATUS = readword(addr);
+		#endif
+		getstat();  /* set last_parity */
 		break;
+
 	case 9:   /* LWP */
-		/* LWP --- Load Workspace Pointer register */
+		/* LWP --- Load Workspace Pointer */
 		/* WP = *Reg */
 		I.WP = readword(addr);
 		break;
 
-#if (TMS99XX_MODEL >= TMS99105A_ID)
-	case 11:  /* BLSK */
-		/* BLSK -- Branch immediate & Link to StacK */
-
-		break;
-#endif
-
-#if 0
+#if 0	/* 990/12 opcodes */
 	case 4:
 		/* CS ---- Compare Strings */
 	case 5:
 		/* SEQB -- Search string for EQual Byte */
 	case 6:
@@ -1933,16 +3086,19 @@
 		/* LIM --- Load Interrupt Mask	*/
 
 	case 10:
 		/* LCS --- Load writable Control Store */
 
+	case 11:  /* BLSK */
+		/* BLSK -- Branch immediate and push Link to StacK */
+
 	case 12:
 		/* MVSR -- MoVe String Reverse */
 	case 13:
-		/* MVSK -- MoVe String from stacK */
+		/* MVSK -- MoVe string from StacK */
 	case 14:
-		/* POPS -- POP String from stack	*/
+		/* POPS -- POP String from stack */
 	case 15:
 		/* PSHS -- PuSH String to stack */
 
 		break;
 #endif
@@ -1967,52 +3123,57 @@
 tms99xxx : BIND
 ============================================================================*/
 static void h0100(UINT16 opcode)
 {
 	register UINT16 src;
+#if HAS_MAPPING
+	int src_map = (opcode & 0x0030) ? I.cur_src_map : I.cur_map;
+#endif
 
 	src = decipheraddr(opcode) & ~1;
 
-  switch ((opcode & 0xC0) >> 6)
-  {
-#if (TMS99XX_MODEL >= TMS99105A_ID)
-	case 1:
+	switch ((opcode & 0xC0) >> 6)
+	{
+#if HAS_BIND_OPCODE
+	case 1:   /* BIND */
 		/* BIND -- Branch INDirect */
-
+		I.PC = readwordX(src, src_map);
+		CYCLES(Mooof!, Mooof!, 4 /*don't know*/);
 		break;
 #endif
 
-  case 2:   /* DIVS */
+	case 2:   /* DIVS */
 		/* DIVS -- DIVide Signed */
 		/* R0 = (R0:R1)/S   R1 = (R0:R1)%S */
 		{
-			INT16 d = readword(src);
-			long divq = (READREG(R0) << 16) | READREG(R1);
-			long q = divq/d;
+			INT16 d = readwordX(src, src_map);
+			INT32 divq = (READREG(R0) << 16) | READREG(R1);
+			INT32 q = divq/d;
 
 			if ((q < -32768L) || (q > 32767L))
 			{
 				I.STATUS |= ST_OV;
-				CYCLES(24 /*don't know*/, 10);
+				CYCLES(Mooof!, Mooof!, 10);
 			}
 			else
 			{
 				I.STATUS &= ~ST_OV;
 				setst_lae(q);
 				WRITEREG(R0, q);
 				WRITEREG(R1, divq%d);
 				/* tms9995 : 33 is the worst case */
-				CYCLES(102 /*don't know*/, 33);
+				CYCLES(Mooof!, Mooof!, 33);
 			}
 		}
 		break;
 
-  case 3:   /* MPYS */
+	case 3:   /* MPYS */
 		/* MPYS -- MultiPlY Signed */
 		/* Results:  R0:R1 = R0*S */
 		{
-			long prod = ((long) (INT16) READREG(R0)) * ((long) (INT16) readword(src));
+			INT32 prod = ((INT32) (INT16) readwordX(src, src_map));
+			prod = prod*((INT32) (INT16) READREG(R0));
 
 			I.STATUS &= ~ (ST_LGT | ST_AGT | ST_EQ);
 			if (prod > 0)
 				I.STATUS |= (ST_LGT | ST_AGT);
 			else if (prod < 0)
@@ -2021,15 +3182,15 @@
 				I.STATUS |= ST_EQ;
 
 			WRITEREG(R0, prod >> 16);
 			WRITEREG(R1, prod);
 		}
-		CYCLES(56 /*don't know*/, 25);
+		CYCLES(Mooof!, Mooof!, 25);
 		break;
 
-#if 0
-	case 0:
+#if 0	/* Origin unknown */
+	case 0:   /* EVAD */
 		/* EVAD -- EValuate ADdress instruction */
 
 		break;
 #endif
 
@@ -2049,174 +3210,346 @@
     ---------------------------------
     |     o p c o d e     |0| reg # |
     ---------------------------------
 
   LI, AI, ANDI, ORI, CI, STWP, STST, LIMI, LWPI, IDLE, RSET, RTWP, CKON, CKOF, LREX
+systems with memory mapper: LMF
 ============================================================================*/
 static void h0200(UINT16 opcode)
 {
 	register UINT16 addr;
 	register UINT16 value;	/* used for anything */
 
 	addr = opcode & 0xF;
 	addr = ((addr + addr) + I.WP) & ~1;
 
-#if 0
-	if ((opcode >= 0x0320) && (opcode < 0x0340))
-	{	/* LMF */
-		/* LMF --- Load memory Map File */
-		/* I don't know what it does exactly.  I guess it was used by some paging system on some
-		TI990/10 variant.
-		Syntax : LMF Rx,x; where Rx can be any workspace register from 0 thru 15, and x can be
-		a `0' or a `1'. */
-		/* ... */
-		return;
-	}
-#endif
+	#if HAS_MAPPING
+		if ((opcode >= 0x0320) && (opcode < 0x0340))
+		{	/* LMF */
+			/* LMF --- Load memory Map File */
+			/* Used by the memory mapper on ti990/10 with mapping option, ti990/12, and the TIM99610
+			mapper chip to be associated with tms99000.
+			Syntax: "LMF Rn,m" loads map file m (0 or 1) with six words of memory, starting at address
+			specified in workspace register Rn (0 thru 15). */
+			#if HAS_PRIVILEGE
+				if (I.STATUS & ST_PR)
+				{
+					HANDLE_PRIVILEGE_VIOLATION
+					return;
+				}
+			#endif
 
-#if (TMS99XX_MODEL >= TMS9995_ID)
-	/* better instruction decoding on tms9995 */
-	if (((opcode < 0x2E0) && (opcode & 0x10)) || ((opcode >= 0x2E0) && (opcode & 0x1F)))
-	{
-#if 0
-		if (opcode == 0x0301)
-		{	/* CR ---- Compare Reals */
+			/* read address pointer */
+			addr = readword(addr);
+
+			load_map_file(addr, I.cur_map, (opcode & 0x10) ? 1 : 0);
+
+			CYCLES(3, Mooof!, Mooof!);
+			return;
 		}
-		else if (opcode == 0x0301)
-		{	/* MM ---- Multiply Multiple */
+	#endif
+
+	#if BETTER_0200_DECODING
+		/* better instruction decoding on ti990/10 */
+		if (opcode & 0x10)
+		{
+			HANDLE_ILLEGAL;
+			return;
 		}
-		else if (opcode >= 0x03F0)
-		{	/* EP ---- Extend Precision */
+	#elif COMPLETE_0200_DECODING
+		/* full instruction decoding on tms9995 */
+		if (((opcode < 0x2E0) && (opcode & 0x10)) || ((opcode >= 0x2E0) && (opcode & 0x1F)))
+		{
+		#if 0	/* Origin unknown */
+			if (opcode == 0x0301)
+			{	/* CR ---- Compare Reals */
+			}
+			else if (opcode == 0x0302)
+			{	/* MM ---- Multiply Multiple */
+			}
+			else
+		#endif
+		#if 0	/* ti990/12 only */
+			if (opcode >= 0x03F0)
+			{	/* EP ---- Extended Precision */
+			}
+			else
+		#endif
+			HANDLE_ILLEGAL;
+			return;
 		}
-		else
-#endif
-		HANDLE_ILLEGAL;
-		return;
-	}
-#endif
+	#endif
 
 	switch ((opcode & 0x1e0) >> 5)
 	{
 	case 0:   /* LI */
 		/* LI ---- Load Immediate */
 		/* *Reg = *PC+ */
 		value = fetch();
 		writeword(addr, value);
 		setst_lae(value);
-		CYCLES(12, 3);
+		CYCLES(3, 12, 3);
 		break;
+
 	case 1:   /* AI */
 		/* AI ---- Add Immediate */
 		/* *Reg += *PC+ */
 		value = fetch();
-		wadd(addr, value);
-		CYCLES(14, 4);
+		value = setst_add_laeco(readword(addr), value);
+		writeword(addr, value);
+		CYCLES(4, 14, 4);
 		break;
+
 	case 2:   /* ANDI */
 		/* ANDI -- AND Immediate */
 		/* *Reg &= *PC+ */
 		value = fetch();
 		value = readword(addr) & value;
 		writeword(addr, value);
 		setst_lae(value);
-		CYCLES(14, 4);
+		CYCLES(4, 14, 4);
 		break;
+
 	case 3:   /* ORI */
 		/* ORI --- OR Immediate */
 		/* *Reg |= *PC+ */
 		value = fetch();
 		value = readword(addr) | value;
 		writeword(addr, value);
 		setst_lae(value);
-		CYCLES(14, 4);
+		CYCLES(4, 14, 4);
 		break;
+
 	case 4:   /* CI */
 		/* CI ---- Compare Immediate */
 		/* status = (*Reg-*PC+) */
 		value = fetch();
 		setst_c_lae(value, readword(addr));
-		CYCLES(14, 4);
+		CYCLES(6, 14, 4);
 		break;
+
 	case 5:   /* STWP */
 		/* STWP -- STore Workspace Pointer */
 		/* *Reg = WP */
 		writeword(addr, I.WP);
-		CYCLES(8, 3);
+		CYCLES(2, 8, 3);
 		break;
+
 	case 6:   /* STST */
 		/* STST -- STore STatus register */
 		/* *Reg = ST */
 		setstat();
 		writeword(addr, I.STATUS);
-		CYCLES(8, 3);
+		CYCLES(2, 8, 3);
 		break;
+
 	case 7:   /* LWPI */
 		/* LWPI -- Load Workspace Pointer Immediate */
 		/* WP = *PC+ */
 		I.WP = fetch();
-		CYCLES(10, 4);
+		CYCLES(3, 10, 4);
 		break;
+
 	case 8:   /* LIMI */
 		/* LIMI -- Load Interrupt Mask Immediate */
 		/* ST&15 |= (*PC+)&15 */
+		#if HAS_PRIVILEGE
+			if (I.STATUS & ST_PR)
+			{
+				HANDLE_PRIVILEGE_VIOLATION
+				break;
+			}
+		#endif
+
 		value = fetch();
-#if (TMS99XX_MODEL == TMS9940_ID)
-		/* Interrupt mask is only two-bit-long on tms9940 */
-		I.STATUS = (I.STATUS & ~ 0x3) | (value & 0x3);
-#else
-		I.STATUS = (I.STATUS & ~ 0xF) | (value & 0xF);
-#endif
+		I.STATUS = (I.STATUS & ~ST_IM) | (value & ST_IM);
 		field_interrupt();  /*IM has been modified.*/
-		CYCLES(16, 5);
+		CYCLES(3, 16, 5);
 		break;
+
 	case 9:   /* LMF is implemented elsewhere - when it is implemented */
 		HANDLE_ILLEGAL;
 		break;
+
 	case 10:  /* IDLE */
 		/* IDLE -- IDLE until a reset, interrupt, load */
 		/* The TMS99000 locks until an interrupt happen (like with 68k STOP instruction),
 		   and continuously performs a special CRU write (code 2). */
+		#if HAS_PRIVILEGE
+			if (I.STATUS & ST_PR)
+			{
+				HANDLE_PRIVILEGE_VIOLATION
+				break;
+			}
+		#endif
 		I.IDLE = 1;
-		external_instruction_notify(2);
-		CYCLES(12, 7);
+		#if EXTERNAL_INSTRUCTION_DECODING
+			external_instruction_notify(2);
+		#endif
+		if (I.idle_callback)
+			(*I.idle_callback)(1);
+		CYCLES(4, 12, 7);
 		/* we take care of further external_instruction_notify(2); in execute() */
 		break;
-	case 11:  /* RSET */
-		/* RSET -- ReSET */
-		/* Reset the Interrupt Mask, and perform a special CRU write (code 3). */
-		/* Does not actually cause a reset, but an external circuitery could trigger one. */
-		I.STATUS &= 0xFFF0; /*clear IM.*/
-		field_interrupt();  /*IM has been modified.*/
-		external_instruction_notify(3);
-		CYCLES(12, 7);
-		break;
+
 	case 12:  /* RTWP */
 		/* RTWP -- Return with Workspace Pointer */
 		/* WP = R13, PC = R14, ST = R15 */
-		I.STATUS = READREG(R15);
+		addr = (I.WP + R13) & ~1;
+		I.WP = readword(addr);
+		addr += 2;
+		I.PC = readword(addr);
+		addr += 2;
+		#if HAS_PRIVILEGE
+			if (I.STATUS & ST_PR)
+				I.STATUS = (I.STATUS & 0x01DF) | (readword(addr) & 0xFE20);
+			else
+				I.STATUS = readword(addr);
+		#else
+			I.STATUS = readword(addr);
+		#endif
 		getstat();  /* set last_parity */
-		I.PC = READREG(R14);
-		I.WP = READREG(R13);
+
+		field_interrupt();  /*IM has been modified.*/
+		CYCLES(3, 14, 6);
+		break;
+
+#if (TMS99XX_MODEL == TMS9940_ID) || (TMS99XX_MODEL == TMS9985_ID)
+
+	case 11:  /* RSET */
+	case 13:  /* CKON */
+	case 14:  /* CKOF */
+	case 15:  /* LREX */
+		HANDLE_ILLEGAL;	/* These instruction "have been deleted" on the TMS9940 */
+		break;
+
+#else
+
+	case 11:  /* RSET */
+		/* RSET -- ReSET */
+		/* Reset the Interrupt Mask, and perform a special CRU write (code 3). */
+		/* The CRU write is supposed to reset external devices. */
+		#if HAS_PRIVILEGE
+			if (I.STATUS & ST_PR)
+			{
+				HANDLE_PRIVILEGE_VIOLATION
+				break;
+			}
+		#endif
+
+		I.STATUS &= 0xFFF0; /*clear IM.*/
 		field_interrupt();  /*IM has been modified.*/
-		CYCLES(14, 6);
+
+		#if (TMS99XX_MODEL == TMS9995_ID)
+			/*I.MID_flag = 0;*/		/* not sure about this */
+		#endif
+		#if (TMS99XX_MODEL == TI990_10_ID)
+			I.error_interrupt_register = 0;
+			I.mapping_on = 0;
+
+			I.reset_maperr = 0;
+			I.mapper_cru_read_register = 0;
+			I.latch_control[0] = I.latch_control[1] = I.latch_control[2] = 0;
+
+			I.diaglat = 0;
+		#endif
+
+		#if EXTERNAL_INSTRUCTION_DECODING
+			external_instruction_notify(3);
+		#endif
+
+		#if EXTERNAL_INSTRUCTION_CALLBACK
+			if (I.rset_callback)
+				(*I.rset_callback)();
+		#endif
+
+		CYCLES(5, 12, 7);
 		break;
+
+#if EXTERNAL_INSTRUCTION_DECODING
+
 	case 13:  /* CKON */
 	case 14:  /* CKOF */
 	case 15:  /* LREX */
 		/* CKON -- ClocK ON */
 		/* Perform a special CRU write (code 5). */
-		/* An external circuitery could, for instance, enable a "decrement-and-interrupt" timer. */
+		/* An external circuitery could, for instance, enable the line clock interrupt (100Hz or 120Hz, depending on voltage). */
 		/* CKOF -- ClocK OFf */
 		/* Perform a special CRU write (code 6). */
-		/* An external circuitery could, for instance, disable a "decrement-and-interrupt" timer. */
+		/* An external circuitery could, for instance, disable the line clock interrupt. */
 		/* LREX -- Load or REstart eXecution */
 		/* Perform a special CRU write (code 7). */
 		/* An external circuitery could, for instance, activate the LOAD* line,
 		   causing a non-maskable LOAD interrupt (vector -1). */
+		#if HAS_PRIVILEGE
+			if (I.STATUS & ST_PR)
+			{
+				HANDLE_PRIVILEGE_VIOLATION
+				break;
+			}
+		#endif
+
 		external_instruction_notify((opcode & 0x00e0) >> 5);
-		CYCLES(12, 7);
+
+		#if EXTERNAL_INSTRUCTION_CALLBACK
+			#warning "todo..."
+		#endif
+
+		CYCLES(Mooof!, 12, 7);
+		break;
+
+#elif EXTERNAL_INSTRUCTION_CALLBACK
+
+	case 13:  /* CKON */
+	case 14:  /* CKOF */
+		/* CKON -- ClocK ON */
+		/* Perform a special CRU write (code 5). */
+		/* An external circuitery could, for instance, enable the line clock interrupt (100Hz or 120Hz, depending on voltage). */
+		/* CKOF -- ClocK OFf */
+		/* Perform a special CRU write (code 6). */
+		/* An external circuitery could, for instance, disable the line clock interrupt. */
+		#if HAS_PRIVILEGE
+			if (I.STATUS & ST_PR)
+			{
+				HANDLE_PRIVILEGE_VIOLATION
+				break;
+			}
+		#endif
+
+		if (I.ckon_ckof_callback)
+			(*I.ckon_ckof_callback)((opcode & 0x0020) ? 1 : 0);
+
+
+		CYCLES(5, Mooof!, Mooof!);
+		break;
+
+	case 15:  /* LREX */
+		/* LREX -- Load or REstart eXecution */
+		/* Perform a special CRU write (code 7). */
+		/* An external circuitery could, for instance, activate the LOAD* line,
+		   causing a non-maskable LOAD interrupt (vector -1). */
+		#if HAS_PRIVILEGE
+			if (I.STATUS & ST_PR)
+			{
+				HANDLE_PRIVILEGE_VIOLATION
+				break;
+			}
+		#endif
+
+		if (I.lrex_callback)
+			(*I.lrex_callback)();
+
+		CYCLES(6, Mooof!, Mooof!);
 		break;
+
+#else
+
+	#warning "Should not happen..."
+
+#endif
+
+#endif
 	}
 }
 
 
 /*==========================================================================
@@ -2227,156 +3560,173 @@
     ---------------------------------
     |    o p c o d e    |TS |   S   |
     ---------------------------------
 
   BLWP, B, X, CLR, NEG, INV, INC, INCT, DEC, DECT, BL, SWPB, SETO, ABS
-tms99xxx : LDD, LDS
+systems with memory mapper: LDD, LDS
 ============================================================================*/
 static void h0400(UINT16 opcode)
 {
 	register UINT16 addr = decipheraddr(opcode) & ~1;
 	register UINT16 value;  /* used for anything */
+#if HAS_MAPPING
+	int src_map = (opcode & 0x0030) ? I.cur_src_map : I.cur_map;
+#endif
 
 	switch ((opcode & 0x3C0) >> 6)
 	{
 	case 0:   /* BLWP */
 		/* BLWP -- Branch and Link with Workspace Pointer */
 		/* Result: WP = *S+, PC = *S */
 		/*         New R13=old WP, New R14=Old PC, New R15=Old ST */
 		contextswitch(addr);
-		CYCLES(26, 11);
-		disable_interrupt_recognition = 1;
+		CYCLES(3, 26, 11);
+		I.disable_interrupt_recognition = 1;
 		break;
 	case 1:   /* B */
 		/* B ----- Branch */
 		/* PC = S */
 		I.PC = addr;
-		CYCLES(8, 3);
+		CYCLES(2, 8, 3);
 		break;
 	case 2:   /* X */
 		/* X ----- eXecute */
 		/* Executes instruction *S */
-		execute(readword(addr));
+		execute(readwordX(addr, src_map));
 		/* On tms9900, the X instruction actually takes 8 cycles, but we gain 4 cycles on the next
 		instruction, as we don't need to fetch it. */
-		CYCLES(4, 2);
+		CYCLES(1, 4, 2);
 		break;
 	case 3:   /* CLR */
 		/* CLR --- CLeaR */
 		/* *S = 0 */
-		writeword(addr, 0);
-		CYCLES(10, 3);
+		writewordX(addr, 0, src_map);
+		CYCLES(2, 10, 3);
 		break;
 	case 4:   /* NEG */
 		/* NEG --- NEGate */
 		/* *S = -*S */
-		value = - (INT16) readword(addr);
+		value = - (INT16) readwordX(addr, src_map);
 		if (value)
 			I.STATUS &= ~ ST_C;
 		else
 			I.STATUS |= ST_C;
-#if (TMS99XX_MODEL == TMS9940_ID)
-		if (value & 0x0FFF)
-			I.STATUS &= ~ ST_DC;
-		else
-			I.STATUS |= ST_DC;
-#endif
+
+		#if (TMS99XX_MODEL == TMS9940_ID) || (TMS99XX_MODEL == TMS9985_ID)
+			if (value & 0x0FFF)
+				I.STATUS &= ~ ST_DC;
+			else
+				I.STATUS |= ST_DC;
+		#endif
+
 		setst_laeo(value);
-		writeword(addr, value);
-		CYCLES(12, 3);
+		writewordX(addr, value, src_map);
+		CYCLES(3, 12, 3);
 		break;
 	case 5:   /* INV */
 		/* INV --- INVert */
 		/* *S = ~*S */
-		value = ~ readword(addr);
-		writeword(addr, value);
+		value = ~ readwordX(addr, src_map);
+		writewordX(addr, value, src_map);
 		setst_lae(value);
-		CYCLES(10, 3);
+		CYCLES(2, 10, 3);
 		break;
 	case 6:   /* INC */
 		/* INC --- INCrement */
 		/* (*S)++ */
-		wadd(addr, 1);
-		CYCLES(10, 3);
+		value = setst_add_laeco(readwordX(addr, src_map), 1);
+		writewordX(addr, value, src_map);
+		CYCLES(2, 10, 3);
 		break;
 	case 7:   /* INCT */
 		/* INCT -- INCrement by Two */
 		/* (*S) +=2 */
-		wadd(addr, 2);
-		CYCLES(10, 3);
+		value = setst_add_laeco(readwordX(addr, src_map), 2);
+		writewordX(addr, value, src_map);
+		CYCLES(2, 10, 3);
 		break;
 	case 8:   /* DEC */
 		/* DEC --- DECrement */
 		/* (*S)-- */
-		wsub(addr, 1);
-		CYCLES(10, 3);
+		value = setst_sub_laeco(readwordX(addr, src_map), 1);
+		writewordX(addr, value, src_map);
+		CYCLES(2, 10, 3);
 		break;
 	case 9:   /* DECT */
 		/* DECT -- DECrement by Two */
 		/* (*S) -= 2 */
-		wsub(addr, 2);
-		CYCLES(10, 3);
+		value = setst_sub_laeco(readwordX(addr, src_map), 2);
+		writewordX(addr, value, src_map);
+		CYCLES(2, 10, 3);
 		break;
 	case 10:  /* BL */
 		/* BL ---- Branch and Link */
 		/* IP=S, R11=old IP */
 		WRITEREG(R11, I.PC);
 		I.PC = addr;
-		CYCLES(12, 5);
+		CYCLES(3, 12, 5);
 		break;
 	case 11:  /* SWPB */
 		/* SWPB -- SWaP Bytes */
 		/* *S = swab(*S) */
-		value = readword(addr);
+		value = readwordX(addr, src_map);
 		value = logical_right_shift(value, 8) | (value << 8);
-		writeword(addr, value);
-		CYCLES(10, 13);
+		writewordX(addr, value, src_map);
+		CYCLES(2, 10, 13);
 		break;
 	case 12:  /* SETO */
-		/* SETO -- SET Ones */
+		/* SETO -- SET to Ones */
 		/* *S = #$FFFF */
-		writeword(addr, 0xFFFF);
-		CYCLES(10, 3);
+		writewordX(addr, 0xFFFF, src_map);
+		CYCLES(2, 10, 3);
 		break;
 	case 13:  /* ABS */
 		/* ABS --- ABSolute value */
 		/* *S = |*S| */
 		/* clearing ST_C seems to be necessary, although ABS will never set it. */
 #if (TMS99XX_MODEL <= TMS9985_ID)
-		/* tms9900/tms9980 only write the result if it has changed */
+
+		/* ti990/10 and tms9900/tms9980 only write the result if it has changed */
 		I.STATUS &= ~ (ST_LGT | ST_AGT | ST_EQ | ST_C | ST_OV);
-#if (TMS99XX_MODEL == TMS9940_ID)
-		/* I guess ST_DC is cleared here, too*/
-		I.STATUS &= ~ ST_DC;
-#endif
-		value = readword(addr);
 
-		CYCLES(12, Mooof!);
+		#if (TMS99XX_MODEL == TMS9940_ID) || (TMS99XX_MODEL == TMS9985_ID)
+			/* I guess ST_DC is cleared here, too*/
+			I.STATUS &= ~ ST_DC;
+		#endif
+
+		value = readwordX(addr, src_map);
+
+		CYCLES(5, 12, Mooof!);
 
 		if (((INT16) value) > 0)
 			I.STATUS |= ST_LGT | ST_AGT;
 		else if (((INT16) value) < 0)
 		{
 			I.STATUS |= ST_LGT;
 			if (value == 0x8000)
 				I.STATUS |= ST_OV;
-#if (TMS99XX_MODEL == TMS9940_ID)
-			if (! (value & 0x0FFF))
-				I.STATUS |= ST_DC;
-#endif
-			writeword(addr, - ((INT16) value));
-			CYCLES(2, Mooof!);
+
+			#if (TMS99XX_MODEL == TMS9940_ID) || (TMS99XX_MODEL == TMS9985_ID)
+				if (! (value & 0x0FFF))
+					I.STATUS |= ST_DC;
+			#endif
+
+			writewordX(addr, - ((INT16) value), src_map);
+			CYCLES(0, 2, Mooof!);
 		}
 		else
 			I.STATUS |= ST_EQ;
 
+		break;
+
 #else
+
 		/* tms9995 always write the result */
 		I.STATUS &= ~ (ST_LGT | ST_AGT | ST_EQ | ST_C | ST_OV);
-		value = readword(addr);
+		value = readwordX(addr, src_map);
 
-		CYCLES(12 /*Don't know for tms9989*/, 3);
+		CYCLES(Mooof!, Mooof!, 3);
 		if (((INT16) value) > 0)
 			I.STATUS |= ST_LGT | ST_AGT;
 		else if (((INT16) value) < 0)
 		{
 			I.STATUS |= ST_LGT;
@@ -2385,30 +3735,60 @@
 			value = - ((INT16) value);
 		}
 		else
 			I.STATUS |= ST_EQ;
 
-		writeword(addr, value);
-#endif
+		writewordX(addr, value, src_map);
 
 		break;
-#if (TMS99XX_MODEL >= TMS99105A_ID)
-	/* "These opcode are designed to support the 99610 memory mapper, to allow easy access to
-	another page without the need of switching a page someplace." */
+
+#endif
+
+
+#if HAS_MAPPING
+	/* Used by the memory mapper on ti990/10 with mapping option, ti990/12, and the TIM99610
+	mapper chip to be associated with tms99000. */
+	/* These opcode allow access to another page without the need of switching a page someplace. */
+	/* Note that, if I read the 990/10 schematics correctly, two consecutive LDS or LDD would
+	cause some trouble.  */
 	case 14:  /* LDS */
 		/* LDS --- Long Distance Source */
-		/* ... */
+
+		#if HAS_PRIVILEGE
+			if (I.STATUS & ST_PR)
+			{
+				HANDLE_PRIVILEGE_VIOLATION
+				break;
+			}
+		#endif
+
+		load_map_file(addr, src_map, 2);
+		lds_flag = 1;
+		I.disable_interrupt_recognition = 1;
 		break;
 	case 15:  /* LDD */
 		/* LDD --- Long Distance Destination */
-		/* ... */
+		#if HAS_PRIVILEGE
+			if (I.STATUS & ST_PR)
+			{
+				HANDLE_PRIVILEGE_VIOLATION
+				break;
+			}
+		#endif
+
+		load_map_file(addr, src_map, 2);
+		ldd_flag = 1;
+		I.disable_interrupt_recognition = 1;
 		break;
+
 #else
+
 	default:
 		/* illegal instructions */
 		HANDLE_ILLEGAL;
 		break;
+
 #endif
 	}
 }
 
 
@@ -2430,23 +3810,23 @@
 	register UINT16 value;
 
 	addr = (opcode & 0xF);
 	addr = ((addr+addr) + I.WP) & ~1;
 
-	CYCLES(12, 5);
+	CYCLES(3, 12, 5);
 
 	if (cnt == 0)
 	{
-		CYCLES(8, 2);
+		CYCLES(2, 8, 2);
 
-		cnt = READREG(0) & 0xF;
+		cnt = READREG(R0) & 0xF;
 
 		if (cnt == 0)
 			cnt = 16;
 	}
 
-	CYCLES(cnt+cnt, cnt);
+	CYCLES(cnt, cnt+cnt, cnt);
 
 	switch ((opcode & 0x300) >> 8)
 	{
 	case 0:   /* SRA */
 		/* SRA --- Shift Right Arithmetic */
@@ -2474,11 +3854,11 @@
 		break;
 	}
 }
 
 
-#if (TMS99XX_MODEL >= TMS99105A_ID)
+#if 0	/* 990/12 opcodes */
 /*==========================================================================
    Additionnal instructions,                                   >0C00->0C0F
    Additionnal single-register instructions,                   >0C10->0C3F
  ---------------------------------------------------------------------------
 
@@ -2486,161 +3866,192 @@
     ---------------------------------
     |     o p c o d e               |
     |     o p c o d e       | reg # |
     ---------------------------------
 
-tms99xxx : TMB, TCMB, TSMB
-tms99110a : CRI, NEGR, CRE, CER
 ============================================================================*/
 static void h0c00(UINT16 opcode)
 {
 	if (opcode & 0x30)
 	{
-#if 0
 		switch ((opcode & 0x30) >> 4)
 		{
 		case 1:
 			/* INSF -- INSert Field */
+			break;
 		case 2:
 			/* XV ---- eXtract Value */
+			break;
 		case 3:
 			/* XF ---- eXtract Field */
-
 			break;
 		}
-#else
-		HANDLE_ILLEGAL;
-#endif
 	}
 	else
 	{
 		switch (opcode & 0x0F)
 		{
-#if (TMS99XX_MODEL == TMS99110A_ID)
 		/* floating point instructions */
 		case 0:
 			/* CRI --- Convert Real to Integer */
-
 			break;
 		case 2:
 			/* NEGR -- NEGate Real */
-
 			break;
 		case 4:
 			/* CRE --- Convert Real to Extended integer */
-
 			break;
 		case 6:
 			/* CER --- Convert Extended integer to Real */
+			break;
 
+		case 1:
+			/* CDI --- Convert Double precision real to Integer */
+			break;
+		case 3:
+			/* NEGD -- NEGate Double precision real */
+			break;
+		case 5:
+			/* CDE --- Convert Double precision real to Extended integer */
+			break;
+		case 7:
+			/* CED --- Convert Extended integer to Double precision real */
+			break;
+
+		case 8:
+			/* NRM --- NoRMalize */
 			break;
-#endif
 
-		/* The next three instructions allow to handle multiprocessor systems */
 		case 9:
 			/* TMB --- Test Memory Bit */
-
 			break;
 		case 10:
 			/* TCMB -- Test and Clear Memory Bit */
-
 			break;
 		case 11:
 			/* TSMB -- Test and Set Memory Bit */
-
 			break;
 
-#if 0
-		/* the four next instructions support BCD */
-		case 1:
-			/* CDI --- Convert Decimal to Integer */
-		case 3:
-			/* NEGD -- NEGate Decimal */
-		case 5:
-			/* CDE --- Convert Decimal to Extended integer */
-		case 7:
-			/* CED --- Convert Extended integer to Decimal */
-
-		case 8:
-			/* NRM --- NoRMalize */
-
-	case 12:
+		case 12:
 			/* SRJ --- Subtract from Register and Jump */
 		case 13:
 			/* ARJ --- Add to Register and Jump */
 
 		case 14:
 		case 15:
-			/* XIT --- eXIT from floating point interpreter (???) */
-			/* Completely alien to me.  Must have existed on weird TI990 variants. */
-
+			/* XIT --- eXIT from floating point interpreter */
+			/* Generated by some compilers, but equivalent to NOP on TI990/12.  May have been used
+			by some software floating-point emulators. */
 			break;
-#endif
+
 		default:
 			HANDLE_ILLEGAL;
 			break;
 		}
 	}
 }
 
 
 /*==========================================================================
-   Additionnal single-operand instructions,                    >0C40->0FFF
+   Additionnal single-operand instructions,                    >0C40->0DFF
+                                                               >0E40->0FFF
  ---------------------------------------------------------------------------
 
      0 1 2 3-4 5 6 7+8 9 A B-C D E F
     ---------------------------------
     |    o p c o d e    |TS |   S   |
     ---------------------------------
 
-tms99110a : AR, CIR, SR, MR, DR, LR, STR
 ============================================================================*/
 static void h0c40(UINT16 opcode)
 {
 	register UINT16 src;
 
+#if HAS_MAPPING
+	int src_map = (opcode & 0x0030) ? I.cur_src_map : I.cur_map;
+#endif
+
 	src = decipheraddr(opcode) & ~1;
 
 	switch ((opcode & 0x03C0) >> 6)
 	{
-#if (TMS99XX_MODEL == TMS99110A_ID)
 	case 1:
 		/* AR ---- Add Real */
+		break;
 	case 2:
 		/* CIR --- Convert Integer to Real */
+		break;
 	case 3:
 		/* SR ---- Subtract Real */
+		break;
 	case 4:
 		/* MR ---- Multiply Real */
+		break;
 	case 5:
 		/* DR ---- Divide Real */
+		break;
 	case 6:
 		/* LR ---- Load Real */
+		break;
 	case 7:
-		/* STR --- STore Real */
-#endif
-#if 0
+		/* STR --- STore Real */
+		break;
 	case 9:
-		/* AD ---- Add Decimal */
+		/* AD ---- Add Double */
+		break;
 	case 10:
-		/* CID --- Convert Integer to Decimal */
+		/* CID --- Convert Integer to Double */
+		break;
 	case 11:
-		/* SD ---- Subtract Decimal */
+		/* SD ---- Subtract Double */
+		break;
 	case 12:
-		/* MD ---- Multiply Decimal */
+		/* MD ---- Multiply Double */
+		break;
 	case 13:
-		/* DD ---- Divide Decimal  */
+		/* DD ---- Divide Double  */
+		break;
 	case 14:
-		/* LD ---- Load Decimal */
+		/* LD ---- Load Double */
+		break;
 	case 15:
-		/* SD ---- Store Decimal */
-#endif
+		/* SD ---- Store Double */
+		break;
 	default:
 		HANDLE_ILLEGAL;
 		break;
 	}
 }
+
+/*==========================================================================
+   Additionnal single-register instructions,                   >0E00->0E3F
+ ---------------------------------------------------------------------------
+
+     0 1 2 3-4 5 6 7+8 9 A B-C D E F
+    ---------------------------------
+    |     o p c o d e       | reg # |
+    ---------------------------------
+
+============================================================================*/
+static void h0e00(UINT16 opcode)
+{
+	switch ((opcode & 0x30) >> 4)
+	{
+	case 1:
+		/* IOF --- Invert Order of Field */
+		break;
+	case 1:
+		/* SNEB -- Search string for Not Equal Byte */
+		break;
+	case 2:
+		/* CRC --- Cyclic Redundancy Code calculation */
+		break;
+	case 3:
+		/* TS ---- Translate String */
+		break;
+	}
+}
 #endif
 
 
 /*==========================================================================
    Jump, CRU bit instructions,                                 >1000->1FFF
@@ -2664,132 +4075,132 @@
 	{
 	case 0:   /* JMP */
 		/* JMP --- unconditional JuMP */
 		/* PC += offset */
 		I.PC += (offset + offset);
-		CYCLES(10, 3);
+		CYCLES(3, 10, 3);
 		break;
 	case 1:   /* JLT */
 		/* JLT --- Jump if Less Than (arithmetic) */
 		/* if (A==0 && EQ==0), PC += offset */
 		if (! (I.STATUS & (ST_AGT | ST_EQ)))
 		{
 			I.PC += (offset + offset);
-			CYCLES(10, 3);
+			CYCLES(3, 10, 3);
 		}
 		else
-			CYCLES(8, 3);
+			CYCLES(2, 8, 3);
 		break;
 	case 2:   /* JLE */
 		/* JLE --- Jump if Lower or Equal (logical) */
 		/* if (L==0 || EQ==1), PC += offset */
 		if ((! (I.STATUS & ST_LGT)) || (I.STATUS & ST_EQ))
 		{
 			I.PC += (offset + offset);
-			CYCLES(10, 3);
+			CYCLES(3, 10, 3);
 		}
 		else
-			CYCLES(8, 3);
+			CYCLES(2, 8, 3);
 		break;
 	case 3:   /* JEQ */
 		/* JEQ --- Jump if EQual */
 		/* if (EQ==1), PC += offset */
 		if (I.STATUS & ST_EQ)
 		{
 			I.PC += (offset + offset);
-			CYCLES(10, 3);
+			CYCLES(3, 10, 3);
 		}
 		else
-			CYCLES(8, 3);
+			CYCLES(2, 8, 3);
 		break;
 	case 4:   /* JHE */
 		/* JHE --- Jump if Higher or Equal (logical) */
 		/* if (L==1 || EQ==1), PC += offset */
 		if (I.STATUS & (ST_LGT | ST_EQ))
 		{
 			I.PC += (offset + offset);
-			CYCLES(10, 3);
+			CYCLES(3, 10, 3);
 		}
 		else
-			CYCLES(8, 3);
+			CYCLES(2, 8, 3);
 		break;
 	case 5:   /* JGT */
 		/* JGT --- Jump if Greater Than (arithmetic) */
 		/* if (A==1), PC += offset */
 		if (I.STATUS & ST_AGT)
 		{
 			I.PC += (offset + offset);
-			CYCLES(10, 3);
+			CYCLES(3, 10, 3);
 		}
 		else
-			CYCLES(8, 3);
+			CYCLES(2, 8, 3);
 		break;
 	case 6:   /* JNE */
 		/* JNE --- Jump if Not Equal */
 		/* if (EQ==0), PC += offset */
 		if (! (I.STATUS & ST_EQ))
 		{
 			I.PC += (offset + offset);
-			CYCLES(10, 3);
+			CYCLES(3, 10, 3);
 		}
 		else
-			CYCLES(8, 3);
+			CYCLES(2, 8, 3);
 		break;
 	case 7:   /* JNC */
 		/* JNC --- Jump if No Carry */
 		/* if (C==0), PC += offset */
 		if (! (I.STATUS & ST_C))
 		{
 			I.PC += (offset + offset);
-			CYCLES(10, 3);
+			CYCLES(3, 10, 3);
 		}
 		else
-			CYCLES(8, 3);
+			CYCLES(2, 8, 3);
 		break;
 	case 8:   /* JOC */
 		/* JOC --- Jump On Carry */
 		/* if (C==1), PC += offset */
 		if (I.STATUS & ST_C)
 		{
 			I.PC += (offset + offset);
-			CYCLES(10, 3);
+			CYCLES(3, 10, 3);
 		}
 		else
-			CYCLES(8, 3);
+			CYCLES(2, 8, 3);
 		break;
 	case 9:   /* JNO */
 		/* JNO --- Jump if No Overflow */
 		/* if (OV==0), PC += offset */
 		if (! (I.STATUS & ST_OV))
 		{
 			I.PC += (offset + offset);
-			CYCLES(10, 3);
+			CYCLES(3, 10, 3);
 		}
 		else
-			CYCLES(8, 3);
+			CYCLES(2, 8, 3);
 		break;
 	case 10:  /* JL */
 		/* JL ---- Jump if Lower (logical) */
 		/* if (L==0 && EQ==0), PC += offset */
 		if (! (I.STATUS & (ST_LGT | ST_EQ)))
 		{
 			I.PC += (offset + offset);
-			CYCLES(10, 3);
+			CYCLES(3, 10, 3);
 		}
 		else
-			CYCLES(8, 3);
+			CYCLES(2, 8, 3);
 		break;
 	case 11:  /* JH */
 		/* JH ---- Jump if Higher (logical) */
 		/* if (L==1 && EQ==0), PC += offset */
 		if ((I.STATUS & ST_LGT) && ! (I.STATUS & ST_EQ))
 		{
 			I.PC += (offset + offset);
-			CYCLES(10, 3);
+			CYCLES(3, 10, 3);
 		}
 		else
-			CYCLES(8, 3);
+			CYCLES(2, 8, 3);
 		break;
 	case 12:  /* JOP */
 		/* JOP --- Jump On (odd) Parity */
 		/* if (P==1), PC += offset */
 		{
@@ -2814,34 +4225,60 @@
 
 			/* Jump accordingly. */
 			if (i & 1)  /*(I.STATUS & ST_OP)*/
 			{
 				I.PC += (offset + offset);
-				CYCLES(10, 3);
+				CYCLES(3, 10, 3);
 			}
 			else
-				CYCLES(8, 3);
+				CYCLES(2, 8, 3);
 		}
 
 		break;
 	case 13:  /* SBO */
 		/* SBO --- Set Bit to One */
 		/* CRU Bit = 1 */
-		writeCRU((READREG(R12) >> 1) + offset, 1, 1);
-		CYCLES(12, 8);
+		#if HAS_PRIVILEGE
+			if (writeCRU((READREG(R12) >> 1) + offset, 1, 1) == CRU_PRIVILEGE_VIOLATION)
+				HANDLE_PRIVILEGE_VIOLATION
+		#else
+			writeCRU((READREG(R12) >> 1) + offset, 1, 1);
+		#endif
+
+		CYCLES(4, 12, 8);
 		break;
+
 	case 14:  /* SBZ */
 		/* SBZ --- Set Bit to Zero */
 		/* CRU Bit = 0 */
-		writeCRU((READREG(R12) >> 1) + offset, 1, 0);
-		CYCLES(12, 8);
+		#if HAS_PRIVILEGE
+			if (writeCRU((READREG(R12) >> 1) + offset, 1, 0) == CRU_PRIVILEGE_VIOLATION)
+				HANDLE_PRIVILEGE_VIOLATION
+		#else
+			writeCRU((READREG(R12) >> 1) + offset, 1, 0);
+		#endif
+
+		CYCLES(4, 12, 8);
 		break;
+
 	case 15:  /* TB */
 		/* TB ---- Test Bit */
 		/* EQ = (CRU Bit == 1) */
-		setst_e(readCRU((READREG(R12)>> 1) + offset, 1) & 1, 1);
-		CYCLES(12, 8);
+		#if HAS_PRIVILEGE
+			{
+				int value;
+
+				value = readCRU((READREG(R12)>> 1) + offset, 1);
+				if (value == CRU_PRIVILEGE_VIOLATION)
+					HANDLE_PRIVILEGE_VIOLATION
+				else
+					setst_e(value & 1, 1);
+			}
+		#else
+			setst_e(readCRU((READREG(R12)>> 1) + offset, 1) & 1, 1);
+		#endif
+		CYCLES(5, 12, 8);
 		break;
 	}
 }
 
 
@@ -2863,81 +4300,80 @@
 {
 	register UINT16 dest = (opcode & 0x3C0) >> 6;
 	register UINT16 src;
 	register UINT16 value;
 
-	src = decipheraddr(opcode);
+#if HAS_MAPPING
+	int src_map = (opcode & 0x0030) ? I.cur_src_map : I.cur_map;
+#endif
+
+	src = decipheraddr(opcode) & ~1;
+	dest = ((dest+dest) + I.WP) & ~1;
 
 	switch ((opcode & 0x1C00) >> 10)
 	{
 	case 0:   /* COC */
 		/* COC --- Compare Ones Corresponding */
 		/* status E bit = (S&D == S) */
-		dest = ((dest+dest) + I.WP) & ~1;
-		src &= ~1;
-		value = readword(src);
+		value = readwordX(src, src_map);
 		setst_e(value & readword(dest), value);
-		CYCLES(14, 4);
+		CYCLES(5, 14, 4);
 		break;
 	case 1:   /* CZC */
 		/* CZC --- Compare Zeroes Corresponding */
 		/* status E bit = (S&~D == S) */
-		dest = ((dest+dest) + I.WP) & ~1;
-		src &= ~1;
-		value = readword(src);
+		value = readwordX(src, src_map);
 		setst_e(value & (~ readword(dest)), value);
-		CYCLES(14, 4);
+		CYCLES(5, 14, 4);
 		break;
 	case 2:   /* XOR */
 		/* XOR --- eXclusive OR */
 		/* D ^= S */
-		dest = ((dest+dest) + I.WP) & ~1;
-		src &= ~1;
-		value = readword(dest) ^ readword(src);
+		value = readwordX(src, src_map);
+		value ^= readword(dest);
 		setst_lae(value);
-		writeword(dest,value);
-		CYCLES(14, 4);
+		writeword(dest, value);
+		CYCLES(3, 14, 4);
 		break;
 	/*case 3:*/   /* XOP is implemented elsewhere */
 	/*case 4:*/   /* LDCR is implemented elsewhere */
 	/*case 5:*/   /* STCR is implemented elsewhere */
 	case 6:   /* MPY */
 		/* MPY --- MultiPlY  (unsigned) */
 		/* Results:  D:D+1 = D*S */
-		/* Note that early TMS9995 reportedly perform an extra dummy read in PC space */
-		dest = ((dest+dest) + I.WP) & ~1;
-		src &= ~1;
+		/* Note that early TMS9995 reportedly performs an extra dummy read in PC space */
 		{
-			unsigned long prod = ((unsigned long) readword(dest)) * ((unsigned long) readword(src));
+			unsigned long prod = ((unsigned long) readwordX(src, src_map));
+			prod = prod * ((unsigned long) readword(dest));
 			writeword(dest, prod >> 16);
-			writeword(dest+2, prod);
+			writeword((dest+2)&0xffff, prod);
 		}
-		CYCLES(52, 23);
+		/* ti990/10 : from 19 to 35, possibly 19 + (number of bits to 1 in one operand) */
+		CYCLES(35, 52, 23);
 		break;
 	case 7:   /* DIV */
 		/* DIV --- DIVide    (unsigned) */
 		/* D = D/S    D+1 = D%S */
-		dest = ((dest+dest) + I.WP) & ~1;
-		src &= ~1;
 		{
-			UINT16 d = readword(src);
+			UINT16 d = readwordX(src, src_map);
 			UINT16 hi = readword(dest);
-			unsigned long divq = (((unsigned long) hi) << 16) | readword(dest+2);
+			unsigned long divq = (((unsigned long) hi) << 16) | readword((dest+2)&0xffff);
 
 			if (d <= hi)
 			{
 				I.STATUS |= ST_OV;
-				CYCLES(16, 6);
+				CYCLES(4, 16, 6);
 			}
 			else
 			{
 				I.STATUS &= ~ST_OV;
 				writeword(dest, divq/d);
-				writeword(dest+2, divq%d);
+				writeword((dest+2)&0xffff, divq%d);
 				/* tms9900 : from 92 to 124, possibly 92 + 2*(number of bits to 1 (or 0?) in quotient) */
 				/* tms9995 : 28 is the worst case */
-				CYCLES(92, 28);
+				/* ti990/10 : from 41 to 58, possibly 41 + (number of bits to 1 (or 0?) in quotient) */
+				CYCLES(41, 92, 28);
 			}
 		}
 		break;
 	}
 }
@@ -2951,17 +4387,18 @@
 	/* Xop bit set */
 
 	register UINT16 immediate = (opcode & 0x3C0) >> 6;
 	register UINT16 operand;
 
-#if (TMS99XX_MODEL == TMS9940_ID)
-		switch (immediate)
+
+#if (TMS99XX_MODEL == TMS9940_ID) || (TMS99XX_MODEL == TMS9985_ID)
+	switch (immediate)
+	{
+	case 0: /* DCA */
+		/* DCA --- Decimal Correct Addition */
+		operand = decipheraddrbyte(opcode);
 		{
-		case 0: /* DCA */
-			/* DCA --- Decimal Correct Addition */
-			operand = decipheraddrbyte(opcode);
-			{
 			int value = readbyte(operand);
 			int X = (value >> 4) & 0xf;
 			int Y = value & 0xf;
 
 			if (Y >= 10)
@@ -2984,16 +4421,16 @@
 			{
 				X += 6;
 			}
 
 			writebyte(operand, (X << 4) | Y);
-			}
-			break;
-		case 1:	/* DCS */
-			/* DCS --- Decimal Correct Substraction */
-			operand = decipheraddrbyte(opcode);
-			{
+		}
+		break;
+	case 1:	/* DCS */
+		/* DCS --- Decimal Correct Substraction */
+		operand = decipheraddrbyte(opcode);
+		{
 			int value = readbyte(operand);
 
 			if (! (I.STATUS & ST_DC))
 			{
 				value += 10;
@@ -3005,51 +4442,58 @@
 			}
 
 			I.STATUS ^= ST_DC;
 
 			writebyte(operand, value);
-			}
-			break;
-		case 2: /* LIIM */
-		case 3: /* LIIM */
-			/* LIIM - Load Immediate Interrupt Mask */
-			/* Does the same job as LIMI, with a different opcode format. */
-			/* Note that, unlike TMS9900, the interrupt mask is only 2-bit long. */
-			operand = decipheraddr(opcode);	/* dummy decode (personnal guess) */
+		}
+		break;
+	case 2: /* LIIM */
+	case 3: /* LIIM */
+		/* LIIM - Load Immediate Interrupt Mask */
+		/* Does the same job as LIMI, with a different opcode format. */
+		/* Note that, unlike TMS9900, the interrupt mask is only 2-bit long. */
+		(void)decipheraddr(opcode);	/* dummy decode (personnal guess) */
 
-			I.STATUS = (I.STATUS & 0xFFFC) | (opcode & 0x0003);
-			break;
-		default:  /* normal XOP */
+		I.STATUS = (I.STATUS & ~ST_IM) | (opcode & ST_IM);
+		break;
+	default:  /* normal XOP */
 #endif
 
+	/* TODO : emulate 990/10 hardware XOP */
 	operand = decipheraddr(opcode);
 
-#if (TMS99XX_MODEL <= TMS9989_ID)
+	#if ((TMS99XX_MODEL <= TMS9989_ID) && (TMS99XX_MODEL != TI990_10_ID))
 		(void)readword(operand & ~1); /*dummy read (personnal guess)*/
-#endif
+	#endif
 
-		contextswitch(0x40 + (immediate << 2));
-#if (TMS99XX_MODEL != TMS9940_ID)
+	contextswitchX(0x40 + (immediate << 2));
+
+	#if ! ((TMS99XX_MODEL == TMS9940_ID) || (TMS99XX_MODEL == TMS9985_ID))
 		/* The bit is not set on tms9940 */
 		I.STATUS |= ST_X;
-#endif
-		WRITEREG(R11, operand);
-		CYCLES(36, 15);
-		disable_interrupt_recognition = 1;
+	#endif
 
-#if (TMS99XX_MODEL == TMS9940_ID)
-			break;
-		}
+	WRITEREG(R11, operand);
+	CYCLES(7, 36, 15);
+	I.disable_interrupt_recognition = 1;
+
+#if (TMS99XX_MODEL == TMS9940_ID) || (TMS99XX_MODEL == TMS9985_ID)
+		break;
+	}
 #endif
 }
 
 /* LDCR and STCR */
 static void ldcr_stcr(UINT16 opcode)
 {
 	register UINT16 cnt = (opcode & 0x3C0) >> 6;
 	register UINT16 addr;
-	register UINT16 value;
+	int value;
+
+#if HAS_MAPPING
+	int src_map = (opcode & 0x0030) ? I.cur_src_map : I.cur_map;
+#endif
 
 	if (cnt == 0)
 		cnt = 16;
 
 	if (cnt <= 8)
@@ -3061,72 +4505,109 @@
 	{	/* LDCR */
 		/* LDCR -- LoaD into CRu */
 		/* CRU R12--CRU R12+D-1 set to S */
 		if (cnt <= 8)
 		{
-#if (TMS99XX_MODEL != TMS9995_ID)
-			value = readbyte(addr);
-#else
-			/* just for once, tms9995 behaves like earlier 8-bit tms99xx chips */
-			/* this must be because instruction decoding is too complex */
-			value = readword(addr);
-			if (addr & 1)
-				value &= 0xFF;
-			else
-				value = (value >> 8) & 0xFF;
-#endif
-			(void)READREG(cnt+cnt); /*dummy read (reasonnable guess, cf TMS9995)*/
+			#if (TMS99XX_MODEL != TMS9995_ID)
+				value = readbyteX(addr, src_map);
+			#else
+				/* just for once, tms9995 behaves like earlier 8-bit tms99xx chips */
+				/* this must be because instruction decoding is too complex */
+				value = readwordX(addr & ~1, src_map);
+				if (addr & 1)
+					value &= 0xFF;
+				else
+					value = (value >> 8) & 0xFF;
+			#endif
+
+			(void)READREG(cnt+cnt); /*dummy read (reasonnable guess for TMS9995 & TMS9900, ti990/10)*/
+
 			setst_byte_laep(value);
-			writeCRU((READREG(R12) >> 1), cnt, value);
 		}
 		else
 		{
-			value = readword(addr);
-			(void)READREG(cnt+cnt); /*dummy read (reasonnable guess, cf TMS9995)*/
+			value = readwordX(addr, src_map);
+
+			(void)READREG(cnt+cnt); /*dummy read (reasonnable guess for TMS9995 & TMS9900, ti990/10)*/
+
 			setst_lae(value);
-			writeCRU((READREG(R12) >> 1), cnt, value);
 		}
-		CYCLES(20 + cnt+cnt, 9 + cnt+cnt);
+
+		#if HAS_PRIVILEGE
+			if (writeCRU((READREG(R12) >> 1), cnt, value) == CRU_PRIVILEGE_VIOLATION)
+				HANDLE_PRIVILEGE_VIOLATION
+		#else
+			writeCRU((READREG(R12) >> 1), cnt, value);
+		#endif
+
+		CYCLES(4+cnt, 20 + cnt+cnt, 9 + cnt+cnt);
 	}
 	else
 	{	/* STCR */
 		/* STCR -- STore from CRu */
 		/* S = CRU R12--CRU R12+D-1 */
 		if (cnt <= 8)
 		{
-#if (TMS99XX_MODEL != TMS9995_ID)
-			(void)readbyte(addr); /*dummy read*/
-			(void)READREG(cnt+cnt); /*dummy read (reasonnable guess, cf TMS9995)*/
-			value = readCRU((READREG(R12) >> 1), cnt);
-			setst_byte_laep(value);
-			writebyte(addr, value);
-			CYCLES((cnt != 8) ? 42 : 44, 19 + cnt);
-#else
-			/* just for once, tms9995 behaves like earlier 8-bit tms99xx chips */
-			/* this must be because instruction decoding is too complex */
-			int value2 = readword(addr);
+			#if (TMS99XX_MODEL != TMS9995_ID)
+				(void)readbyteX(addr, src_map);	/*dummy read*/
 
-			READREG(cnt+cnt); /*dummy read (guessed from timing table)*/
-			value = readCRU((READREG(R12) >> 1), cnt);
-			setst_byte_laep(value);
+				(void)READREG(cnt+cnt); /*dummy read (reasonnable guess for TMS9995 & TMS9900, ti990/10)*/
 
-			if (addr & 1)
-				writeword(addr, (value & 0x00FF) | (value2 & 0xFF00));
-			else
-				writeword(addr, (value2 & 0x00FF) | ((value << 8) & 0xFF00));
+				#if HAS_PRIVILEGE
+					value = readCRU((READREG(R12) >> 1), cnt);
+					if (value == CRU_PRIVILEGE_VIOLATION)
+						HANDLE_PRIVILEGE_VIOLATION
+					else
+					{
+						setst_byte_laep(value);
+						writebyteX(addr, value, src_map);
+					}
+				#else
+					value = readCRU((READREG(R12) >> 1), cnt);
+					setst_byte_laep(value);
+					writebyteX(addr, value, src_map);
+				#endif
+				CYCLES(18+cnt, (cnt != 8) ? 42 : 44, 19 + cnt);
+			#else
+				/* just for once, tms9995 behaves like earlier 8-bit tms99xx chips */
+				/* this must be because instruction decoding is too complex */
+				int value2 = readwordX(addr & ~1, src_map);
 
-			CYCLES(Mooof!, 19 + cnt);
-#endif
+				(void)READREG(cnt+cnt); /*dummy read (reasonnable guess for TMS9995 & TMS9900, ti990/10)*/
+
+				value = readCRU((READREG(R12) >> 1), cnt);
+				setst_byte_laep(value);
+
+				if (addr & 1)
+					writewordX(addr & ~1, (value & 0x00FF) | (value2 & 0xFF00), src_map);
+				else
+					writewordX(addr & ~1, (value2 & 0x00FF) | ((value << 8) & 0xFF00), src_map);
+
+				CYCLES(Mooof!, Mooof!, 19 + cnt);
+			#endif
 		}
 		else
 		{
-			(void)readword(addr); /*dummy read*/
-			(void)READREG(cnt+cnt); /*dummy read (reasonnable guess, cf TMS9995)*/
-			value = readCRU((READREG(R12) >> 1), cnt);
-			setst_lae(value);
-			writeword(addr, value);
-			CYCLES((cnt != 16) ? 58 : 60, 27 + cnt);
+			(void)readwordX(addr, src_map);	/*dummy read*/
+
+			(void)READREG(cnt+cnt); /*dummy read (reasonnable guess for TMS9995 & TMS9900, ti990/10)*/
+
+			#if HAS_PRIVILEGE
+				value = readCRU((READREG(R12) >> 1), cnt);
+				if (value == CRU_PRIVILEGE_VIOLATION)
+					HANDLE_PRIVILEGE_VIOLATION
+				else
+				{
+					setst_lae(value);
+					writewordX(addr, value, src_map);
+				}
+			#else
+				value = readCRU((READREG(R12) >> 1), cnt);
+				setst_lae(value);
+				writewordX(addr, value, src_map);
+			#endif
+			CYCLES(24+cnt, (cnt != 16) ? 58 : 60, 27 + cnt);
 		}
 	}
 }
 
 
@@ -3146,70 +4627,69 @@
 static void h4000w(UINT16 opcode)
 {
 	register UINT16 src;
 	register UINT16 dest;
 	register UINT16 value;
-	int a,b;
+
+#if HAS_MAPPING
+	int src_map = (opcode & 0x0030) ? I.cur_src_map : I.cur_map;
+	int dst_map = (opcode & 0x0c00) ? I.cur_dst_map : I.cur_map;
+#endif
 
 	src = decipheraddr(opcode) & ~1;
 	dest = decipheraddr(opcode >> 6) & ~1;
 
+	value = readwordX(src, src_map);
+
 	switch ((opcode >> 13) & 0x0007)    /* ((opcode & 0xE000) >> 13) */
 	{
 	case 2:   /* SZC */
 		/* SZC --- Set Zeros Corresponding */
 		/* D &= ~S */
-		value = readword(dest) & (~ readword(src));
+		value = readwordX(dest, dst_map) & (~ value);
 		setst_lae(value);
-		writeword(dest, value);
-		CYCLES(14, 4);
+		writewordX(dest, value, dst_map);
+		CYCLES(2, 14, 4);
 		break;
 	case 3:   /* S */
 		/* S ----- Subtract */
 		/* D -= S */
-		a = readword(dest);
-		b = readword(src);
-		value = setst_sub_laeco(a, b);
-		writeword(dest, value);
-		CYCLES(14, 4);
+		value = setst_sub_laeco(readwordX(dest, dst_map), value);
+		writewordX(dest, value, dst_map);
+		CYCLES(2, 14, 4);
 		break;
 	case 4:   /* C */
 		/* C ----- Compare */
 		/* ST = (D - S) */
-		a = readword(dest);
-		b = readword(src);
-		setst_c_lae(a, b);
-		CYCLES(14, 4);
+		setst_c_lae(readwordX(dest, dst_map), value);
+		CYCLES(5, 14, 4);
 		break;
 	case 5:   /* A */
 		/* A ----- Add */
 		/* D += S */
-		a = readword(dest);
-		b = readword(src);
-		value = setst_add_laeco(a, b);
-		writeword(dest, value);
-		CYCLES(14, 4);
+		value = setst_add_laeco(readwordX(dest, dst_map), value);
+		writewordX(dest, value, dst_map);
+		CYCLES(2, 14, 4);
 		break;
 	case 6:   /* MOV */
 		/* MOV --- MOVe */
 		/* D = S */
-		value = readword(src);
 		setst_lae(value);
-#if (TMS99XX_MODEL <= TMS9989_ID)
-		/* MOV performs a dummy read... */
-		(void)readword(dest);
-#endif
-		writeword(dest, value);
-		CYCLES(14, 3);
+		#if ((TMS99XX_MODEL >= TMS9900_ID) && (TMS99XX_MODEL <= TMS9985_ID))
+			/* MOV performs a dummy read with tms9900/9980 (but neither ti990/10 nor tms9995) */
+			(void)readwordX(dest, dst_map);
+		#endif
+		writewordX(dest, value, dst_map);
+		CYCLES(1, 14, 3);
 		break;
 	case 7:   /* SOC */
 		/* SOC --- Set Ones Corresponding */
 		/* D |= S */
-		value = readword(dest) | readword(src);
+		value = value | readwordX(dest, dst_map);
 		setst_lae(value);
-		writeword(dest, value);
-		CYCLES(14, 4);
+		writewordX(dest, value, dst_map);
+		CYCLES(2, 14, 4);
 		break;
 	}
 }
 
 /* byte instruction */
@@ -3217,73 +4697,80 @@
 {
 	register UINT16 src;
 	register UINT16 dest;
 	register UINT16 value;
 
+#if HAS_MAPPING
+	int src_map = (opcode & 0x0030) ? I.cur_src_map : I.cur_map;
+	int dst_map = (opcode & 0x0c00) ? I.cur_dst_map : I.cur_map;
+#endif
+
 	src = decipheraddrbyte(opcode);
 	dest = decipheraddrbyte(opcode >> 6);
 
+	value = readbyteX(src, src_map);
+
 	switch ((opcode >> 13) & 0x0007)    /* ((opcode & 0xE000) >> 13) */
 	{
 	case 2:   /* SZCB */
 		/* SZCB -- Set Zeros Corresponding, Byte */
 		/* D &= ~S */
-		value = readbyte(dest) & (~ readbyte(src));
+		value = readbyteX(dest, dst_map) & (~ value);
 		setst_byte_laep(value);
-		writebyte(dest, value);
-		CYCLES(14, 4);
+		writebyteX(dest, value, dst_map);
+		CYCLES(3, 14, 4);
 		break;
 	case 3:   /* SB */
 		/* SB ---- Subtract, Byte */
 		/* D -= S */
-		value = setst_subbyte_laecop(readbyte(dest), readbyte(src));
-		writebyte(dest, value);
-		CYCLES(14, 4);
+		value = setst_subbyte_laecop(readbyteX(dest, dst_map), value);
+		writebyteX(dest, value, dst_map);
+		CYCLES(3, 14, 4);
 		break;
 	case 4:   /* CB */
 		/* CB ---- Compare Bytes */
 		/* ST = (D - S) */
-		value = readbyte(src);
-		setst_c_lae(readbyte(dest)<<8, value<<8);
+		setst_c_lae(readbyteX(dest, dst_map)<<8, value<<8);
 		lastparity = value;
-		CYCLES(14, 4);
+		CYCLES(5, 14, 4);
 		break;
 	case 5:   /* AB */
 		/* AB ---- Add, Byte */
 		/* D += S */
-		value = setst_addbyte_laecop(readbyte(dest), readbyte(src));
-		writebyte(dest, value);
+		value = setst_addbyte_laecop(readbyteX(dest, dst_map), value);
+		writebyteX(dest, value, dst_map);
+		CYCLES(3, 14, 4);
 		break;
 	case 6:   /* MOVB */
 		/* MOVB -- MOVe Bytes */
 		/* D = S */
-		value = readbyte(src);
 		setst_byte_laep(value);
-#if (TMS99XX_MODEL <= TMS9989_ID)
-		/* on tms9900, MOVB needs to read destination, because it cannot actually read one single byte.
-		  It reads a word, replaces the revelant byte, then write the result */
-		/* A tms9980 theorically does not need to do so, but still does... */
-		readbyte(dest);
-#endif
-		writebyte(dest, value);
-		CYCLES(14, 3);
+		#if (TMS99XX_MODEL <= TMS9985_ID)
+			/* On ti990/10 and tms9900, MOVB needs to read destination, because it cannot actually
+			  read one single byte.  It reads a word, replaces the revelant byte, then write
+			  the result.  A tms9980 should not need to do so, but still does, because it is just
+			  a tms9900 with a 16 to 8 bit multiplexer (instead of a new chip design, like tms9995). */
+			(void)readbyteX(dest, dst_map);
+		#endif
+		writebyteX(dest, value, dst_map);
+		CYCLES(3, 14, 3);
 		break;
 	case 7:   /* SOCB */
 		/* SOCB -- Set Ones Corresponding, Byte */
 		/* D |= S */
-		value = readbyte(dest) | readbyte(src);
+		value = value | readbyteX(dest, dst_map);
 		setst_byte_laep(value);
-		writebyte(dest, value);
-		CYCLES(14, 4);
+		writebyteX(dest, value, dst_map);
+		CYCLES(3, 14, 4);
 		break;
 	}
 }
 
 
 INLINE void execute(UINT16 opcode)
 {
-#if (TMS99XX_MODEL <= TMS9985_ID)
+#if (! HAS_9995_OPCODES)
 
 	/* tms9900-like instruction set*/
 
 	static void (* jumptable[128])(UINT16) =
 	{
@@ -3305,13 +4792,14 @@
 		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b
 	};
 
 	(* jumptable[opcode >> 9])(opcode);
 
-#elif (TMS99XX_MODEL <= TMS9995_ID)
+#else
 
 	/* tms9989 and tms9995 include 4 extra instructions, and one additionnal instruction type */
+	/* tms99000 includes yet another additional instruction */
 
 	static void (* jumptable[256])(UINT16) =
 	{
 		&h0040,&h0100,&h0200,&h0200,&h0400,&h0400,&h0400,&h0400,
 		&h0800,&h0800,&h0800,&h0800,&illegal,&illegal,&illegal,&illegal,
@@ -3347,149 +4835,7 @@
 		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b
 	};
 
 	(* jumptable[opcode >> 8])(opcode);
 
-#elif (TMS99XX_MODEL >= TMS99105A_ID)
-
-	/* tms99xxx include even more instruction types */
-
-	static void (* jumptable[1024])(UINT16) =
-	{
-		&h0000,&h0040,&h0040,&illegal,&h0100,&h0100,&h0100,&h0100,
-		&h0200,&h0200,&h0200,&h0200,&h0200,&h0200,&h0200,&h0200,
-		&h0400,&h0400,&h0400,&h0400,&h0400,&h0400,&h0400,&h0400,
-		&h0400,&h0400,&h0400,&h0400,&h0400,&h0400,&h0400,&h0400,
-		&h0800,&h0800,&h0800,&h0800,&h0800,&h0800,&h0800,&h0800,
-		&h0800,&h0800,&h0800,&h0800,&h0800,&h0800,&h0800,&h0800,
-#if (TMS99XX_MODEL == TMS99110A_ID)
-		&h0c00,&h0c40,&h0c40,&h0c40,&h0c40,&h0c40,&h0c40,&h0c40,
-#else
-		&h0c00,&illegal,&illegal,&illegal,&illegal,&illegal,&illegal,&illegal,
-#endif
-		&illegal,&illegal,&illegal,&illegal,&illegal,&illegal,&illegal,&illegal,
-		&h1000,&h1000,&h1000,&h1000,&h1000,&h1000,&h1000,&h1000,
-		&h1000,&h1000,&h1000,&h1000,&h1000,&h1000,&h1000,&h1000,
-		&h1000,&h1000,&h1000,&h1000,&h1000,&h1000,&h1000,&h1000,
-		&h1000,&h1000,&h1000,&h1000,&h1000,&h1000,&h1000,&h1000,
-		&h1000,&h1000,&h1000,&h1000,&h1000,&h1000,&h1000,&h1000,
-		&h1000,&h1000,&h1000,&h1000,&h1000,&h1000,&h1000,&h1000,
-		&h1000,&h1000,&h1000,&h1000,&h1000,&h1000,&h1000,&h1000,
-		&h1000,&h1000,&h1000,&h1000,&h1000,&h1000,&h1000,&h1000,
-		&h2000,&h2000,&h2000,&h2000,&h2000,&h2000,&h2000,&h2000,
-		&h2000,&h2000,&h2000,&h2000,&h2000,&h2000,&h2000,&h2000,
-		&h2000,&h2000,&h2000,&h2000,&h2000,&h2000,&h2000,&h2000,
-		&h2000,&h2000,&h2000,&h2000,&h2000,&h2000,&h2000,&h2000,
-		&h2000,&h2000,&h2000,&h2000,&h2000,&h2000,&h2000,&h2000,
-		&h2000,&h2000,&h2000,&h2000,&h2000,&h2000,&h2000,&h2000,
-		&xop,&xop,&xop,&xop,&xop,&xop,&xop,&xop,
-		&xop,&xop,&xop,&xop,&xop,&xop,&xop,&xop,
-		&ldcr_stcr,&ldcr_stcr,&ldcr_stcr,&ldcr_stcr,&ldcr_stcr,&ldcr_stcr,&ldcr_stcr,&ldcr_stcr,
-		&ldcr_stcr,&ldcr_stcr,&ldcr_stcr,&ldcr_stcr,&ldcr_stcr,&ldcr_stcr,&ldcr_stcr,&ldcr_stcr,
-		&ldcr_stcr,&ldcr_stcr,&ldcr_stcr,&ldcr_stcr,&ldcr_stcr,&ldcr_stcr,&ldcr_stcr,&ldcr_stcr,
-		&ldcr_stcr,&ldcr_stcr,&ldcr_stcr,&ldcr_stcr,&ldcr_stcr,&ldcr_stcr,&ldcr_stcr,&ldcr_stcr,
-		&h2000,&h2000,&h2000,&h2000,&h2000,&h2000,&h2000,&h2000,
-		&h2000,&h2000,&h2000,&h2000,&h2000,&h2000,&h2000,&h2000,
-		&h2000,&h2000,&h2000,&h2000,&h2000,&h2000,&h2000,&h2000,
-		&h2000,&h2000,&h2000,&h2000,&h2000,&h2000,&h2000,&h2000,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,&h4000w,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,
-		&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b,&h4000b
-	};
-
-	(* jumptable[opcode >> 6])(opcode);
-
 #endif
 }
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/cpu/tms9900/99xxstat.h srcmess/cpu/tms9900/99xxstat.h
--- srcmess.ori/cpu/tms9900/99xxstat.h	1999-12-30 14:57:16.000000000 +0100
+++ srcmess/cpu/tms9900/99xxstat.h	2003-01-20 11:27:34.000000000 +0100
@@ -38,18 +38,22 @@
 	It must be called on interrupt return, or when, for some reason,
 	the emulated program sets the STATUS register directly.
 */
 static void getstat(void)
 {
-#if TMS99XX_MODEL <= TMS9985_ID
+#if (USE_ST_MASK)
 	I.STATUS &= ST_MASK;  /* unused bits are forced to 0 */
 #endif
 
 	if (I.STATUS & ST_OP)
 		lastparity = 1;
 	else
 		lastparity = 0;
+
+#if HAS_MAPPING
+	I.cur_map = (I.STATUS & ST_MF) ? 1 : 0;
+#endif
 }
 
 /*
 	A few words about the following functions.
 
@@ -187,25 +191,22 @@
 		if ( ((UINT16) val) > ((UINT16) to) )
 		I.STATUS |= ST_LGT;
 	}
 }
 
-#define wadd(addr,expr) { int lval = setst_add_laeco(readword(addr), (expr)); writeword((addr),lval); }
-#define wsub(addr,expr) { int lval = setst_sub_laeco(readword(addr), (expr)); writeword((addr),lval); }
-
-#ifdef __POWERPC__
+#if defined(__POWERPC__) && defined(__MWERKS__)
 
 // setst_add_32_laeco :
 // - computes a+b
 // - sets L, A, E, Carry and Overflow in st
 //
 // a -> r3, b -> r4, st -> r5
 // preserve r6-r12
 
 static INT32 asm setst_add_32_laeco(register INT32 a, register INT32 b, register INT16 st)
 {
-#if (TMS99XX_MODEL == TMS9940_ID)
+#if (TMS99XX_MODEL == TMS9940_ID) || (TMS99XX_MODEL == TMS9985_ID)
   mr r6,a           // save operand
 #endif
   addco. r3, b, a   // add, set CR0, and set CA and OV
   clrlwi st, st, 21 // clear L, A, E, C, O flags (-> keep bits 21-31)
   mcrxr cr1         // move XER (-> CA and CO bits) to CR1
@@ -221,11 +222,11 @@
 
 positive_result:
   ori st, st, ST_LGT | ST_AGT   // if result > 0, set ST_LGT and ST_AGT
 
 next:
-#if (TMS99XX_MODEL == TMS9940_ID)
+#if (TMS99XX_MODEL == TMS9940_ID) || (TMS99XX_MODEL == TMS9985_ID)
   andi. st, st, (~ ST_DC) & 0xFFFF
 
   or r7,r6,b
   and r6,r6,b
   andc r7,r7,r3
@@ -251,11 +252,11 @@
 // a -> r3, b -> r4, st -> r5
 // preserve r6-r12
 
 static INT32 asm setst_sub_32_laeco(register INT32 a, register INT32 b, register INT16 st)
 {
-#if (TMS99XX_MODEL == TMS9940_ID)
+#if (TMS99XX_MODEL == TMS9940_ID) || (TMS99XX_MODEL == TMS9985_ID)
   mr r6,a           // save operand
 #endif
   subco. r3, a, b   // sub, set CR0, and set CA and OV
   clrlwi st, st, 21 // clear L, A, E, C, O flags (-> keep bits 21-31)
   mcrxr cr1         // move XER (-> CA and CO bits) to CR1
@@ -271,11 +272,11 @@
 
 positive_result:
   ori st, st, ST_LGT | ST_AGT   // if result > 0, set ST_LGT and ST_AGT
 
 next:
-#if (TMS99XX_MODEL == TMS9940_ID)
+#if (TMS99XX_MODEL == TMS9940_ID) || (TMS99XX_MODEL == TMS9985_ID)
   andi. st, st, (~ ST_DC) & 0xFFFF
 
   orc r7,r6,b
   andc r6,r6,b
   andc r7,r7,r3
@@ -404,11 +405,11 @@
 		I.STATUS |= ST_C;
 
 	if ((res ^ b) & (res ^ a) & 0x8000)
 		I.STATUS |= ST_OV;
 
-#if (TMS99XX_MODEL == TMS9940_ID)
+#if (TMS99XX_MODEL == TMS9940_ID) || (TMS99XX_MODEL == TMS9985_ID)
 	if (((a & b) | ((a | b) & ~ res)) & 0x0800)
 		I.STATUS |= ST_DC;
 #endif
 
 	res2 = (INT16) res;
@@ -440,11 +441,11 @@
 		I.STATUS |= ST_C;
 
 	if ((a ^ b) & (a ^ res) & 0x8000)
 		I.STATUS |= ST_OV;
 
-#if (TMS99XX_MODEL == TMS9940_ID)
+#if (TMS99XX_MODEL == TMS9940_ID) || (TMS99XX_MODEL == TMS9985_ID)
 	if (((a & ~ b) | ((a | ~ b) & ~ res)) & 0x0800)
 		I.STATUS |= ST_DC;
 #endif
 
 	res2 = (INT16) res;
@@ -476,11 +477,11 @@
 		I.STATUS |= ST_C;
 
 	if ((res ^ b) & (res ^ a) & 0x80)
 		I.STATUS |= ST_OV;
 
-#if (TMS99XX_MODEL == TMS9940_ID)
+#if (TMS99XX_MODEL == TMS9940_ID) || (TMS99XX_MODEL == TMS9985_ID)
 	if (((a & b) | ((a | b) & ~ res)) & 0x08)
 		I.STATUS |= ST_DC;
 #endif
 
 	res2 = (INT8) res;
@@ -514,11 +515,11 @@
 		I.STATUS |= ST_C;
 
 	if ((a ^ b) & (a ^ res) & 0x80)
 		I.STATUS |= ST_OV;
 
-#if (TMS99XX_MODEL == TMS9940_ID)
+#if (TMS99XX_MODEL == TMS9940_ID) || (TMS99XX_MODEL == TMS9985_ID)
 	if (((a & ~ b) | ((a | ~ b) & ~ res)) & 0x08)
 		I.STATUS |= ST_DC;
 #endif
 
 	res2 = (INT8) res;
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/cpu/tms9900/ti990_10.c srcmess/cpu/tms9900/ti990_10.c
--- srcmess.ori/cpu/tms9900/ti990_10.c	1970-01-01 01:00:00.000000000 +0100
+++ srcmess/cpu/tms9900/ti990_10.c	2002-02-25 18:57:41.000000000 +0100
@@ -0,0 +1,9 @@
+/*
+	Generate the tms9900 emulator
+*/
+
+#include "tms9900.h"
+
+#define TMS99XX_MODEL TI990_10_ID
+
+#include "99xxcore.h"
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/cpu/tms9900/tms9900.h srcmess/cpu/tms9900/tms9900.h
--- srcmess.ori/cpu/tms9900/tms9900.h	2001-08-28 23:45:40.000000000 +0200
+++ srcmess/cpu/tms9900/tms9900.h	2003-01-20 11:28:46.000000000 +0100
@@ -9,21 +9,32 @@
 
 #include <stdio.h>
 #include "driver.h"
 #include "osd_cpu.h"
 
-#define TMS9900_ID      0 /* original processor, 1976 (huh... it had some multi-chip ancestors, */
-                          /* the 9x0 series)*/
-#define TMS9940_ID      1 /* embedded version, 1979 */
-#define TMS9980_ID      2 /* 8-bit variant of tms9900.  Two distinct chips actually : tms9980a, */
+/*#define TI990_9_ID	0*//* early implementation, used in a few real-world applications, 1974 */
+                          /* ("ti990/9" is likely to be a nickname) */
+#define TI990_10_ID		1 /* original multi-chip implementation for minicomputer systems, 1975 */
+/*#define TI990_12_ID		2*//* multi-chip implementation, faster than 990/10. huge instruction set */
+                          /* (144 instructions, with up to 16 additional custom instructions simulteanously) */
+                          /* 1979 (or before) */
+#define TMS9900_ID      3 /* mono-chip implementation, 1976 */
+#define TMS9940_ID      4 /* microcontroller with 2kb ROM, 128b RAM, decrementer, CRU bus, 1979 */
+#define TMS9980_ID      5 /* 8-bit variant of tms9900.  Two distinct chips actually : tms9980a, */
                           /* and tms9981 with an extra clock and simplified power supply */
-#define TMS9985_ID      3 /* 9980 with on-chip 16-bit RAM and decrementer, c. 1978 (never released) */
-#define TMS9989_ID      4 /* improved 9980, used in bombs, missiles, and other *nice* hardware */
-#define TMS9995_ID      5 /* tms9985-like, with many improvements */
-#define TMS99105A_ID    6 /* late variant, widely improved, 1981 */
-#define TMS99110A_ID    7 /* same as above, with floating point support, c. 1981 */
-
+#define TMS9985_ID      6 /* 9940 with 8kb ROM, 256b RAM, and a 8-bit external bus, c. 1978 (never released) */
+#define TMS9989_ID      7 /* improved 9980, used in bombs, missiles, and other *nice* hardware */
+/*#define SBP68689_ID     8*//* improved 9989, built as an ASIC as 9989 was running scarce */
+#define TMS9995_ID      9 /* tms9985-like, with many improvements (but no ROM) */
+#define TMS99000_ID     10/* improved mono-chip implementation, meant to replace 990/10, 1981 */
+                          /* This chip is available in several variants (tms99105, tms99110...), */
+                          /* which are similar but emulate additional instructions thanks */
+                          /* to the so-called macrostore feature. */
+
+/* NPW 25-May-2002 - Added these to get it to compile under windows */
+#define TI9940_ID		11
+#define TI9985_ID		12
 
 
 enum {
 	TMS9900_PC=1, TMS9900_WP, TMS9900_STATUS, TMS9900_IR
 #ifdef MAME_DEBUG
@@ -33,10 +44,52 @@
 	TMS9900_R8, TMS9900_R9, TMS9900_R10, TMS9900_R11,
 	TMS9900_R12, TMS9900_R13, TMS9900_R14, TMS9900_R15
 #endif
 };
 
+#if (HAS_TI990_10)
+
+extern	int ti990_10_ICount;
+
+extern void ti990_10_init(void);
+extern void ti990_10_reset(void *param);
+extern int ti990_10_execute(int cycles);
+extern void ti990_10_exit(void);
+extern unsigned ti990_10_get_context(void *dst);
+extern void ti990_10_set_context(void *src);
+extern unsigned ti990_10_get_reg(int regnum);
+extern void ti990_10_set_reg(int regnum, unsigned val);
+extern void ti990_10_set_irq_line(int irqline, int state);
+extern void ti990_10_set_irq_callback(int (*callback)(int irqline));
+extern const char *ti990_10_info(void *context, int regnum);
+extern unsigned ti990_10_dasm(char *buffer, unsigned pc);
+
+/*
+	structure with the parameters ti990_10_reset wants.
+*/
+typedef struct ti990_10reset_param
+{
+	void (*idle_callback)(int state);
+	void (*rset_callback)(void);
+	void (*lrex_callback)(void);
+	void (*ckon_ckof_callback)(int state);
+
+	void (*error_interrupt_callback)(int state);
+} ti990_10reset_param;
+
+/* accessor for the internal ROM */
+extern READ16_HANDLER(ti990_10_internal_r);
+
+/* CRU accessor for the mapper registers (R12 base 0x1fa0) */
+extern READ16_HANDLER(ti990_10_mapper_cru_r);
+extern WRITE16_HANDLER(ti990_10_mapper_cru_w);
+/* CRU accessor for the error interrupt register (R12 base 0x1fc0) */
+extern READ16_HANDLER(ti990_10_eir_cru_r);
+extern WRITE16_HANDLER(ti990_10_eir_cru_w);
+
+#endif
+
 #if (HAS_TMS9900)
 
 extern	int tms9900_ICount;
 
 extern void tms9900_init(void);
@@ -50,10 +103,18 @@
 extern void tms9900_set_irq_line(int irqline, int state);
 extern void tms9900_set_irq_callback(int (*callback)(int irqline));
 extern const char *tms9900_info(void *context, int regnum);
 extern unsigned tms9900_dasm(char *buffer, unsigned pc);
 
+/*
+	structure with optional parameters for tms9900_reset.
+*/
+typedef struct tms9900reset_param
+{
+	void (*idle_callback)(int state);
+} tms9900reset_param;
+
 #endif
 
 #if (HAS_TMS9940)
 
 extern	int tms9940_ICount;
@@ -155,52 +216,40 @@
 	/* auto_wait_state : a non-zero value makes tms9995 generate a wait state automatically on each
 	   memory access */
 	int auto_wait_state;
 } tms9995reset_param;
 
-#endif
-
-#if (HAS_TMS99105A)
-
-extern	int tms99105a_ICount;
-
-extern void tms99105a_init(void);
-extern void tms99105a_reset(void *param);
-extern int tms99105a_execute(int cycles);
-extern void tms99105a_exit(void);
-extern unsigned tms99105a_get_context(void *dst);
-extern void tms99105a_set_context(void *src);
-extern unsigned tms99105a_get_reg(int regnum);
-extern void tms99105a_set_reg(int regnum, unsigned val);
-extern void tms99105a_set_irq_line(int irqline, int state);
-extern void tms99105a_set_irq_callback(int (*callback)(int irqline));
-extern const char *tms99105a_info(void *context, int regnum);
-extern unsigned tms99105a_dasm(char *buffer, unsigned pc);
+/* accessor for the first 252 bytes of internal RAM */
+extern READ_HANDLER(tms9995_internal1_r);
+extern WRITE_HANDLER(tms9995_internal1_w);
+/* accessors for the last 4 bytes of internal RAM */
+extern READ_HANDLER(tms9995_internal2_r);
+extern WRITE_HANDLER(tms9995_internal2_w);
 
 #endif
+/*
+#if (HAS_TMS99000)
 
-#if (HAS_TMS99110A)
-
-extern	int tms99110A_ICount;
-
-extern void tms99110a_init(void);
-extern void tms99110a_reset(void *param);
-extern int tms99110a_execute(int cycles);
-extern void tms99110a_exit(void);
-extern unsigned tms99110a_get_context(void *dst);
-extern void tms99110a_set_context(void *src);
-extern unsigned tms99110a_get_reg(int regnum);
-extern void tms99110a_set_reg(int regnum, unsigned val);
-extern void tms99110a_set_irq_line(int irqline, int state);
-extern void tms99110a_set_irq_callback(int (*callback)(int irqline));
-extern const char *tms99110a_info(void *context, int regnum);
-extern unsigned tms99110a_dasm(char *buffer, unsigned pc);
+extern	int tms99000_ICount;
 
-#endif
+extern void tms99000_init(void);
+extern void tms99000_reset(void *param);
+extern int tms99000_execute(int cycles);
+extern void tms99000_exit(void);
+extern unsigned tms99000_get_context(void *dst);
+extern void tms99000_set_context(void *src);
+extern unsigned tms99000_get_reg(int regnum);
+extern void tms99000_set_reg(int regnum, unsigned val);
+extern void tms99000_set_irq_line(int irqline, int state);
+extern void tms99000_set_irq_callback(int (*callback)(int irqline));
+extern const char *tms99000_info(void *context, int regnum);
+extern unsigned tms99000_dasm(char *buffer, unsigned pc);
 
+#endif
+*/
 #ifdef MAME_DEBUG
-extern unsigned Dasm9900 (char *buffer, unsigned pc);
+extern unsigned Dasm9900 (char *buffer, unsigned pc, int model_id);
 #endif
 
 #endif
 
 
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/cpu/z80/z80.c srcmess/cpu/z80/z80.c
--- srcmess.ori/cpu/z80/z80.c	2002-12-12 20:01:26.000000000 +0100
+++ srcmess/cpu/z80/z80.c	2003-02-12 02:11:49.000000000 +0100
@@ -80,10 +80,16 @@
 
 #ifdef Z80_MSX
 #include "z80_msx.h"
 #endif
 
+#if defined(__GNUC__) && __GNUC__ >= 3
+/* Disable all the asm macro and the big switch */
+#undef X86_ASM
+#define BIG_SWITCH 0
+#endif
+
 #define VERBOSE 0
 
 #if VERBOSE
 #define LOG(x)	logerror x
 #else
@@ -4011,10 +4017,17 @@
 				case 0xc30000:	/* jump */
 					_PCD = irq_vector & 0xffff;
 					/* JP $xxxx + 2 cycles */
 					Z80.extra_cycles += cc[Z80_TABLE_op][0xc3] + cc[Z80_TABLE_ex][0xff];
 					break;
+#ifdef MESS
+				case 0x000000:        /* NOP */
+				    /* pc 8801 disk emulation */
+					/* NOP + 2 cycles */
+					Z80.extra_cycles += cc[Z80_TABLE_op][0] + cc[Z80_TABLE_ex][0xff];
+					break;
+#endif /* MESS */
 				default:		/* rst (or other opcodes?) */
 					PUSH( PC );
 					_PCD = irq_vector & 0x0038;
 					/* RST $xx + 2 cycles */
 					Z80.extra_cycles += cc[Z80_TABLE_op][_PCD] + cc[Z80_TABLE_ex][_PCD];
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/cpu/z80/z80_msx.c srcmess/cpu/z80/z80_msx.c
--- srcmess.ori/cpu/z80/z80_msx.c	1970-01-01 01:00:00.000000000 +0100
+++ srcmess/cpu/z80/z80_msx.c	2001-06-26 21:06:04.000000000 +0200
@@ -0,0 +1,7 @@
+/*
+** Creates the Z80 for the MSX 
+*/
+
+#define Z80_MSX
+#include "z80.c"
+
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/cpu/z80/z80_msx.h srcmess/cpu/z80/z80_msx.h
--- srcmess.ori/cpu/z80/z80_msx.h	1970-01-01 01:00:00.000000000 +0100
+++ srcmess/cpu/z80/z80_msx.h	2002-05-22 03:49:36.000000000 +0200
@@ -0,0 +1,31 @@
+#ifndef Z80_MSX_H
+#define Z80_MSX_H
+
+#include "cpuintrf.h"
+#include "osd_cpu.h"
+
+extern int z80_msx_ICount;          /* T-state count                        */
+
+extern void z80_msx_init(void);
+extern void z80_msx_reset (void *param);
+extern void z80_msx_exit (void);
+extern int z80_msx_execute(int cycles);
+extern void z80_msx_burn(int cycles);
+extern unsigned z80_msx_get_context (void *dst);
+extern void z80_msx_set_context (void *src);
+extern const void *z80_msx_get_cycle_table (int which);
+extern void z80_msx_set_cycle_table (int which, void *new_tbl);
+extern unsigned z80_msx_get_pc (void);
+extern void z80_msx_set_pc (unsigned val);
+extern unsigned z80_msx_get_sp (void);
+extern void z80_msx_set_sp (unsigned val);
+extern unsigned z80_msx_get_reg (int regnum);
+extern void z80_msx_set_reg (int regnum, unsigned val);
+extern void z80_msx_set_nmi_line(int state);
+extern void z80_msx_set_irq_line(int irqline, int state);
+extern void z80_msx_set_irq_callback(int (*irq_callback)(int));
+extern const char *z80_msx_info(void *context, int regnum);
+extern unsigned z80_msx_dasm(char *buffer, unsigned pc);
+
+#endif
+
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/cpuexec.c srcmess/cpuexec.c
--- srcmess.ori/cpuexec.c	2002-12-08 13:32:25.000000000 +0100
+++ srcmess/cpuexec.c	2003-02-12 02:11:49.000000000 +0100
@@ -141,11 +141,11 @@
  *	Save/load variables
  *
  *************************************/
 
 static int loadsave_schedule;
-static char loadsave_schedule_id;
+static char *loadsave_schedule_name;
 
 
 
 /*************************************
  *
@@ -233,10 +233,13 @@
 	watchdog_counter = -1;
 
 	/* reset sound chips */
 	sound_reset();
 
+	/* reset the osd level */
+	osd_reset();
+
 	/* first pass over CPUs */
 	for (cpunum = 0; cpunum < cpu_gettotalcpu(); cpunum++)
 	{
 		/* enable all CPUs (except for audio CPUs if the sound is off) */
 		if (!(Machine->drv->cpu[cpunum].cpu_flags & CPU_AUDIO_CPU) || Machine->sample_rate != 0)
@@ -399,17 +402,15 @@
  *
  *************************************/
 
 static void handle_save(void)
 {
-	char name[2] = { 0 };
 	mame_file *file;
 	int cpunum;
 
 	/* open the file */
-	name[0] = loadsave_schedule_id;
-	file = mame_fopen(Machine->gamedrv->name, name, FILETYPE_STATE, 1);
+	file = mame_fopen(Machine->gamedrv->name, loadsave_schedule_name, FILETYPE_STATE, 1);
 
 	if (file)
 	{
 		/* write the save state */
 		state_save_save_begin(file);
@@ -441,11 +442,11 @@
 	{
 		usrintf_showmessage("Error: Failed to save state");
 	}
 
 	/* unschedule the save */
-	loadsave_schedule = LOADSAVE_NONE;
+	cpu_loadsave_reset();
 }
 
 
 
 /*************************************
@@ -454,17 +455,15 @@
  *
  *************************************/
 
 static void handle_load(void)
 {
-	char name[2] = { 0 };
 	mame_file *file;
 	int cpunum;
 
 	/* open the file */
-	name[0] = loadsave_schedule_id;
-	file = mame_fopen(Machine->gamedrv->name, name, FILETYPE_STATE, 0);
+	file = mame_fopen(Machine->gamedrv->name, loadsave_schedule_name, FILETYPE_STATE, 0);
 
 	/* if successful, load it */
 	if (file)
 	{
 		/* start loading */
@@ -498,11 +497,11 @@
 	{
 		usrintf_showmessage("Error: Failed to load state");
 	}
 
 	/* unschedule the load */
-	loadsave_schedule = LOADSAVE_NONE;
+	cpu_loadsave_reset();
 }
 
 
 
 /*************************************
@@ -518,11 +517,31 @@
 		handle_save();
 	else if (loadsave_schedule == LOADSAVE_LOAD)
 		handle_load();
 
 	/* reset the schedule */
-	loadsave_schedule = LOADSAVE_NONE;
+	cpu_loadsave_reset();
+}
+
+
+
+/*************************************
+ *
+ *	Schedules a save/load for later
+ *
+ *************************************/
+
+void cpu_loadsave_schedule_file(int type, const char *name)
+{
+	cpu_loadsave_reset();
+
+	loadsave_schedule_name = malloc(strlen(name) + 1);
+	if (loadsave_schedule_name)
+	{
+		strcpy(loadsave_schedule_name, name);
+		loadsave_schedule = type;
+	}
 }
 
 
 
 /*************************************
@@ -531,12 +550,13 @@
  *
  *************************************/
 
 void cpu_loadsave_schedule(int type, char id)
 {
-	loadsave_schedule = type;
-	loadsave_schedule_id = id;
+	char name[256];
+	sprintf(name, "%s-%c", Machine->gamedrv->name, id);
+	cpu_loadsave_schedule_file(type, name);
 }
 
 
 
 /*************************************
@@ -546,10 +566,15 @@
  *************************************/
 
 void cpu_loadsave_reset(void)
 {
 	loadsave_schedule = LOADSAVE_NONE;
+	if (loadsave_schedule_name)
+	{
+		free(loadsave_schedule_name);
+		loadsave_schedule_name = NULL;
+	}
 }
 
 
 #if 0
 #pragma mark -
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/cpuexec.h srcmess/cpuexec.h
--- srcmess.ori/cpuexec.h	2002-12-08 13:32:31.000000000 +0100
+++ srcmess/cpuexec.h	2003-01-27 18:36:36.000000000 +0100
@@ -93,10 +93,11 @@
 	LOADSAVE_NONE,
 	LOADSAVE_SAVE,
 	LOADSAVE_LOAD
 };
 void cpu_loadsave_schedule(int type, char id);
+void cpu_loadsave_schedule_file(int type, const char *name);
 void cpu_loadsave_reset(void);
 
 
 
 /*************************************
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/cpuintrf.c srcmess/cpuintrf.c
--- srcmess.ori/cpuintrf.c	2003-01-12 21:04:05.000000000 +0100
+++ srcmess/cpuintrf.c	2003-01-23 17:24:29.000000000 +0100
@@ -152,41 +152,41 @@
 
 
 #ifdef MESS
 
 #if (HAS_APEXC)
-#include "mess/cpu/apexc/apexc.h"
+#include "cpu/apexc/apexc.h"
 #endif
 #if (HAS_CDP1802)
-#include "mess/cpu/cdp1802/cdp1802.h"
+#include "cpu/cdp1802/cdp1802.h"
 #endif
 #if (HAS_CP1600)
-#include "mess/cpu/cp1600/cp1600.h"
+#include "cpu/cp1600/cp1600.h"
 #endif
 #if (HAS_F8)
-#include "mess/cpu/f8/f8.h"
+#include "cpu/f8/f8.h"
 #endif
 #if (HAS_G65816)
-#include "mess/cpu/g65816/g65816.h"
+#include "cpu/g65816/g65816.h"
 #endif
 #if (HAS_LH5801)
-#include "mess/cpu/lh5801/lh5801.h"
+#include "cpu/lh5801/lh5801.h"
 #endif
 #if (HAS_PDP1)
-#include "mess/cpu/pdp1/pdp1.h"
+#include "cpu/pdp1/pdp1.h"
 #endif
 #if (HAS_SATURN)
-#include "mess/cpu/saturn/saturn.h"
+#include "cpu/saturn/saturn.h"
 #endif
 #if (HAS_SC61860)
-#include "mess/cpu/sc61860/sc61860.h"
+#include "cpu/sc61860/sc61860.h"
 #endif
 #if (HAS_SPC700)
-#include "mess/cpu/spc700/spc700.h"
+#include "cpu/spc700/spc700.h"
 #endif
 #if (HAS_Z80GB)
-#include "mess/cpu/z80gb/z80gb.h"
+#include "cpu/z80gb/z80gb.h"
 #endif
 #if (HAS_Z80_MSX)
 #include "cpu/z80/z80_msx.h"
 #endif
 
@@ -532,10 +532,13 @@
 	CPU0(TMS34010, tms34010, 2,  0,1.00,16,29lew,  3,29,LE,2,10	),
 #endif
 #if (HAS_TMS34020)
 	CPU0(TMS34020, tms34020, 2,  0,1.00,16,29lew,  3,29,LE,2,10	),
 #endif
+#if (HAS_TI990_10)
+	/*CPU4*/CPU0(TI990_10, ti990_10, 1,  0,1.00,			   16,/*21*/24bew,  0,/*21*/24,BE,2, 6	),
+#endif
 #if (HAS_TMS9900)
 	CPU0(TMS9900,  tms9900,  1,  0,1.00,16,16bew,  0,16,BE,2, 6	),
 #endif
 #if (HAS_TMS9940)
 	CPU0(TMS9940,  tms9940,  1,  0,1.00,16,16bew,  0,16,BE,2, 6	),
@@ -644,11 +647,11 @@
 #define cdp1802_ICount cdp1802_icount
 	CPU0(CDP1802,  cdp1802,  1,  0,1.00, 8, 16,	  0,16,BE,1, 3	),
 #endif
 #if (HAS_CP1600)
 #define cp1600_ICount cp1600_icount
-	CPU0(CP1600,   cp1600,	 0,  0,1.00, 8, 16,	  0,16,LE,1, 3	),
+	CPU0(CP1600,   cp1600,	 4,  0,1.00, 16, 24bew,  -1,17,BE,2,3	),
 #endif
 #if (HAS_F8)
 #define f8_ICount f8_icount
 	CPU4(F8,	   f8,		 1,  0,1.00, 8, 16,	  0,16,LE,1, 3	),
 #endif
@@ -658,11 +661,12 @@
 #if (HAS_LH5801)
 #define lh5801_ICount lh5801_icount
 	CPU0(LH5801,   lh5801,	 1,  0,1.00, 8, 17,	  0,17,BE,1, 5	),
 #endif
 #if (HAS_PDP1)
-	CPU0(PDP1,	   pdp1,	 0,  0,1.00, 8, 16,	  0,18,LE,1, 3	),
+	//CPU0(PDP1,	   pdp1,	 0,  0,1.00, 8, 16,	  0,18,LE,1, 3	),
+	CPU0(PDP1,	   pdp1,	 0,  0,1.00,32,18bedw,0,18,LE,1, 3	),
 #endif
 #if (HAS_SATURN)
 #define saturn_ICount saturn_icount
 	CPU0(SATURN,   saturn,	 1,  0,1.00, 8,20,	  0,20,LE,1, 21 ),
 #endif
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/cpuintrf.h srcmess/cpuintrf.h
--- srcmess.ori/cpuintrf.h	2003-01-12 21:03:25.000000000 +0100
+++ srcmess/cpuintrf.h	2003-01-23 05:32:09.000000000 +0100
@@ -185,10 +185,13 @@
 	CPU_TMS34010,
 #endif
 #if (HAS_TMS34020)
 	CPU_TMS34020,
 #endif
+#if (HAS_TI990_10)
+	CPU_TI990_10,
+#endif
 #if (HAS_TMS9900)
 	CPU_TMS9900,
 #endif
 #if (HAS_TMS9940)
 	CPU_TMS9940,
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/fileio.c srcmess/fileio.c
--- srcmess.ori/fileio.c	2003-01-14 23:34:58.000000000 +0100
+++ srcmess/fileio.c	2003-01-27 18:36:37.000000000 +0100
@@ -42,10 +42,17 @@
 #define FILEFLAG_CRC			0x04
 #define FILEFLAG_REVERSE_SEARCH	0x08
 #define FILEFLAG_VERIFY_ONLY	0x10
 #define FILEFLAG_NOZIP			0x20
 
+#ifdef MESS
+#define FILEFLAG_ALLOW_ABSOLUTE	0x40
+#define FILEFLAG_ZIP_PATHS		0x80
+#define FILEFLAG_CREATE_GAMEDIR	0x100
+#define FILEFLAG_MUST_EXIST		0x200
+#endif
+
 
 
 /***************************************************************************
 	TYPE DEFINITIONS
 ***************************************************************************/
@@ -54,21 +61,30 @@
 {
 	osd_file *file;
 	UINT8 *data;
 	UINT64 offset;
 	UINT64 length;
+	UINT8 eof;
 	UINT8 type;
 	UINT32 crc;
 };
 
 
 
 /***************************************************************************
 	PROTOTYPES
 ***************************************************************************/
 
-extern unsigned int crc32(unsigned int crc, const UINT8 *buf, unsigned int len);
+#ifndef ZEXPORT
+#ifdef _MSC_VER
+#define ZEXPORT __stdcall
+#else
+#define ZEXPORT
+#endif
+#endif
+
+extern unsigned int ZEXPORT crc32(unsigned int crc, const UINT8 *buf, unsigned int len);
 
 static mame_file *generic_fopen(int pathtype, const char *gamename, const char *filename, UINT32 crc, UINT32 flags);
 static const char *get_extension_for_filetype(int filetype);
 static int checksum_file(int pathtype, int pathindex, const char *file, UINT8 **p, UINT64 *size, UINT32 *crc);
 
@@ -84,11 +100,13 @@
 	switch (filetype)
 	{
 		/* read-only cases */
 		case FILETYPE_ROM:
 		case FILETYPE_ROM_NOCRC:
+#ifndef MESS
 		case FILETYPE_IMAGE:
+#endif
 		case FILETYPE_SAMPLE:
 		case FILETYPE_HIGHSCORE_DB:
 		case FILETYPE_ARTWORK:
 		case FILETYPE_HISTORY:
 		case FILETYPE_LANGUAGE:
@@ -121,11 +139,32 @@
 		case FILETYPE_ROM_NOCRC:
 			return generic_fopen(filetype, gamename, filename, 0, FILEFLAG_OPENREAD);
 
 		/* read-only disk images */
 		case FILETYPE_IMAGE:
+#ifndef MESS
 			return generic_fopen(filetype, gamename, filename, 0, FILEFLAG_OPENREAD | FILEFLAG_NOZIP);
+#else
+			{
+				int flags = FILEFLAG_ALLOW_ABSOLUTE | FILEFLAG_ZIP_PATHS;
+				switch(openforwrite) {
+				case OSD_FOPEN_READ:   
+					flags |= FILEFLAG_OPENREAD | FILEFLAG_CRC;   
+					break;   
+				case OSD_FOPEN_WRITE:   
+					flags |= FILEFLAG_OPENWRITE;   
+					break;
+				case OSD_FOPEN_RW:   
+					flags |= FILEFLAG_OPENREAD | FILEFLAG_OPENWRITE | FILEFLAG_MUST_EXIST;   
+					break;   
+				case OSD_FOPEN_RW_CREATE:
+					flags |= FILEFLAG_OPENREAD | FILEFLAG_OPENWRITE;
+					break;
+				} 
+				return generic_fopen(filetype, gamename, filename, 0, flags);
+			}
+#endif
 
 		/* differencing disk images */
 		case FILETYPE_IMAGE_DIFF:
 			return generic_fopen(filetype, gamename, filename, 0, FILEFLAG_OPENREAD | FILEFLAG_OPENWRITE);
 
@@ -137,11 +176,16 @@
 		case FILETYPE_ARTWORK:
 			return generic_fopen(filetype, gamename, filename, 0, FILEFLAG_OPENREAD);
 
 		/* NVRAM files */
 		case FILETYPE_NVRAM:
+#ifdef MESS
+			if (filename)
+				return generic_fopen(filetype, gamename, filename, 0, openforwrite ? FILEFLAG_OPENWRITE | FILEFLAG_CREATE_GAMEDIR : FILEFLAG_OPENREAD);
+#else
 			return generic_fopen(filetype, NULL, gamename, 0, openforwrite ? FILEFLAG_OPENWRITE : FILEFLAG_OPENREAD);
+#endif
 
 		/* high score files */
 		case FILETYPE_HIGHSCORE:
 			if (!mame_highscore_enabled())
 				return NULL;
@@ -159,15 +203,15 @@
 		case FILETYPE_INPUTLOG:
 			return generic_fopen(filetype, NULL, gamename, 0, openforwrite ? FILEFLAG_OPENWRITE : FILEFLAG_OPENREAD);
 
 		/* save state files */
 		case FILETYPE_STATE:
-		{
-			char temp[256];
-			sprintf(temp, "%s-%s", gamename, filename);
-			return generic_fopen(filetype, NULL, temp, 0, openforwrite ? FILEFLAG_OPENWRITE : FILEFLAG_OPENREAD);
-		}
+#ifndef MESS
+			return generic_fopen(filetype, NULL, filename, 0, openforwrite ? FILEFLAG_OPENWRITE : FILEFLAG_OPENREAD);
+#else
+			return generic_fopen(filetype, NULL, filename, 0, FILEFLAG_ALLOW_ABSOLUTE | (openforwrite ? FILEFLAG_OPENWRITE : FILEFLAG_OPENREAD));
+#endif
 
 		/* memory card files */
 		case FILETYPE_MEMCARD:
 			return generic_fopen(filetype, NULL, filename, 0, openforwrite ? FILEFLAG_OPENWRITE : FILEFLAG_OPENREAD);
 
@@ -301,11 +345,14 @@
 		case ZIPPED_FILE:
 		case RAM_FILE:
 			if (file->data)
 			{
 				if (file->offset + length > file->length)
+				{
 					length = file->length - file->offset;
+					file->eof = 1;
+				}
 				memcpy(buffer, file->data + file->offset, length);
 				file->offset += length;
 				return length;
 			}
 			break;
@@ -360,10 +407,11 @@
 					break;
 				case SEEK_END:
 					file->offset = file->length + offset;
 					break;
 			}
+			file->eof = 0;
 			break;
 	}
 
 	return err;
 }
@@ -452,10 +500,12 @@
 
 		case RAM_FILE:
 		case ZIPPED_FILE:
 			if (file->offset < file->length)
 				return file->data[file->offset++];
+			else
+				file->eof = 1;
 			return EOF;
 	}
 	return EOF;
 }
 
@@ -469,17 +519,27 @@
 {
 	/* switch off the file type */
 	switch (file->type)
 	{
 		case PLAIN_FILE:
-			if (osd_fseek(file->file, -1, SEEK_CUR))
-				return c;
+			if (osd_feof(file->file))
+			{
+				if (osd_fseek(file->file, 0, SEEK_CUR))
+					return c;
+			}
+			else
+			{
+				if (osd_fseek(file->file, -1, SEEK_CUR))
+					return c;
+			}
 			return EOF;
 
 		case RAM_FILE:
 		case ZIPPED_FILE:
-			if (file->offset > 0)
+			if (file->eof)
+				file->eof = 0;
+			else if (file->offset > 0)
 			{
 				file->offset--;
 				return c;
 			}
 			return EOF;
@@ -552,11 +612,11 @@
 		case PLAIN_FILE:
 			return osd_feof(file->file);
 
 		case RAM_FILE:
 		case ZIPPED_FILE:
-			return (file->offset >= file->length);
+			return (file->eof);
 	}
 
 	return 1;
 }
 
@@ -653,10 +713,18 @@
 INLINE void compose_path(char *output, const char *gamename, const char *filename, const char *extension)
 {
 	char *filename_base = output;
 	*output = 0;
 
+#ifdef MESS
+	if (filename && osd_is_absolute_path(filename))
+	{
+		strcpy(output, filename);
+		return;
+	}
+#endif
+
 	/* if there's a gamename, add that; only add a '/' if there is a filename as well */
 	if (gamename)
 	{
 		strcat(output, gamename);
 		if (filename)
@@ -699,13 +767,15 @@
 		case FILETYPE_CHEAT:		/* cheat file */
 		default:					/* anything else */
 			extension = NULL;
 			break;
 
+#ifndef MESS
 		case FILETYPE_IMAGE:		/* disk image files */
 			extension = "chd";
 			break;
+#endif
 
 		case FILETYPE_IMAGE_DIFF:	/* differencing drive images */
 			extension = "dif";
 			break;
 
@@ -767,10 +837,20 @@
 	int pathcount = osd_get_path_count(pathtype);
 	int pathindex, pathstart, pathstop, pathinc;
 	mame_file file, *newfile;
 	char tempname[256];
 
+#ifdef MESS
+	int is_absolute_path = osd_is_absolute_path(filename);
+	if (is_absolute_path)
+	{
+		if ((flags & FILEFLAG_ALLOW_ABSOLUTE) == 0)
+			return NULL;
+		pathcount = 1;
+	}
+#endif
+
 	LOG(("generic_fopen(%d, %s, %s, %s, %X)\n", pathc, gamename, filename, extension, flags));
 
 	/* reset the file handle */
 	memset(&file, 0, sizeof(file));
 
@@ -801,10 +881,22 @@
 
 		/* first look for path/gamename as a directory */
 		compose_path(name, gamename, NULL, NULL);
 		LOG(("Trying %s\n", name));
 
+#ifdef MESS
+		if (is_absolute_path)
+		{
+			*name = 0;
+		}
+		else if (flags & FILEFLAG_CREATE_GAMEDIR)
+		{
+			if (osd_get_path_info(pathtype, pathindex, name) == PATH_NOT_FOUND)
+				osd_create_directory(pathtype, pathindex, name);
+		}
+#endif
+
 		/* if the directory exists, proceed */
 		if (*name == 0 || osd_get_path_info(pathtype, pathindex, name) == PATH_IS_DIRECTORY)
 		{
 			/* now look for path/gamename/filename.ext */
 			compose_path(name, gamename, filename, extension);
@@ -817,20 +909,75 @@
 					file.type = RAM_FILE;
 					break;
 				}
 			}
 
+#ifdef MESS
+			else if ((flags & FILEFLAG_MUST_EXIST) && (osd_get_path_info(pathtype, pathindex, name) == PATH_NOT_FOUND))
+			{
+				/* if FILEFLAG_MUST_EXIST is set and the file isn't there, don't open it */
+			}
+#endif
+
 			/* otherwise, just open it straight */
 			else
 			{
 				file.type = PLAIN_FILE;
 				file.file = osd_fopen(pathtype, pathindex, name, access_modes[flags & 3]);
 				if (file.file == NULL && (flags & 3) == 3)
 					file.file = osd_fopen(pathtype, pathindex, name, "w+b");
 				if (file.file != NULL)
 					break;
 			}
+
+#ifdef MESS
+			if (flags & FILEFLAG_ZIP_PATHS)
+			{
+				int path_info;
+				const char *oldname = name;
+				const char *zipentryname;
+				char *newname = NULL;
+				char *oldnewname = NULL;
+				char *s;
+				UINT32 ziplength;
+
+				while((path_info = osd_get_path_info(pathtype, pathindex, oldname)) == PATH_NOT_FOUND)
+				{
+					newname = osd_dirname(oldname);
+					if (oldnewname)
+						free(oldnewname);
+					oldname = oldnewname = newname;
+					if (!newname)
+						break;
+					
+					for (s = newname + strlen(newname) - 1; s >= newname && osd_is_path_separator(*s); s--)
+						*s = '\0';
+				}
+
+				if (newname)
+				{
+					if (path_info == PATH_IS_FILE)
+					{
+						zipentryname = name + strlen(newname);
+						while(osd_is_path_separator(*zipentryname))
+							zipentryname++;
+
+						if (load_zipped_file(pathtype, pathindex, newname, zipentryname, &file.data, &ziplength) == 0)
+						{
+							LOG(("Using (mame_fopen) zip file for %s\n", filename));
+							file.length = ziplength;
+							file.type = ZIPPED_FILE;
+							file.crc = crc32(0L, file.data, file.length);
+							break;
+						}
+					}
+					free(newname);
+				}
+			}
+			if (is_absolute_path)
+				continue;
+#endif
 		}
 
 		/* ----------------- STEP 2: OPEN THE FILE IN A ZIP -------------------- */
 
 		/* now look for it within a ZIP file */
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/fileio.h srcmess/fileio.h
--- srcmess.ori/fileio.h	2002-12-09 10:05:11.000000000 +0100
+++ srcmess/fileio.h	2003-01-23 05:32:12.000000000 +0100
@@ -37,10 +37,13 @@
 	FILETYPE_HISTORY,
 	FILETYPE_CHEAT,
 	FILETYPE_LANGUAGE,
 	FILETYPE_CTRLR,
 	FILETYPE_INI,
+#ifdef MESS
+	FILETYPE_CRC,
+#endif
 	FILETYPE_end /* dummy last entry */
 };
 
 
 /* gamename holds the driver name, filename is only used for ROMs and    */
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/harddisk.c srcmess/harddisk.c
--- srcmess.ori/harddisk.c	2003-01-01 21:20:13.000000000 +0100
+++ srcmess/harddisk.c	2003-01-23 13:39:11.000000000 +0100
@@ -41,11 +41,13 @@
  *
  *************************************/
 
 #define SET_ERROR_AND_CLEANUP(err) do { last_error = (err); goto cleanup; } while (0)
 
-
+#ifdef _MSC_VER
+#define interface interface_
+#endif
 
 /*************************************
  *
  *	Type definitions
  *
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/info.c srcmess/info.c
--- srcmess.ori/info.c	2002-12-06 00:02:46.000000000 +0100
+++ srcmess/info.c	2003-02-12 02:11:49.000000000 +0100
@@ -741,10 +741,39 @@
 	fprintf(out, SELECT(L2P "palettesize %d" L2N, "\t\t\t<palettesize>%d</palettesize>\n"), driver.total_colors);
 
 	fprintf(out, SELECT(L2E L1N, "\t\t</driver>\n"));
 }
 
+#ifdef MESS
+static void print_game_device(FILE* out, const struct GameDriver* game) {
+	const struct IODevice* dev = device_first(game);
+
+	while (dev) {
+		const char* ext = dev->file_extensions;
+
+		fprintf(out, L1P "device" L2B);
+		fprintf(out, L2P "name \"%s\"" L2N, device_typename(dev->type));
+
+		while (*ext) {
+			/* some drivers put the extension separated by a , */
+			char* ext_list = strdup(ext);
+			char* ext_item = strtok(ext_list, ",");
+			while (ext_item && ext_item[0]) {
+				fprintf(out, L2P "ext \"%s\"" L2N, ext_item);
+				ext_item = strtok(0 ,",");
+			}
+			free(ext_list);
+			ext += strlen(ext) + 1;
+		}
+
+		fprintf(out, L2E L1N);
+
+		dev = device_next(game, dev);
+	}
+}
+#endif
+
 /* Print the MAME info record for a game */
 static void print_game_info(FILE* out, const struct GameDriver* game)
 {
 
 #ifndef MESS
@@ -784,10 +813,13 @@
 	print_game_video(out,game);
 	print_game_sound(out,game);
 	print_game_input(out,game);
 	print_game_switch(out,game);
 	print_game_driver(out,game);
+#ifdef MESS
+	print_game_device(out,game);
+#endif
 
 	fprintf(out, SELECT(L1E, "\t</game>\n"));
 }
 
 #if !defined(MESS) && !defined(TINY_COMPILE) && !defined(CPSMAME) && !defined(MMSND)
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/inptport.c srcmess/inptport.c
--- srcmess.ori/inptport.c	2002-11-20 21:21:00.000000000 +0100
+++ srcmess/inptport.c	2003-02-12 02:11:49.000000000 +0100
@@ -11,10 +11,14 @@
 ***************************************************************************/
 
 #include "driver.h"
 #include <math.h>
 
+#ifdef MESS
+#include "inputx.h"
+#endif
+
 #ifdef MAME_NET
 #include "network.h"
 
 static unsigned short input_port_defaults[MAX_INPUT_PORTS];
 static int default_player;
@@ -147,10 +151,13 @@
 	{ IPT_UI_SHOW_PROFILER,     "Show Profiler",		SEQ_DEF_2(KEYCODE_F11, KEYCODE_LSHIFT) },
 #ifdef MESS
 	{ IPT_UI_TOGGLE_UI,         "UI Toggle",			SEQ_DEF_1(KEYCODE_SCRLOCK) },
 #endif
 	{ IPT_UI_SNAPSHOT,          "Save Snapshot",		SEQ_DEF_1(KEYCODE_F12) },
+	{ IPT_UI_RECORD_START,      "Record Start", SEQ_DEF_2(KEYCODE_ENTER,KEYCODE_LCONTROL) },
+	{ IPT_UI_RECORD_STOP,       "Record Stop", SEQ_DEF_3(KEYCODE_ENTER,CODE_NOT,KEYCODE_LCONTROL) },
+	{ IPT_UI_TURBO,             "Turbo", SEQ_DEF_1(KEYCODE_ASTERISK) },
 	{ IPT_UI_TOGGLE_CHEAT,      "Toggle Cheat",			SEQ_DEF_1(KEYCODE_F6) },
 	{ IPT_UI_UP,                "UI Up",				SEQ_DEF_3(KEYCODE_UP, CODE_OR, JOYCODE_1_UP) },
 	{ IPT_UI_DOWN,              "UI Down",				SEQ_DEF_3(KEYCODE_DOWN, CODE_OR, JOYCODE_1_DOWN) },
 	{ IPT_UI_LEFT,              "UI Left",				SEQ_DEF_3(KEYCODE_LEFT, CODE_OR, JOYCODE_1_LEFT) },
 	{ IPT_UI_RIGHT,             "UI Right",				SEQ_DEF_3(KEYCODE_RIGHT, CODE_OR, JOYCODE_1_RIGHT) },
@@ -158,10 +165,12 @@
 	{ IPT_UI_CANCEL,            "UI Cancel",			SEQ_DEF_1(KEYCODE_ESC) },
 	{ IPT_UI_PAN_UP,            "Pan Up",				SEQ_DEF_3(KEYCODE_PGUP, CODE_NOT, KEYCODE_LSHIFT) },
 	{ IPT_UI_PAN_DOWN,          "Pan Down",				SEQ_DEF_3(KEYCODE_PGDN, CODE_NOT, KEYCODE_LSHIFT) },
 	{ IPT_UI_PAN_LEFT,          "Pan Left",				SEQ_DEF_2(KEYCODE_PGUP, KEYCODE_LSHIFT) },
 	{ IPT_UI_PAN_RIGHT,         "Pan Right",			SEQ_DEF_2(KEYCODE_PGDN, KEYCODE_LSHIFT) },
+	{ IPT_UI_MODE_NEXT,         "Mode Next",         SEQ_DEF_1(KEYCODE_STOP) },
+	{ IPT_UI_MODE_PRED,         "Mode Pred",         SEQ_DEF_1(KEYCODE_COMMA) },	
 	{ IPT_UI_TOGGLE_DEBUG,      "Toggle Debugger",		SEQ_DEF_1(KEYCODE_F5) },
 	{ IPT_UI_SAVE_STATE,        "Save State",			SEQ_DEF_2(KEYCODE_F7, KEYCODE_LSHIFT) },
 	{ IPT_UI_LOAD_STATE,        "Load State",			SEQ_DEF_3(KEYCODE_F7, CODE_NOT, KEYCODE_LSHIFT) },
 	{ IPT_UI_ADD_CHEAT,			"Add Cheat",			SEQ_DEF_1(KEYCODE_A) },
 	{ IPT_UI_DELETE_CHEAT,		"Delete Cheat",			SEQ_DEF_1(KEYCODE_D) },
@@ -1694,14 +1703,16 @@
 		int new, prev;
 
 		/* center stick */
 		if ((delta == 0) && (in->type & IPF_CENTER))
 		{
-			if (current > default_value)
-			delta = -100 / sensitivity;
-			if (current < default_value)
-			delta = 100 / sensitivity;
+			/* return backward at middle speed */
+			delta = default_value - current;
+			if (delta < -(keydelta+1)/2)
+				delta = -(keydelta+1)/2;
+			if (delta > (keydelta+1)/2)
+				delta = (keydelta+1)/2;
 		}
 
 		/* An analog joystick which is not at zero position (or has just */
 		/* moved there) takes precedence over all other computations */
 		/* analog_x/y holds values from -128 to 128 (yes, 128, not 127) */
@@ -2059,10 +2070,15 @@
 				{
 					InputSeq* seq;
 					seq = input_port_seq(in);
 					if (seq_pressed(seq))
 					{
+#ifdef MESS
+						if (((in->type & ~IPF_MASK) == IPT_KEYBOARD) && osd_keyboard_disabled())
+							continue;
+#endif
+
 						/* skip if coin input and it's locked out */
 						if ((in->type & ~IPF_MASK) >= IPT_COIN1 &&
 							(in->type & ~IPF_MASK) <= IPT_COIN4 &&
                             coinlockedout[(in->type & ~IPF_MASK) - IPT_COIN1])
 						{
@@ -2184,10 +2200,14 @@
 			}
 			if (in->type == IPT_PORT) in++;
 		}
 	}
 
+#ifdef MESS
+	inputx_update(input_port_value);
+#endif
+
 	if (record)
 	{
 		int i;
 
 		for (i = 0; i < MAX_INPUT_PORTS; i ++)
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/inptport.h srcmess/inptport.h
--- srcmess.ori/inptport.h	2002-11-15 18:36:21.000000000 +0100
+++ srcmess/inptport.h	2003-02-12 02:11:49.000000000 +0100
@@ -67,10 +67,13 @@
 	IPT_START1, IPT_START2, IPT_START3, IPT_START4,	/* start buttons */
 	IPT_COIN1, IPT_COIN2, IPT_COIN3, IPT_COIN4,	/* coin slots */
 	IPT_SERVICE1, IPT_SERVICE2, IPT_SERVICE3, IPT_SERVICE4,	/* service coin */
 	IPT_SERVICE, IPT_TILT,
 	IPT_DIPSWITCH_NAME, IPT_DIPSWITCH_SETTING,
+#ifdef MESS
+	IPT_UCHAR,
+#endif
 /* Many games poll an input bit to check for vertical blanks instead of using */
 /* interrupts. This special value allows you to handle that. If you set one of the */
 /* input bits to this, the bit will be inverted while a vertical blank is happening. */
 	IPT_VBLANK,
 	IPT_UNKNOWN,
@@ -81,10 +84,15 @@
 	IPT_OSD_4,
 	IPT_EXTENSION,	/* this is an extension on the previous InputPort, not a real inputport. */
 					/* It is used to store additional parameters for analog inputs */
 
 	/* the following are special codes for user interface handling - not to be used by drivers! */
+	IPT_UI_MODE_NEXT,
+	IPT_UI_MODE_PRED,
+	IPT_UI_RECORD_START,
+	IPT_UI_RECORD_STOP,
+	IPT_UI_TURBO,
 	IPT_UI_CONFIGURE,
 	IPT_UI_ON_SCREEN_DISPLAY,
 	IPT_UI_PAUSE,
 	IPT_UI_RESET_MACHINE,
 	IPT_UI_SHOW_GFX,
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/input.c srcmess/input.c
--- srcmess.ori/input.c	2002-06-30 20:57:54.000000000 +0200
+++ srcmess/input.c	2003-02-12 02:11:49.000000000 +0100
@@ -782,11 +782,11 @@
 {
 	int pressed;
 
 	profiler_mark(PROFILER_INPUT);
 
-	pressed = seq_pressed(input_port_type_seq(code));
+	pressed = osd_input_ui_filter(seq_pressed(input_port_type_seq(code)),code);
 
 	if (pressed)
 	{
 		if (ui_map[code].memory == 0)
 		{
@@ -806,11 +806,11 @@
 	static int counter,inputdelay;
 	int pressed;
 
 	profiler_mark(PROFILER_INPUT);
 
-	pressed = seq_pressed(input_port_type_seq(code));
+	pressed = osd_input_ui_filter(seq_pressed(input_port_type_seq(code)),code);
 
 	if (pressed)
 	{
 		if (ui_map[code].memory == 0)
 		{
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/machine/6522via.c srcmess/machine/6522via.c
--- srcmess.ori/machine/6522via.c	2002-11-15 19:28:40.000000000 +0100
+++ srcmess/machine/6522via.c	2003-02-04 18:08:51.000000000 +0100
@@ -62,12 +62,14 @@
 	UINT8 ier;
 	UINT8 ifr;
 
 	void *t1;
 	double time1;
+	char t1_active;
 	void *t2;
 	double time2;
+	char t2_active;
 
 	double cycles_to_sec;
 	double sec_to_cycles;
 };
 
@@ -227,11 +229,11 @@
     }
 	else
     {
 		if (T1_SET_PB7(v->acr))
 			v->out_b |= 0x80;
-		v->t1 = 0;
+		v->t1_active = 0;
 		v->time1=timer_get_time();
     }
 	if (v->ddr_b)
 	{
 		UINT8 write_data = v->out_b & v->ddr_b;
@@ -253,11 +255,11 @@
 	if (v->intf->t2_callback)
 		v->intf->t2_callback(timer_timeelapsed(v->t2));
 	else
 		logerror("6522VIA chip %d: T2 timout occured but there is no callback.  PC: %08X\n", which, activecpu_get_pc());
 
-	v->t2 = 0;
+	v->t2_active = 0;
 	v->time2=timer_get_time();
 
 	if (!(v->ifr & INT_T2))
 		via_set_int (which, INT_T2);
 }
@@ -282,11 +284,13 @@
 		v.time2 = via[i].time2;
 		v.sec_to_cycles = via[i].sec_to_cycles;
 		v.cycles_to_sec = via[i].cycles_to_sec;
 
 		v.t1 = timer_alloc(via_t1_timeout);
+		v.t1_active = 0;
 		v.t2 = timer_alloc(via_t2_timeout);
+		v.t2_active = 0;
 
 		via[i] = v;
     }
 }
 
@@ -376,11 +380,11 @@
 		val = v->ddr_a;
 		break;
 
     case VIA_T1CL:
 		via_clear_int (which, INT_T1);
-		if (v->t1)
+		if (v->t1_active)
 			val = V_TIME_TO_CYCLES(timer_timeleft(v->t1)) & 0xff;
 		else
 		{
 			if ( T1_CONTINUOUS(v->acr) )
 			{
@@ -396,11 +400,11 @@
 			}
 		}
 		break;
 
     case VIA_T1CH:
-		if (v->t1)
+		if (v->t1_active)
 			val = V_TIME_TO_CYCLES(timer_timeleft(v->t1)) >> 8;
 		else
 		{
 			if ( T1_CONTINUOUS(v->acr) )
 			{
@@ -425,11 +429,11 @@
 		val = v->t1lh;
 		break;
 
     case VIA_T2CL:
 		via_clear_int (which, INT_T2);
-		if (v->t2)
+		if (v->t2_active)
 			val = V_TIME_TO_CYCLES(timer_timeleft(v->t2)) & 0xff;
 		else
 		{
 			if (T2_COUNT_PB6(v->acr))
 			{
@@ -443,11 +447,11 @@
 			}
 		}
 		break;
 
     case VIA_T2CH:
-		if (v->t2)
+		if (v->t2_active)
 			val = V_TIME_TO_CYCLES(timer_timeleft(v->t2)) >> 8;
 		else
 		{
 			if (T2_COUNT_PB6(v->acr))
 			{
@@ -585,11 +589,11 @@
     	/* EHC 03/04/2000 - If data direction changed, present output on the lines */
     	if ( data != v->ddr_b )
     	{
 			v->ddr_b = data;
 
-			if (v->ddr_b)
+			//if (v->ddr_b)
 			{
 				UINT8 write_data = v->out_b & v->ddr_b;
 
 				if (v->intf->out_b_func)
 					v->intf->out_b_func(0, write_data);
@@ -603,11 +607,11 @@
     	/* EHC 03/04/2000 - If data direction changed, present output on the lines */
     	if ( data != v->ddr_a )
     	{
 			v->ddr_a = data;
 
-			if (v->ddr_a)
+			//if (v->ddr_a)
 			{
 				UINT8 write_data = v->out_a & v->ddr_a;
 
 				if (v->intf->out_a_func)
 					v->intf->out_a_func(0, write_data);
@@ -635,21 +639,22 @@
 
 		if (T1_SET_PB7(v->acr))
 		{
 			v->out_b &= 0x7f;
 
-			if (v->ddr_b)
+			//if (v->ddr_b)
 			{
 				UINT8 write_data = v->out_b & v->ddr_b;
 
 				if (v->intf->out_b_func)
 					v->intf->out_b_func(0, write_data);
 				else
 					logerror("6522VIA chip %d: Port B is being written to but has no handler.  PC: %08X - %02X\n", which, activecpu_get_pc(), write_data);
 			}
 		}
 		timer_adjust (v->t1, V_CYCLES_TO_TIME(TIMER1_VALUE(v) + IFR_DELAY), which, 0);
+		v->t1_active = 1;
 		break;
 
     case VIA_T2CL:
 		v->t2ll = data;
 		break;
@@ -666,10 +671,11 @@
 				v->intf->t2_callback(timer_timeelapsed(v->t2));
 			else
 				logerror("6522VIA chip %d: T2 timout occured but there is no callback.  PC: %08X\n", which, activecpu_get_pc());
 
 			timer_adjust (v->t2, V_CYCLES_TO_TIME(TIMER2_VALUE(v) + IFR_DELAY), which, 0);
+			v->t2_active = 1;
 		}
 		else
 		{
 			v->time2=timer_get_time();
 		}
@@ -725,16 +731,16 @@
 
     case VIA_ACR:
 		v->acr = data;
 		if (T1_SET_PB7(v->acr))
 		{
-			if (v->t1)
+			if (v->t1_active)
 				v->out_b &= ~0x80;
 			else
 				v->out_b |= 0x80;
 
-			if (v->ddr_b)
+			//if (v->ddr_b)
 			{
 				UINT8 write_data = v->out_b & v->ddr_b;
 
 				if (v->intf->out_b_func)
 					v->intf->out_b_func(0, write_data);
@@ -743,10 +749,11 @@
 			}
 		}
 		if (T1_CONTINUOUS(data))
 		{
 			timer_adjust (v->t1, V_CYCLES_TO_TIME(TIMER1_VALUE(v) + IFR_DELAY), which, 0);
+			v->t1_active = 1;
 		}
 		/* kludge for Mac Plus (and 128k, 512k, 512ke) : */
 		if (SI_EXT_CONTROL(data))
 		{
 			if (v->intf->si_ready_func)
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/machine/8255ppi.c srcmess/machine/8255ppi.c
--- srcmess.ori/machine/8255ppi.c	2002-05-19 17:12:23.000000000 +0200
+++ srcmess/machine/8255ppi.c	2002-05-25 23:46:00.000000000 +0200
@@ -12,31 +12,79 @@
 
 #include "driver.h"
 #include "machine/8255ppi.h"
 
 
+static void	ppi8255_set_intra(int which);
+
 static int num;
 
+/* mode 2 inte flags */
+#define PPI8255_INTE1_FLAG (1<<6)
+#define PPI8255_INTE2_FLAG (1<<4)
+
 typedef struct
 {
+
 	mem_read_handler portAread;
 	mem_read_handler portBread;
 	mem_read_handler portCread;
 	mem_write_handler portAwrite;
 	mem_write_handler portBwrite;
 	mem_write_handler portCwrite;
 	int groupA_mode;
 	int groupB_mode;
-	int in_mask[3];	/* input mask */
-	int out_mask[3];/* output mask */
+	int io[3];		/* input output status */
 	int latch[3];	/* data written to ports */
+	
+	/* mode 2 mode data */
+	mem_write_handler obfa_write;
+	mem_write_handler intra_write;
+	mem_write_handler ibfa_write;
+	int inte_flags;
 } ppi8255;
 
+
+
 static ppi8255 chips[MAX_8255];
 
 static void set_mode(int which, int data, int call_handlers);
 
+static void ppi8255_obfa_w(int which, int data)
+{
+	ppi8255 *chip = &chips[which];
+
+	if (data)
+		chip->latch[2]|=(1<<7);
+	else
+		chip->latch[2]&=~(1<<7);
+	
+	/* a low on this output indicates that CPU has written data out to port A */
+	if (chip->obfa_write)
+	{
+		logerror("8255 ppi output obfa: %d\n",data & 0x01);
+		chip->obfa_write(0,data & 0x01);
+	}
+}
+
+static void ppi8255_ibfa_w(int which, int data)
+{
+	ppi8255 *chip = &chips[which];
+
+	if (data)
+		chip->latch[2]|=(1<<5);
+	else
+		chip->latch[2]&=~(1<<5);
+
+	if (chip->ibfa_write)
+	{
+		logerror("8255 ppi output ibfa: %d\n",data & 0x01);
+		chip->ibfa_write(0,data & 0x01);
+	}
+
+}
+
 
 void ppi8255_init( ppi8255_interface *intfce )
 {
 	int i;
 
@@ -48,20 +96,22 @@
 		chips[i].portBread = intfce->portBread[i];
 		chips[i].portCread = intfce->portCread[i];
 		chips[i].portAwrite = intfce->portAwrite[i];
 		chips[i].portBwrite = intfce->portBwrite[i];
 		chips[i].portCwrite = intfce->portCwrite[i];
+		chips[i].obfa_write = NULL;
+		chips[i].intra_write = NULL;
+		chips[i].ibfa_write = NULL;
 
 		set_mode(i, 0x1b, 0);	/* Mode 0, all ports set to input */
 	}
 }
 
 
-int ppi8255_r(int which, int offset)
+int ppi8255_r( int which, int offset )
 {
 	ppi8255 *chip = &chips[which];
-	int result = 0;
 
 	/* some bounds checking */
 	if (which > num)
 	{
 		logerror("Attempting to access an unmapped 8255 chip.  PC: %04X\n", activecpu_get_pc());
@@ -74,137 +124,330 @@
 		return 0xff;
 	}
 
 	switch(offset)
 	{
-		case 0: /* Port A read */
-			if (chip->in_mask[0])
+	case 0: /* Port A read */
+	{
+		switch (chip->groupA_mode)
+		{
+			case 0:
 			{
-				if (chip->portAread)
-					result = (*chip->portAread)(0) & chip->in_mask[0];
+				if (chip->io[0] == 0)
+					return chip->latch[0];	/* output */
 				else
-					logerror("8255 chip %d: Port A is being read (mask %02x) but has no handler.  PC: %08X\n", which, chip->in_mask[0], activecpu_get_pc());
+					if (chip->portAread)  return (*chip->portAread)(0);	/* input */
 			}
-			result |= chip->latch[0] & chip->out_mask[0] & ~chip->in_mask[0];
 			break;
 
-		case 1: /* Port B read */
-			if (chip->in_mask[1])
+			case 1:
 			{
-				if (chip->portBread)
-					result = (*chip->portBread)(0) & chip->in_mask[1];
-				else
-					logerror("8255 chip %d: Port B is being read (mask %02x) but has no handler.  PC: %08X\n", which, chip->in_mask[1], activecpu_get_pc());
 			}
-			result |= chip->latch[1] & chip->out_mask[1] & ~chip->in_mask[1];
 			break;
 
-		case 2: /* Port C read */
-			if (chip->in_mask[2])
+
+			case 2:
+			{
+				int data;
+
+				data = chip->latch[0];
+
+				/* input buffer is now empty */
+				ppi8255_ibfa_w(which, 0);
+
+				ppi8255_set_intra(which);
+
+				logerror("8255 chip %d: Read latched data from port A %02x\n",which, data);
+
+				/* return latched data */
+				return data;
+			}
+			break;
+
+			default:
+				break;
+
+		}
+	}
+	break;
+
+	case 1: /* Port B read */
+		if (chip->io[1] == 0)
+			return chip->latch[1];	/* output */
+		else
+			if (chip->portBread)  return (*chip->portBread)(0);	/* input */
+		break;
+
+	case 2: /* Port C read */
+	{
+		switch (chip->groupA_mode)
+		{
+			case 0:
 			{
+				int data;
+
+				data = chip->latch[2] & (~chip->io[2]);
+
 				if (chip->portCread)
-					result = (*chip->portCread)(0) & chip->in_mask[2];
-				else
-					logerror("8255 chip %d: Port C is being read (mask %02x) but has no handler.  PC: %08X\n", which, chip->in_mask[2], activecpu_get_pc());
+				{
+					data |= chip->portCread(0) & chip->io[2];
+				}
+
+				return data;
 			}
-			result |= chip->latch[2] & chip->out_mask[2] & ~chip->in_mask[2];
 			break;
 
-		case 3: /* Control word */
-			result = 0xff;
+			case 2:
+			{
+				/* return data - combination of input and latched output depending on
+				   the input/output status of each half of port C */
+				int data;
+
+				data =  (
+							/* keep state of obf, ibf, intra */
+							(chip->latch[2] & ((1<<7)|(1<<5)|(1<<3))) |
+							/* inte1 and inte2 flags */
+							(chip->inte_flags & ((1<<6)|(1<<4))) |
+							/* state of bits 2..0 depending on input/output status */
+							((chip->latch[2] & (~chip->io[2])) & 0x07)
+						);
+				
+				if (chip->portCread)
+				{
+					data  |= chip->portCread(0) & chip->io[2] & 0x07;
+				}
+
+				logerror("port c data: %02x\n",data);
+
+				return data;
+			}
 			break;
+
+			case 1:
+				break;
+
+			default:
+				break;
+		}
+	}
+	break;
+
+	case 3: /* Control word */
+		return 0xff;
 	}
 
-	return result;
+	logerror("8255 chip %d: Port %c is being read but has no handler.  PC: %04X\n", which, 'A' + offset, activecpu_get_pc());
+
+	return 0xff;
 }
 
 
 
 #define PPI8255_PORT_A_WRITE()							\
 {														\
-	int write_data = (chip->latch[0] & chip->out_mask[0]) |	(0xff & ~chip->out_mask[0]);	\
+	int write_data;										\
+														\
+	write_data = (chip->latch[0] & ~chip->io[0]) |		\
+				 (0xff & chip->io[0]);					\
 														\
 	if (chip->portAwrite)								\
 		(*chip->portAwrite)(0, write_data);				\
 	else												\
-		logerror("8255 chip %d: Port A is being written to (mask %02x) but has no handler.  PC: %08X - %02X\n", which, chip->out_mask[0], activecpu_get_pc(), write_data);	\
+		logerror("8255 chip %d: Port A is being written to but has no handler.  PC: %08X - %02X\n", which, activecpu_get_pc(), write_data);	\
 }
 
 #define PPI8255_PORT_B_WRITE()							\
 {														\
-	int write_data = (chip->latch[1] & chip->out_mask[1]) |	(0xff & ~chip->out_mask[1]);	\
+	int write_data;										\
+														\
+	write_data = (chip->latch[1] & ~chip->io[1]) |		\
+				 (0xff & chip->io[1]);					\
 														\
 	if (chip->portBwrite)								\
 		(*chip->portBwrite)(0, write_data);				\
 	else												\
-		logerror("8255 chip %d: Port B is being written to (mask %02x) but has no handler.  PC: %08X - %02X\n", which, chip->out_mask[1], activecpu_get_pc(), write_data);	\
+		logerror("8255 chip %d: Port B is being written to but has no handler.  PC: %08X - %02X\n", which, activecpu_get_pc(), write_data);	\
 }
 
 #define PPI8255_PORT_C_WRITE()							\
 {														\
-	int write_data = (chip->latch[2] & chip->out_mask[2]) |	(0xff & ~chip->out_mask[2]);	\
+	int write_data;										\
+														\
+	write_data = (chip->latch[2] & ~chip->io[2]) |		\
+				 (0xff & chip->io[2]);					\
 														\
 	if (chip->portCwrite)								\
 		(*chip->portCwrite)(0, write_data);				\
 	else												\
-		logerror("8255 chip %d: Port C is being written to (mask %02x) but has no handler.  PC: %08X - %02X\n", which, chip->out_mask[2], activecpu_get_pc(), write_data);	\
+		logerror("8255 chip %d: Port C is being written to but has no handler.  PC: %08X - %02X\n", which, activecpu_get_pc(), write_data);	\
 }
 
 
-void ppi8255_w(int which, int offset, int data)
+void ppi8255_w( int which, int offset, int data )
 {
-	ppi8255	*chip = &chips[which];
+	ppi8255	*chip;
+
 
 	/* Some bounds checking */
 	if (which > num)
 	{
 		logerror("Attempting to access an unmapped 8255 chip.  PC: %04X\n", activecpu_get_pc());
 		return;
 	}
 
+	chip = &chips[which];
+
+
 	if (offset > 3)
 	{
 		logerror("Attempting to access an invalid 8255 register.  PC: %04X\n", activecpu_get_pc());
 		return;
 	}
 
+
 	switch( offset )
 	{
-		case 0: /* Port A write */
-			chip->latch[0] = data;
-			PPI8255_PORT_A_WRITE();
+	case 0: /* Port A write */
+	{
+		chip->latch[0] = data;
+
+		
+		switch (chip->groupA_mode)
+		{
+			default:
+			case 0:
+			{
+				PPI8255_PORT_A_WRITE();
+			}
 			break;
 
-		case 1: /* Port B write */
-			chip->latch[1] = data;
-			PPI8255_PORT_B_WRITE();
+			case 1:
+			{
+				logerror("mode not supported by emulation\n");
+
+			}
 			break;
 
-		case 2: /* Port C write */
-			chip->latch[2] = data;
-			PPI8255_PORT_C_WRITE();
+
+			case 2:
+			{
+				/* mode 2 */
+				logerror("8255 chip %d: Write to port A latch %02x\n",which, chip->latch[0]);
+
+				if (chip->portAwrite)
+					chip->portAwrite(0,chip->latch[0]);
+
+				ppi8255_obfa_w(which, 0);
+
+				ppi8255_set_intra(which);
+
+			}
 			break;
+		}
+	}
+	break;
+
+	case 1: /* Port B write */
+		chip->latch[1] = data;
+		PPI8255_PORT_B_WRITE();
+		break;
 
-		case 3: /* Control word */
-			if (data & 0x80)
+	case 2: /* Port C write */
+	{
+		switch (chip->groupA_mode)
+		{
+			case 0:
 			{
-				set_mode(which, data & 0x7f, 1);
+				chip->latch[2] = data;
+				PPI8255_PORT_C_WRITE();
 			}
-			else
+			break;
+
+			case 1:
 			{
-				/* bit set/reset */
-				int bit;
 
-				bit = (data >> 1) & 0x07;
 
-				if (data & 1)
-					chip->latch[2] |= (1<<bit);		/* set bit */
-				else
-					chip->latch[2] &= ~(1<<bit);	/* reset bit */
+			}
+			break;
 
+			case 2:
+			{
+				/* not possible to set flag states with write */
+				chip->latch[2] = (data & 0x07) | chip->latch[2];
 				PPI8255_PORT_C_WRITE();
 			}
+			break;
+
+			default:
+				break;
+		}
+	}
+	break;
+
+	case 3: /* Control word */
+		if ( data & 0x80 )
+		{
+			set_mode(which, data & 0x7f, 1);
+		}
+		else
+		{
+			/* bit set/reset */
+			int bit;
+			int newData;
+
+			bit = (data >> 1) & 0x07;
+			
+			if (data & 1)
+			{
+				newData = chip->latch[2] | (1<<bit);
+			}
+			else
+			{
+				newData = chip->latch[2] & (~(1<<bit));
+			}
+
+			switch (chip->groupA_mode)
+			{
+				case 0:
+				{
+				}
+				break;
+
+				case 1:
+				{
+				}
+				break;
+
+				case 2:
+				{
+
+					/* set inte flags from bits 6 and 4 */
+					chip->inte_flags = newData & ((1<<6)|(1<<4));
+
+					/* bit set, reset can be used to set the signal of any output bit obf, ibf, intra */
+					/* states of inputs remain */
+					newData = 
+						(
+						/* keep state of ack and stb */
+						(chip->latch[2] & ((1<<6)|(1<<4))) |
+						/* allow changing of output flags and bits 2..0 */
+						(newData & ((1<<7)|(1<<5)|(1<<3)|0x07))
+						);
+
+					/* enable intra output */
+					ppi8255_set_intra(which);
+
+				}
+				break;
+			
+				default:
+					break;
+			}
+
+			chip->latch[2] = newData;
+		}
+	
 	}
 }
 
 #ifdef MESS
 data8_t ppi8255_peek( int which, offs_t offset )
@@ -234,104 +477,121 @@
 	return chip->latch[offset];
 }
 #endif
 
 
-void ppi8255_set_portAread(int which, mem_read_handler portAread)
+void ppi8255_set_portAread( int which, mem_read_handler portAread)
 {
 	chips[which].portAread = portAread;
 }
 
-void ppi8255_set_portBread(int which, mem_read_handler portBread)
+void ppi8255_set_portBread( int which, mem_read_handler portBread)
 {
 	chips[which].portBread = portBread;
 }
 
-void ppi8255_set_portCread(int which, mem_read_handler portCread)
+void ppi8255_set_portCread( int which, mem_read_handler portCread)
 {
 	chips[which].portCread = portCread;
 }
 
 
-void ppi8255_set_portAwrite(int which, mem_write_handler portAwrite)
+void ppi8255_set_portAwrite( int which, mem_write_handler portAwrite)
 {
 	chips[which].portAwrite = portAwrite;
 }
 
-void ppi8255_set_portBwrite(int which, mem_write_handler portBwrite)
+void ppi8255_set_portBwrite( int which, mem_write_handler portBwrite)
 {
 	chips[which].portBwrite = portBwrite;
 }
 
-void ppi8255_set_portCwrite(int which, mem_write_handler portCwrite)
+void ppi8255_set_portCwrite( int which, mem_write_handler portCwrite)
 {
 	chips[which].portCwrite = portCwrite;
 }
 
 
 static void set_mode(int which, int data, int call_handlers)
 {
 	ppi8255 *chip = &chips[which];
 
-	chip->groupA_mode = (data >> 5) & 3;
-	chip->groupB_mode = (data >> 2) & 1;
-
-	if ((chip->groupA_mode == 1) || (chip->groupB_mode == 1))
-	{
-		logerror("8255 chip %d: Setting an unsupported mode %02X.  PC: %04X\n", which, data & 0x62, activecpu_get_pc());
-		return;
-	}
-
-	/* Group A mode 0 */
-	if (chip->groupA_mode == 0)
-	{
-		/* Port A direction */
-		if (data & 0x10)
-			chip->in_mask[0] = 0xff, chip->out_mask[0] = 0x00;	/* input */
-		else
-			chip->in_mask[0] = 0x00, chip->out_mask[0] = 0xff; 	/* output */
-
-		/* Port C upper direction */
-		if (data & 0x08)
-			chip->in_mask[2] |= 0xf0, chip->out_mask[2] &= ~0xf0;	/* input */
-		else
-			chip->in_mask[2] &= ~0xf0, chip->out_mask[2] |= 0xf0;	/* output */
-	}
+	chip->groupA_mode = ( data >> 5 ) & 3;
+	chip->groupB_mode = ( data >> 2 ) & 1;
 
-	/* Group A mode 2/3 */
-	else
-	{
-		chip->in_mask[0] = 0xff;
-		chip->out_mask[0] = 0xff;
+	if (chip->groupA_mode == 3)
+		chip->groupA_mode = 2;
 
-		chip->in_mask[2] = 0xf7;
-		chip->out_mask[2] = 0xff;
-	}
+        logerror("8255 chip %d: group A mode %d\n",which,chip->groupA_mode);
+        logerror("8255 chip %d: group B mode %d\n",which,chip->groupB_mode);
 
-	/* Group B mode 0 */
+	if (((chip->groupA_mode != 0) && (chip->groupA_mode!=2)) || (chip->groupB_mode != 0))
 	{
-		/* Port B direction */
-		if (data & 0x02)
-			chip->in_mask[1] = 0xff, chip->out_mask[1] = 0x00;	/* input */
-		else
-			chip->in_mask[1] = 0x00, chip->out_mask[1] = 0xff; 	/* output */
-
-		/* Port C lower direction */
-		if (data & 0x01)
-			chip->in_mask[2] |= 0x0f, chip->out_mask[2] &= ~0x0f;	/* input */
-		else
-			chip->in_mask[2] &= ~0x0f, chip->out_mask[2] |= 0x0f;	/* output */
+		logerror("8255 chip %d: Setting an unsupported mode %02X.  PC: %04X\n", which, data & 0x62, activecpu_get_pc());
+		return;
 	}
 
+	chip->io[0] = 0;
+	chip->io[1] = 0;
+	chip->io[2] = 0;
+
+	/* Port A direction */
+	if ( data & 0x10 )
+        {
+                chip->io[0] = 0xff;             /* input */
+                logerror("8255 chip %d: port A input\n",which);
+        }
+        else
+        {
+                logerror("8255 chip %d: port A output\n",which);
+        }
+
+	/* Port B direction */
+	if ( data & 0x02 )
+        {
+		chip->io[1] = 0xff;
+                logerror("8255 chip %d: port B input\n",which);
+         }
+         else
+         {
+                logerror("8255 chip %d: port B output\n",which);
+         }
+	/* Port C upper direction */
+	if ( data & 0x08 )
+		chip->io[2] |= 0xf0;
+
+	/* Port C lower direction */
+	if ( data & 0x01 )
+		chip->io[2] |= 0x0f;
+	
 	/* KT: 25-Dec-99 - 8255 resets latches when mode set */
 	chip->latch[0] = chip->latch[1] = chip->latch[2] = 0;
 
 	if (call_handlers)
 	{
-		if (chip->portAwrite) PPI8255_PORT_A_WRITE();
-		if (chip->portBwrite) PPI8255_PORT_B_WRITE();
-		if (chip->portCwrite) PPI8255_PORT_C_WRITE();
+		if (chip->portAwrite)  PPI8255_PORT_A_WRITE();
+		if (chip->portBwrite)  PPI8255_PORT_B_WRITE();
+	
+		if (chip->groupA_mode == 0)
+		{
+			if (chip->portCwrite)  PPI8255_PORT_C_WRITE();
+		}
+		else
+		{
+			/* all output registers and status flip-flops are reset on mode change or reset */
+			chip->inte_flags = 0;
+
+			/* don't know if this is correct or not */
+
+			/* output buffer empty */
+			ppi8255_obfa_w(which, 0);
+			/* input buffer empty */
+			ppi8255_ibfa_w(which, 0);
+			
+			ppi8255_set_intra(which);
+		}
+
 	}
 }
 
 
 /* Helpers */
@@ -349,5 +609,119 @@
 WRITE_HANDLER( ppi8255_3_w ) { ppi8255_w( 3, offset, data ); }
 WRITE_HANDLER( ppi8255_4_w ) { ppi8255_w( 4, offset, data ); }
 WRITE_HANDLER( ppi8255_5_w ) { ppi8255_w( 5, offset, data ); }
 WRITE_HANDLER( ppi8255_6_w ) { ppi8255_w( 6, offset, data ); }
 WRITE_HANDLER( ppi8255_7_w ) { ppi8255_w( 7, offset, data ); }
+
+
+/*************************/
+
+void ppi8255_set_input_acka(int which, int data)
+{
+	ppi8255 *chip = &chips[which];
+
+	if (chip->groupA_mode==2)
+	{
+		logerror("8255 ppi input acka: %d\n",data);
+
+		if (data)
+			chip->latch[2] |= (1<<6);
+		else
+			chip->latch[2] &= ~(1<<6);
+
+		/* low on pin latches out data to port A */
+		if (data==0)
+		{
+			/* output buffer is now empty */
+			ppi8255_obfa_w(which, 1);
+
+
+	//		/* set output latch to high impedance */
+	//		chip->latch[0] = 0x0ff;
+		}
+
+		ppi8255_set_intra(which);
+
+	}
+}
+
+/* a low on the strobe input (/stb)  loads data into the input latch */
+void ppi8255_set_input_stba(int which, int data)
+{
+	ppi8255 *chip = &chips[which];
+
+	if (chip->groupA_mode==2)
+	{
+		logerror("8255 ppi input stba: %d\n",data);
+
+		if (data)
+			chip->latch[2] |= (1<<4);
+		else
+			chip->latch[2] &= ~(1<<4);
+
+		if (data==0)
+		{
+			/* latch data from port A */
+			if (chip->portAread)  chip->latch[0] = chip->portAread(0);
+
+			logerror("8255 chip %d: Received /STBA, just latched data into port A %02x\n",which, chip->latch[0]);
+
+			/* input buffer is full */
+			ppi8255_ibfa_w(which, 1);
+
+			/* "high" indicates data has been loaded into the input latch */
+
+		}
+		
+		ppi8255_set_intra(which);
+	}
+}
+
+/* high indicates interrupt */
+static void	ppi8255_set_intra(int which)
+{
+	ppi8255 *chip = &chips[which];
+
+	int state;
+
+	state = 0;
+
+	if (
+		/* /stb = 1, ibf = 1, inte = 1 */
+		/* ack = 1, /obf = 1, inte = 1 */
+		(
+			((chip->latch[2] & ((1<<5)|(1<<4)))==((1<<5)|(1<<4))) &&
+			((chip->inte_flags & (1<<4))==(1<<4))
+		) ||
+		(
+			((chip->latch[2] & ((1<<7)|(1<<6)))==((1<<7)|(1<<6))) &&
+			((chip->inte_flags & (1<<6))==(1<<6))
+		)
+		)	
+	{
+		state = 1;
+	}
+
+	if (state)
+		chip->latch[2]|=(1<<3);
+	else
+		chip->latch[2]&=~(1<<3);
+
+	if (chip->intra_write)
+	{
+		logerror("8255 ppi output intra: %d\n",state);
+		chip->intra_write(0,state);
+	}
+}
+
+
+void ppi8255_set_mode2_interface( ppi8255_mode2_interface *intfce)
+{
+	int i;
+
+	for (i = 0; i < num; i++)
+	{
+		chips[i].obfa_write = intfce->obfa_write[i];
+		chips[i].intra_write = intfce->intra_write[i];
+		chips[i].ibfa_write = intfce->ibfa_write[i];
+	}
+}
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/machine/8255ppi.h srcmess/machine/8255ppi.h
--- srcmess.ori/machine/8255ppi.h	2002-04-22 00:56:14.000000000 +0200
+++ srcmess/machine/8255ppi.h	2002-05-25 23:46:00.000000000 +0200
@@ -50,6 +50,30 @@
 WRITE_HANDLER( ppi8255_3_w );
 WRITE_HANDLER( ppi8255_4_w );
 WRITE_HANDLER( ppi8255_5_w );
 WRITE_HANDLER( ppi8255_6_w );
 WRITE_HANDLER( ppi8255_7_w );
+
+
+/**************************************************************************/
+/* Added by Kev Thacker */
+/* mode 2 (used by Sord M5 to communicate with FD-5 disc interface */
+
+/* interface for mode 2 */
+typedef struct 
+{
+	mem_write_handler	obfa_write[MAX_8255];
+	mem_write_handler	intra_write[MAX_8255];
+	mem_write_handler	ibfa_write[MAX_8255];
+} ppi8255_mode2_interface;
+
+/* set interface to use for mode 2 */
+/* call AFTER setting interface with other function */
+void ppi8255_set_mode2_interface( ppi8255_mode2_interface *intfce);
+
+/* set acka input */
+void ppi8255_set_input_acka(int which, int data);
+
+/* set stba input */
+void ppi8255_set_input_stba(int which, int data);
+
 #endif
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/mame.c srcmess/mame.c
--- srcmess.ori/mame.c	2003-01-02 17:52:20.000000000 +0100
+++ srcmess/mame.c	2003-02-12 02:11:49.000000000 +0100
@@ -7,27 +7,27 @@
 ****************************************************************************
 
 	Since there has been confusion in the past over the order of
 	initialization and other such things, here it is, all spelled out
 	as of May, 2002:
-
+	
 	main()
 		- does platform-specific init
 		- calls run_game()
-
+		
 		run_game()
 			- constructs the machine driver
 			- calls init_game_options()
-
+			
 			init_game_options()
 				- determines color depth from the options
 				- computes orientation from the options
-
+			
 			- initializes the savegame system
 			- calls osd_init() to do platform-specific initialization
 			- calls init_machine()
-
+			
 			init_machine()
 				- initializes the localized strings
 				- initializes the input system
 				- parses and allocates the game's input ports
 				- initializes the hard disk system
@@ -36,16 +36,16 @@
 				- starts the refresh timer
 				- initializes the CPUs
 				- loads the configuration file
 				- initializes the memory system for the game
 				- calls the driver's DRIVER_INIT callback
-
+			
 			- calls run_machine()
-
+			
 			run_machine()
 				- calls vh_open()
-
+				
 				vh_open()
 					- allocates the palette
 					- decodes the graphics
 					- computes vector game resolution
 					- sets up the artwork
@@ -54,54 +54,54 @@
 					- sets the initial visible_area
 					- sets up buffered spriteram
 					- creates the user interface font
 					- creates the debugger bitmap and font
 					- finishes palette initialization
-
+				
 				- initializes the tilemap system
 				- calls the driver's VIDEO_START callback
 				- starts the audio system
 				- disposes of regions marked as disposable
 				- calls run_machine_core()
-
+				
 				run_machine_core()
 					- shows the copyright screen
 					- shows the game warnings
 					- initializes the user interface
 					- initializes the cheat system
 					- calls the driver's NVRAM_HANDLER
-
+					
 	--------------( at this point, we're up and running )---------------------------
-
+	
 					- calls the driver's NVRAM_HANDLER
 					- tears down the cheat system
 					- saves the game's configuration
-
+				
 				- stops the audio system
 				- calls the driver's VIDEO_STOP callback
 				- tears down the tilemap system
 				- calls vh_close()
-
+				
 				vh_close()
 					- frees the decoded graphics
 					- frees the fonts
 					- calls osd_close_display() to shut down the display
 					- tears down the artwork
 					- tears down the palette system
-
+				
 			- calls shutdown_machine()
-
+			
 			shutdown_machine()
 				- tears down the memory system
 				- frees all the memory regions
 				- tears down the hard disks
 				- tears down the CPU system
 				- releases the input ports
 				- tears down the input system
 				- tears down the localized strings
 				- resets the saved state system
-
+			
 			- calls osd_exit() to do platform-specific cleanup
 
 		- exits the program
 
 ***************************************************************************/
@@ -217,10 +217,14 @@
 static int decode_graphics(const struct GfxDecodeInfo *gfxdecodeinfo);
 static void compute_aspect_ratio(const struct InternalMachineDriver *drv, int *aspect_x, int *aspect_y);
 static void scale_vectorgames(int gfx_width, int gfx_height, int *width, int *height);
 static int init_buffered_spriteram(void);
 
+#ifdef MESS
+#include "mesintrf.h"
+#define handle_user_interface	handle_mess_user_interface
+#endif
 
 
 /***************************************************************************
 
 	Inline functions
@@ -288,18 +292,18 @@
 	else
 		cpu_loadsave_reset();
 
 	/* here's the meat of it all */
 	bailing = 0;
-
+	
 	/* let the OSD layer start up first */
 	if (osd_init())
 		bail_and_print("Unable to initialize system");
 	else
 	{
 		begin_resource_tracking();
-
+		
 		/* then finish setting up our local machine */
 		if (init_machine())
 			bail_and_print("Unable to initialize machine emulation");
 		else
 		{
@@ -424,12 +428,12 @@
 }
 
 
 
 /*-------------------------------------------------
-	run_machine - start the various subsystems
-	and the CPU emulation; returns non zero in
+	run_machine - start the various subsystems 
+	and the CPU emulation; returns non zero in 
 	case of error
 -------------------------------------------------*/
 
 static int run_machine(void)
 {
@@ -440,11 +444,11 @@
 		bail_and_print("Unable to start video emulation");
 	else
 	{
 		/* initialize tilemaps */
 		tilemap_init();
-
+		
 		/* start up the driver's video */
 		if (Machine->drv->video_start && (*Machine->drv->video_start)())
 			bail_and_print("Unable to start video emulation");
 		else
 		{
@@ -465,19 +469,19 @@
 						for (i = 0; i < memory_region_length(region); i++)
 							memory_region(region)[i] = rand();
 						free(Machine->memory_region[region].base);
 						Machine->memory_region[region].base = 0;
 					}
-
+				
 				/* now do the core execution */
 				run_machine_core();
 				res = 0;
 
 				/* store the sound system */
 				sound_stop();
 			}
-
+			
 			/* shut down the driver's video and kill and artwork */
 			if (Machine->drv->video_stop)
 				(*Machine->drv->video_stop)();
 		}
 
@@ -557,11 +561,11 @@
 }
 
 
 
 /*-------------------------------------------------
-	shutdown_machine - tear down the emulated
+	shutdown_machine - tear down the emulated 
 	machine
 -------------------------------------------------*/
 
 static void shutdown_machine(void)
 {
@@ -592,11 +596,11 @@
 	/* close down the input system */
 	code_close();
 
 	/* close down the localization */
 	uistring_shutdown();
-
+	
 	/* reset the saved states */
 	state_save_reset();
 }
 
 
@@ -662,11 +666,11 @@
 	else
 	{
 		params.width = bmwidth;
 		params.height = bmheight;
 	}
-
+	
 	/* fill in the rest of the display parameters */
 	compute_aspect_ratio(Machine->drv, &params.aspect_x, &params.aspect_y);
 	params.depth = Machine->color_depth;
 	params.colors = palette_get_total_colors_with_ui();
 	params.fps = Machine->drv->frames_per_second;
@@ -777,11 +781,11 @@
 	for (i = 0; i < MAX_GFX_ELEMENTS; i++)
 	{
 		freegfx(Machine->gfx[i]);
 		Machine->gfx[i] = 0;
 	}
-
+	
 	/* free the font elements */
 	if (Machine->uifont)
 	{
 		freegfx(Machine->uifont);
 		Machine->uifont = NULL;
@@ -789,11 +793,11 @@
 	if (Machine->debugger_font)
 	{
 		freegfx(Machine->debugger_font);
 		Machine->debugger_font = NULL;
 	}
-
+	
 	/* close down the OSD layer's display */
 	osd_close_display();
 }
 
 
@@ -842,15 +846,15 @@
 		/* first pick a default */
 		if (Machine->drv->video_attributes & VIDEO_NEEDS_6BITS_PER_GUN)
 			Machine->color_depth = 32;
 		else
 			Machine->color_depth = 15;
-
+		
 		/* now allow overrides */
 		if (options.color_depth == 15 || options.color_depth == 32)
 			Machine->color_depth = options.color_depth;
-
+		
 		/* enable alpha for direct video modes */
 		alpha_active = 1;
 		alpha_init();
 	}
 
@@ -875,26 +879,26 @@
 -------------------------------------------------*/
 
 static int decode_graphics(const struct GfxDecodeInfo *gfxdecodeinfo)
 {
 	int i;
-
+	
 	/* loop over all elements */
 	for (i = 0; i < MAX_GFX_ELEMENTS && gfxdecodeinfo[i].memory_region != -1; i++)
 	{
 		int region_length = 8 * memory_region_length(gfxdecodeinfo[i].memory_region);
 		UINT8 *region_base = memory_region(gfxdecodeinfo[i].memory_region);
 		struct GfxLayout glcopy;
 		int j;
-
+		
 		/* make a copy of the layout */
 		glcopy = *gfxdecodeinfo[i].gfxlayout;
 
 		/* if the character count is a region fraction, compute the effective total */
 		if (IS_FRAC(glcopy.total))
 			glcopy.total = region_length / glcopy.charincrement * FRAC_NUM(glcopy.total) / FRAC_DEN(glcopy.total);
-
+		
 		/* loop over all the planes, converting fractions */
 		for (j = 0; j < MAX_GFX_PLANES; j++)
 		{
 			int value = glcopy.planeoffset[j];
 			if (IS_FRAC(value))
@@ -947,32 +951,26 @@
 }
 
 
 
 /*-------------------------------------------------
-	scale_vectorgames - scale the vector games
+	scale_vectorgames - scale the vector games 
 	to a given resolution
 -------------------------------------------------*/
 
 static void scale_vectorgames(int gfx_width, int gfx_height, int *width, int *height)
 {
-	double x_scale, y_scale, scale;
-
-	/* compute the scale values */
-	x_scale = (double)gfx_width / (double)(*width);
-	y_scale = (double)gfx_height / (double)(*height);
-
-	/* pick the smaller scale factor */
-	scale = (x_scale < y_scale) ? x_scale : y_scale;
-
-	/* compute the new size */
-	*width = (int)((double)*width * scale);
-	*height = (int)((double)*height * scale);
-
-	/* round to the nearest 4 pixel value */
-	*width &= ~3;
-	*height &= ~3;
+	if (Machine->orientation & ORIENTATION_SWAP_XY)
+	{
+		*width = gfx_height;
+		*height = gfx_width*9/16;
+	}
+	else
+	{
+		*width = gfx_width;
+		*height = gfx_height;
+	}
 }
 
 
 
 /*-------------------------------------------------
@@ -986,11 +984,11 @@
 	if (spriteram_size == 0)
 	{
 		logerror("vh_open():  Video buffers spriteram but spriteram_size is 0\n");
 		return 0;
 	}
-
+	
 	/* allocate memory for the back buffer */
 	buffered_spriteram = auto_malloc(spriteram_size);
 	if (!buffered_spriteram)
 		return 1;
 
@@ -1053,11 +1051,11 @@
 		Machine->absolute_visible_area.min_x = 0;
 		Machine->absolute_visible_area.max_x = Machine->scrbitmap->width - 1;
 		Machine->absolute_visible_area.min_y = 0;
 		Machine->absolute_visible_area.max_y = Machine->scrbitmap->height - 1;
 	}
-
+	
 	/* raster games need to use the visible area */
 	else
 		Machine->absolute_visible_area = Machine->visible_area;
 
 	/* recompute scanline timing */
@@ -1163,30 +1161,30 @@
 	debug_trace_delay = 0;
 #endif
 
 	/* fill in our portion of the display */
 	current_display.changed_flags = 0;
-
+	
 	/* set the main game bitmap */
 	current_display.game_bitmap = Machine->scrbitmap;
 	current_display.game_bitmap_update = Machine->absolute_visible_area;
 	if (!skipped_it)
 		current_display.changed_flags |= GAME_BITMAP_CHANGED;
-
+	
 	/* set the visible area */
 	current_display.game_visible_area = Machine->absolute_visible_area;
 	if (visible_area_changed)
 		current_display.changed_flags |= GAME_VISIBLE_AREA_CHANGED;
-
+	
 	/* set the vector dirty list */
 	if (Machine->drv->video_attributes & VIDEO_TYPE_VECTOR)
 		if (!full_refresh_pending && !ui_dirty && !skipped_it)
 		{
 			current_display.vector_dirty_pixels = vector_dirty_list;
 			current_display.changed_flags |= VECTOR_PIXELS_CHANGED;
 		}
-
+	
 #ifdef MAME_DEBUG
 	/* set the debugger bitmap */
 	current_display.debug_bitmap = Machine->debug_bitmap;
 	if (debugger_bitmap_changed)
 		current_display.changed_flags |= DEBUG_BITMAP_CHANGED;
@@ -1204,20 +1202,20 @@
 	if (leds_status != current_display.led_state)
 	{
 		current_display.led_state = leds_status;
 		current_display.changed_flags |= LED_STATE_CHANGED;
 	}
-
+	
 	/* update with data from other parts of the system */
 	palette_update_display(&current_display);
-
+	
 	/* render */
 	artwork_update_video_and_audio(&current_display);
-
+	
 	/* update FPS */
 	recompute_fps(skipped_it);
-
+	
 	/* reset dirty flags */
 	visible_area_changed = 0;
 	if (ui_dirty) ui_dirty--;
 }
 
@@ -1231,29 +1229,29 @@
 {
 	/* increment the frame counters */
 	frames_since_last_fps++;
 	if (!skipped_it)
 		rendered_frames_since_last_fps++;
-
+	
 	/* if we didn't skip this frame, we may be able to compute a new FPS */
 	if (!skipped_it && frames_since_last_fps >= FRAMES_PER_FPS_UPDATE)
 	{
 		cycles_t cps = osd_cycles_per_second();
 		cycles_t curr = osd_cycles();
 		double seconds_elapsed = (double)(curr - last_fps_time) * (1.0 / (double)cps);
 		double frames_per_sec = (double)frames_since_last_fps / seconds_elapsed;
-
+		
 		/* compute the performance data */
 		performance.game_speed_percent = 100.0 * frames_per_sec / Machine->drv->frames_per_second;
 		performance.frames_per_second = (double)rendered_frames_since_last_fps / seconds_elapsed;
 
 		/* reset the info */
 		last_fps_time = curr;
 		frames_since_last_fps = 0;
 		rendered_frames_since_last_fps = 0;
 	}
-
+	
 	/* for vector games, compute the vector update count once/second */
 	vfcount++;
 	if (vfcount >= (int)Machine->drv->frames_per_second)
 	{
 		/* from vidhrdw/avgdvg.c */
@@ -1405,11 +1403,11 @@
 }
 
 
 
 /*-------------------------------------------------
-	machine_find_cpu - find a tagged CPU during
+	machine_find_cpu - find a tagged CPU during 
 	machine driver expansion
 -------------------------------------------------*/
 
 struct MachineCPU *machine_find_cpu(struct InternalMachineDriver *machine, const char *tag)
 {
@@ -1424,11 +1422,11 @@
 }
 
 
 
 /*-------------------------------------------------
-	machine_remove_cpu - remove a tagged CPU
+	machine_remove_cpu - remove a tagged CPU 
 	during machine driver expansion
 -------------------------------------------------*/
 
 void machine_remove_cpu(struct InternalMachineDriver *machine, const char *tag)
 {
@@ -1446,11 +1444,11 @@
 }
 
 
 
 /*-------------------------------------------------
-	machine_add_sound - add a sound system during
+	machine_add_sound - add a sound system during 
 	machine driver expansion
 -------------------------------------------------*/
 
 struct MachineSound *machine_add_sound(struct InternalMachineDriver *machine, const char *tag, int type, void *sndintf)
 {
@@ -1471,11 +1469,11 @@
 }
 
 
 
 /*-------------------------------------------------
-	machine_find_sound - find a tagged sound
+	machine_find_sound - find a tagged sound 
 	system during machine driver expansion
 -------------------------------------------------*/
 
 struct MachineSound *machine_find_sound(struct InternalMachineDriver *machine, const char *tag)
 {
@@ -1664,19 +1662,24 @@
 				printf("%s: %s and %s use the same ROM set\n",drivers[i]->source_file,drivers[i]->name,drivers[j]->name);
 				error = 1;
 			}
 		}
 
+#ifndef MESS	/* MAME core: You forgot to tell that your PDP-1 driver misses the sound emulation.
+		   MESS dev: PDP-1 does not "miss" sound emulation, as it never had any sound generator.
+		   MAME core: Huh? Don't you know that every arcade in the world has sound, except minivadr.
+		   MESS dev: I see... */
 		if ((drivers[i]->flags & NOT_A_DRIVER) == 0)
 		{
 			if (drv.sound[0].sound_type == 0 && (drivers[i]->flags & GAME_NO_SOUND) == 0 &&
 					strcmp(drivers[i]->name,"minivadr"))
 			{
 				printf("%s: %s missing GAME_NO_SOUND flag\n",drivers[i]->source_file,drivers[i]->name);
 				error = 1;
 			}
 		}
+#endif
 
 		romp = drivers[i]->rom;
 
 		if (romp)
 		{
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/mame.h srcmess/mame.h
--- srcmess.ori/mame.h	2002-12-08 12:06:38.000000000 +0100
+++ srcmess/mame.h	2003-02-12 02:11:49.000000000 +0100
@@ -44,40 +44,40 @@
 {
 	/* ----- game-related information ----- */
 
 	/* points to the definition of the game machine */
 	const struct GameDriver *gamedrv;
-
+	
 	/* points to the constructed MachineDriver */
 	const struct InternalMachineDriver *drv;
 
 	/* array of memory regions */
-	struct RegionInfo		memory_region[MAX_MEMORY_REGIONS];
-
+	struct RegionInfo memory_region[MAX_MEMORY_REGIONS];
+	
 
 	/* ----- video-related information ----- */
 
 	/* array of pointers to graphic sets (chars, sprites) */
 	struct GfxElement *		gfx[MAX_GFX_ELEMENTS];
-
+	
 	/* main bitmap to render to (but don't do it directly!) */
 	struct mame_bitmap *	scrbitmap;
 
 	/* current visible area, and a prerotated one adjusted for orientation */
-	struct rectangle 		visible_area;
+	struct rectangle visible_area;
 	struct rectangle		absolute_visible_area;
 
 	/* remapped palette pen numbers. When you write directly to a bitmap in a
 	   non-paletteized mode, use this array to look up the pen number. For example,
 	   if you want to use color #6 in the palette, use pens[6] instead of just 6. */
-	pen_t *					pens;
+	pen_t *					pens;	
 
 	/* lookup table used to map gfx pen numbers to color numbers */
-	UINT16 *				game_colortable;
+	UINT16 *				game_colortable;	
 
 	/* the above, already remapped through Machine->pens */
-	pen_t *					remapped_colortable;
+	pen_t *					remapped_colortable;	
 
 	/* video color depth: 16, 15 or 32 */
 	int						color_depth;
 
 	/* video orientation; obsolete; always set to 0 */
@@ -94,48 +94,54 @@
 
 
 	/* ----- input-related information ----- */
 
 	/* the input ports definition from the driver is copied here and modified */
-	struct InputPort *		input_ports;
+	struct InputPort *input_ports;	
 
 	/* original input_ports without modifications */
-	struct InputPort *		input_ports_default;
+	struct InputPort *input_ports_default;
 
 
 	/* ----- user interface-related information ----- */
 
 	/* font used by the user interface */
-	struct GfxElement *		uifont;
-
+	struct GfxElement *uifont;
+	
 	/* font parameters */
-	int 					uifontwidth, uifontheight;
+	int uifontwidth,uifontheight;
 
 	/* user interface visible area */
-	int 					uixmin, uiymin;
-	int 					uiwidth, uiheight;
+	int uixmin,uiymin;
+	int uiwidth,uiheight;
 
 	/* user interface orientation */
-	int 					ui_orientation;
+	int ui_orientation;
 
 
 	/* ----- debugger-related information ----- */
 
 	/* bitmap where the debugger is rendered */
-	struct mame_bitmap *	debug_bitmap;
-
+	struct mame_bitmap *debug_bitmap;
+	
 	/* pen array for the debugger, analagous to the pens above */
-	pen_t *					debug_pens;
+	pen_t *debug_pens;
 
 	/* colortable mapped through the pens, as for the game */
-	pen_t *					debug_remapped_colortable;
+	pen_t *debug_remapped_colortable;
 
 	/* font used by the debugger */
-	struct GfxElement *		debugger_font;
+	struct GfxElement *debugger_font;
 };
 
 
+#ifdef MESS
+#include <stdarg.h>
+#ifndef DECL_SPEC
+#define DECL_SPEC
+#endif
+#endif
 
 /***************************************************************************
 
 	Options passed from the frontend to the main core
 
@@ -181,12 +187,12 @@
 
 	float	brightness;		/* brightness of the display */
 	float	pause_bright;		/* additional brightness when in pause */
 	float	gamma;			/* gamma correction of the display */
 	int		color_depth;	/* 15, 16, or 32, any other value means auto */
-	int		vector_width;	/* requested width for vector games; 0 means default (640) */
-	int		vector_height;	/* requested height for vector games; 0 means default (480) */
+	int vector_width;	/* requested width for vector games; 0 means default (640) */
+	int vector_height;	/* requested height for vector games; 0 means default (480) */
 	int		ui_orientation;	/* orientation of the UI relative to the video */
 
 	int		beam;			/* vector beam width */
 	float	vector_flicker;	/* vector beam flicker effect control */
 	float	vector_intensity;/* vector beam intensity */
@@ -202,15 +208,18 @@
 	int		debug_width;	/* requested width of debugger bitmap */
 	int		debug_height;	/* requested height of debugger bitmap */
 	int		debug_depth;	/* requested depth of debugger bitmap */
 
 	#ifdef MESS
-	UINT32 ram;
+	UINT32	ram;
 	struct ImageFile image_files[MAX_IMAGES];
 	int		image_count;
-	int (*mess_printf_output)(char *fmt, va_list arg);
-	int disable_normal_ui;
+	int		(*mess_printf_output)(const char *fmt, va_list arg);
+	int		disable_normal_ui;
+
+	int		min_width;		/* minimum width for the display */
+	int		min_height;		/* minimum height for the display */
 	#endif
 };
 
 
 
@@ -295,11 +304,11 @@
 ***************************************************************************/
 
 /* ----- core system management ----- */
 
 /* execute a given game by index in the drivers[] array */
-int run_game(int game);
+int run_game (int game);
 
 /* construct a machine driver */
 struct InternalMachineDriver;
 void expand_machine_driver(void (*constructor)(struct InternalMachineDriver *), struct InternalMachineDriver *output);
 
@@ -338,18 +347,19 @@
 
 /* mame_fopen() must use this to know if high score files can be used */
 int mame_highscore_enabled(void);
 
 /* set the state of a given LED */
-void set_led_status(int num, int on);
+void set_led_status(int num,int on);
 
 /* return current performance data */
 const struct performance_info *mame_get_performance_info(void);
 
 /* return the index of the given CPU, or -1 if not found */
 int mame_find_cpu_index(const char *tag);
 
 #ifdef MESS
 #include "mess.h"
+#include "osdutils.h"
 #endif /* MESS */
 
 #endif
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/osdepend.h srcmess/osdepend.h
--- srcmess.ori/osdepend.h	2002-12-21 18:07:36.000000000 +0100
+++ srcmess/osdepend.h	2003-02-12 02:12:51.000000000 +0100
@@ -358,11 +358,34 @@
 /* things like changing the title bar or darkening the display. */
 /* Note that the OS dependant code must NOT stop processing input, since the user */
 /* interface is still active while the game is paused. */
 void osd_pause(int paused);
 
+/******************************************************************************
 
+	Additions
+
+******************************************************************************/
+
+/* called then the game is reset */
+void osd_reset(void);
+
+/* execute the specified menu (0,1,...) */
+int osd_menu(struct mame_bitmap *bitmap, int sel);
+
+/* filter the user interface input state */
+int osd_input_ui_filter(int result, int type);
+
+/* filter the main exit request */
+int osd_input_exit_filter(int result);
+
+/* filter the input port state */
+int osd_input_port_filter(int result, int type);
+
+/* start and stop the video/sound recording. */
+void osd_record_start(void);
+void osd_record_stop(void);
 
 #ifdef MAME_NET
 /* network */
 int osd_net_init(void);
 int osd_net_send(int player, unsigned char buf[], int *size);
@@ -380,13 +403,20 @@
 /* this is here to follow the current mame file hierarchy style */
 #include "osd_mess.h"
 #endif
 
 #ifdef __GNUC__
+#ifndef printf
 void CLIB_DECL logerror(const char *text,...)
       __attribute__ ((format (printf, 1, 2)));
 #else
+#undef printf
+void CLIB_DECL logerror(const char *text,...)
+      __attribute__ ((format (printf, 1, 2)));
+#define printf printf_substitute
+#endif
+#else
 void CLIB_DECL logerror(const char *text,...);
 #endif
 
 #ifdef __cplusplus
 }
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/rules.mak srcmess/rules.mak
--- srcmess.ori/rules.mak	2003-01-12 21:02:51.000000000 +0100
+++ srcmess/rules.mak	2003-01-23 05:32:19.000000000 +0100
@@ -680,10 +680,21 @@
 $(OBJ)/cpu/tms9900/tms9995.o: tms9995.c tms9900.h 99xxcore.h 99xxstat.h
 else
 CPUDEFS += -DHAS_TMS9995=0
 endif
 
+CPU=$(strip $(findstring TMS99010@,$(CPUS)))
+ifneq ($(CPU),)
+OBJDIRS += $(OBJ)/cpu/tms9900
+CPUDEFS += -DHAS_TI990_10=1
+CPUOBJS += $(OBJ)/cpu/tms9900/ti990_10.o
+DBGOBJS += $(OBJ)/cpu/tms9900/9900dasm.o
+$(OBJ)/cpu/tms9900/ti990_10.o: ti990_10.c tms9900.h 99xxcore.h 99xxstat.h
+else
+CPUDEFS += -DHAS_TI990_10=0
+endif                                                                                                                                         
+
 CPU=$(strip $(findstring TMS99105A@,$(CPUS)))
 ifneq ($(CPU),)
 OBJDIRS += $(OBJ)/cpu/tms9900
 CPUDEFS += -DHAS_TMS99105A=1
 CPUOBJS += $(OBJ)/cpu/tms9900/tms9995.o
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/sndintrf.h srcmess/sndintrf.h
--- srcmess.ori/sndintrf.h	2003-01-12 20:49:25.000000000 +0100
+++ srcmess/sndintrf.h	2003-01-23 05:32:19.000000000 +0100
@@ -63,11 +63,11 @@
 #endif
 #if (HAS_NES)
  #ifndef MESS
 #include "sound/nes_apu.h"
  #else
-#include "mess/sound/nesintf.h"
+#include "sound/nesintf.h"
  #endif
 #endif
 #if (HAS_ASTROCADE)
 #include "sound/astrocde.h"
 #endif
@@ -153,20 +153,20 @@
 #include "sound/gaelco.h"
 #endif
 
 #ifdef MESS
 #if (HAS_BEEP)
-#include "mess/sound/beep.h"
+#include "sound/beep.h"
 #endif
 #if (HAS_SPEAKER)
-#include "mess/sound/speaker.h"
+#include "sound/speaker.h"
 #endif
 #if (HAS_TIA)
-#include "mess/sound/tiaintf.h"
+#include "sound/tiaintf.h"
 #endif
 #if (HAS_WAVE)
-#include "mess/sound/wave.h"
+#include "sound/wave.h"
 #endif
 #endif
 
 
 #define SOUND_YM2151_ALT SOUND_YM2151
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/sound/5220intf.c srcmess/sound/5220intf.c
--- srcmess.ori/sound/5220intf.c	2001-09-04 14:22:54.000000000 +0200
+++ srcmess/sound/5220intf.c	2003-01-23 05:38:56.000000000 +0100
@@ -3,10 +3,11 @@
      TMS5220 interface
 
      Written for MAME by Frank Palazzolo
      With help from Neill Corlett
      Additional tweaking by Aaron Giles
+     Speech ROM support and a few bug fixes by R Nabet
 
 ***********************************************************************************************/
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -59,10 +60,15 @@
 	/* initialize a stream */
 	stream = stream_init("TMS5220", intf->mixing_level, Machine->sample_rate, 0, tms5220_update);
 	if (stream == -1)
 		return 1;
 
+	/* init the speech ROM handlers */
+	tms5220_set_read(intf->read);
+	tms5220_set_load_address(intf->load_address);
+	tms5220_set_read_and_branch(intf->read_and_branch);
+
     /* request a sound channel */
     return 0;
 }
 
 
@@ -106,11 +112,11 @@
 
 
 
 /**********************************************************************************************
 
-     tms5220_status_r -- read status from the sound chip
+     tms5220_status_r -- read status or data from the sound chip
 
 ***********************************************************************************************/
 
 READ_HANDLER( tms5220_status_r )
 {
@@ -136,10 +142,28 @@
 
 
 
 /**********************************************************************************************
 
+     tms5220_ready_r -- return the time in seconds until the ready line is asserted
+
+***********************************************************************************************/
+
+double tms5220_time_to_ready(void)
+{
+	double cycles;
+
+	/* bring up to date first */
+	stream_update(stream, -1);
+	cycles = tms5220_cycles_to_ready();
+	return cycles * 80.0 / intf->baseclock;
+}
+
+
+
+/**********************************************************************************************
+
      tms5220_int_r -- return the int status from the sound chip
 
 ***********************************************************************************************/
 
 int tms5220_int_r(void)
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/sound/5220intf.h srcmess/sound/5220intf.h
--- srcmess.ori/sound/5220intf.h	2000-04-05 18:43:48.000000000 +0200
+++ srcmess/sound/5220intf.h	2003-01-20 16:20:15.000000000 +0100
@@ -6,19 +6,24 @@
 	int baseclock;				/* clock rate = 80 * output sample rate,     */
 								/* usually 640000 for 8000 Hz sample rate or */
 								/* usually 800000 for 10000 Hz sample rate.  */
 	int mixing_level;
 	void (*irq)(int state);		/* IRQ callback function */
+
+	int (*read)(int count);			/* speech ROM read callback */
+	void (*load_address)(int data);	/* speech ROM load address callback */
+	void (*read_and_branch)(void);	/* speech ROM read and branch callback */
 };
 
 int tms5220_sh_start(const struct MachineSound *msound);
 void tms5220_sh_stop(void);
 void tms5220_sh_update(void);
 
 WRITE_HANDLER( tms5220_data_w );
 READ_HANDLER( tms5220_status_r );
 int tms5220_ready_r(void);
+double tms5220_time_to_ready(void);
 int tms5220_int_r(void);
 
 void tms5220_reset(void);
 void tms5220_set_frequency(int frequency);
 
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/sound/tms5220.c srcmess/sound/tms5220.c
--- srcmess.ori/sound/tms5220.c	2001-03-26 20:30:48.000000000 +0200
+++ srcmess/sound/tms5220.c	2003-02-04 09:53:25.000000000 +0100
@@ -17,29 +17,57 @@
 
 
 /* Pull in the ROM tables */
 #include "tms5220r.c"
 
+/*
+  Changes by R. Nabet
+   * added Speech ROM support
+   * modified code so that the beast only start speaking at the start of next frame, like the data
+     sheet says
+*/
+#define USE_OBSOLETE_HACK 0
+
+
+#ifndef TRUE
+	#define TRUE 1
+#endif
+#ifndef FALSE
+	#define FALSE 0
+#endif
+
 
 /* these contain data that describes the 128-bit data FIFO */
 #define FIFO_SIZE 16
 static UINT8 fifo[FIFO_SIZE];
 static UINT8 fifo_head;
 static UINT8 fifo_tail;
 static UINT8 fifo_count;
-static UINT8 bits_taken;
+static UINT8 fifo_bits_taken;
 
 
 /* these contain global status bits */
-static UINT8 speak_external;
+/*
+	R Nabet : speak_external is only set when a speak external command is going on.
+	tms5220_speaking is set whenever a speak or speak external command is going on.
+	Note that we really need to do anything in tms5220_process and play samples only when
+	tms5220_speaking is true.  Else, we can play nothing as well, which is a
+	speed-up...
+*/
+static UINT8 tms5220_speaking;	/* Speak or Speak External command in progress */
+static UINT8 speak_external;	/* Speak External command in progress */
+#if USE_OBSOLETE_HACK
 static UINT8 speak_delay_frames;
-static UINT8 talk_status;
-static UINT8 buffer_low;
-static UINT8 buffer_empty;
-static UINT8 irq_pin;
+#endif
+static UINT8 talk_status; 		/* tms5220 is really currently speaking */
+static UINT8 first_frame;		/* we have just started speaking, and we are to parse the first frame */
+static UINT8 last_frame;		/* we are doing the frame of sound */
+static UINT8 buffer_low;		/* FIFO has less than 8 bytes in it */
+static UINT8 buffer_empty;		/* FIFO is empty*/
+static UINT8 irq_pin;			/* state of the IRQ pin (output) */
 
-static void (*irq_func)(int state);
+static void (*irq_func)(int state); /* called when the state of the IRQ pin changes */
 
 
 /* these contain data describing the current and previous voice frames */
 static UINT16 old_energy;
 static UINT16 old_pitch;
@@ -57,12 +85,12 @@
 
 static UINT16 target_energy;
 static UINT16 target_pitch;
 static int target_k[10];
 
-static UINT8 interp_count;       /* number of interp periods (0-7) */
-static UINT8 sample_count;       /* sample number within interp (0-24) */
+static UINT8 interp_count;		/* number of interp periods (0-7) */
+static UINT8 sample_count;		/* sample number within interp (0-24) */
 static int pitch_count;
 
 static int u[11];
 static int x[10];
 
@@ -70,54 +98,78 @@
 
 
 /* Static function prototypes */
 static void process_command(void);
 static int extract_bits(int count);
-static int parse_frame(int removeit);
+static int parse_frame(int the_first_frame);
 static void check_buffer_low(void);
 static void set_interrupt_state(int state);
 
 
 #define DEBUG_5220	0
 
 
+
+/* R Nabet : These have been added to emulate speech Roms */
+static int (*read_callback)(int count) = NULL;
+static void (*load_address_callback)(int data) = NULL;
+static void (*read_and_branch_callback)(void) = NULL;
+static int schedule_dummy_read;			/* set after each load address, so that next read operation
+										  is preceded by a dummy read */
+
+static UINT8 data_register;				/* data register, used by read command */
+static int RDB_flag;					/* whether we should read data register or status register */
+
+
 /**********************************************************************************************
 
      tms5220_reset -- resets the TMS5220
 
 ***********************************************************************************************/
 
 void tms5220_reset(void)
 {
-    /* initialize the FIFO */
-    memset(fifo, 0, sizeof(fifo));
-    fifo_head = fifo_tail = fifo_count = bits_taken = 0;
-
-    /* initialize the chip state */
-    speak_external = speak_delay_frames = talk_status = irq_pin = 0;
+	/* initialize the FIFO */
+	/*memset(fifo, 0, sizeof(fifo));*/
+	fifo_head = fifo_tail = fifo_count = fifo_bits_taken = 0;
+
+	/* initialize the chip state */
+	/* Note that we do not actually clear IRQ on start-up : IRQ is even raised if buffer_empty or buffer_low are 0 */
+	tms5220_speaking = speak_external = talk_status = first_frame = last_frame = irq_pin = 0;
+#if USE_OBSOLETE_HACK
+	speak_delay_frames = 0;
+#endif
+	if (irq_func) irq_func(0);
 	buffer_empty = buffer_low = 1;
 
-    /* initialize the energy/pitch/k states */
-    old_energy = new_energy = current_energy = target_energy = 0;
-    old_pitch = new_pitch = current_pitch = target_pitch = 0;
-    memset(old_k, 0, sizeof(old_k));
-    memset(new_k, 0, sizeof(new_k));
-    memset(current_k, 0, sizeof(current_k));
-    memset(target_k, 0, sizeof(target_k));
+	RDB_flag = FALSE;
+
+	/* initialize the energy/pitch/k states */
+	old_energy = new_energy = current_energy = target_energy = 0;
+	old_pitch = new_pitch = current_pitch = target_pitch = 0;
+	memset(old_k, 0, sizeof(old_k));
+	memset(new_k, 0, sizeof(new_k));
+	memset(current_k, 0, sizeof(current_k));
+	memset(target_k, 0, sizeof(target_k));
+
+	/* initialize the sample generators */
+	interp_count = sample_count = pitch_count = 0;
+	randbit = 0;
+	memset(u, 0, sizeof(u));
+	memset(x, 0, sizeof(x));
+
+	if (load_address_callback)
+		(*load_address_callback)(0);
 
-    /* initialize the sample generators */
-    interp_count = sample_count = pitch_count = 0;
-    randbit = 0;
-    memset(u, 0, sizeof(u));
-    memset(x, 0, sizeof(x));
+	schedule_dummy_read = TRUE;
 }
 
 
 
 /**********************************************************************************************
 
-     tms5220_reset -- reset the TMS5220
+     tms5220_set_irq -- sets the interrupt handler
 
 ***********************************************************************************************/
 
 void tms5220_set_irq(void (*func)(int))
 {
@@ -125,10 +177,46 @@
 }
 
 
 /**********************************************************************************************
 
+     tms5220_set_read -- sets the speech ROM read handler
+
+***********************************************************************************************/
+
+void tms5220_set_read(int (*func)(int))
+{
+	read_callback = func;
+}
+
+
+/**********************************************************************************************
+
+     tms5220_set_load_address -- sets the speech ROM load address handler
+
+***********************************************************************************************/
+
+void tms5220_set_load_address(void (*func)(int))
+{
+	load_address_callback = func;
+}
+
+
+/**********************************************************************************************
+
+     tms5220_set_read_and_branch -- sets the speech ROM read and branch handler
+
+***********************************************************************************************/
+
+void tms5220_set_read_and_branch(void (*func)(void))
+{
+	read_and_branch_callback = func;
+}
+
+
+/**********************************************************************************************
+
      tms5220_data_write -- handle a write to the TMS5220
 
 ***********************************************************************************************/
 
 void tms5220_data_write(int data)
@@ -151,16 +239,20 @@
         if (DEBUG_5220) logerror("Ran out of room in the FIFO!\n");
     }
 
     /* update the buffer low state */
     check_buffer_low();
+
+	if (! speak_external)
+		/* R Nabet : we parse commands at once.  It is necessary for such commands as read. */
+		process_command (/*data*/);
 }
 
 
 /**********************************************************************************************
 
-     tms5220_status_read -- read status from the TMS5220
+     tms5220_status_read -- read status or data from the TMS5220
 
 	  From the data sheet:
         bit 0 = TS - Talk Status is active (high) when the VSP is processing speech data.
                 Talk Status goes active at the initiation of a Speak command or after nine
                 bytes of data are loaded into the FIFO following a Speak External command. It
@@ -179,16 +271,25 @@
 
 ***********************************************************************************************/
 
 int tms5220_status_read(void)
 {
-    /* clear the interrupt pin */
-    set_interrupt_state(0);
+	if (RDB_flag)
+	{	/* if last command was read, return data register */
+		RDB_flag = FALSE;
+		return(data_register);
+	}
+	else
+	{	/* read status */
+
+		/* clear the interrupt pin */
+		set_interrupt_state(0);
 
-    if (DEBUG_5220) logerror("Status read: TS=%d BL=%d BE=%d\n", talk_status, buffer_low, buffer_empty);
+		if (DEBUG_5220) logerror("Status read: TS=%d BL=%d BE=%d\n", talk_status, buffer_low, buffer_empty);
 
-    return (talk_status << 7) | (buffer_low << 6) | (buffer_empty << 5);
+		return (talk_status << 7) | (buffer_low << 6) | (buffer_empty << 5);
+	}
 }
 
 
 
 /**********************************************************************************************
@@ -201,10 +302,50 @@
 {
     return (fifo_count < FIFO_SIZE-1);
 }
 
 
+/**********************************************************************************************
+
+     tms5220_ready_read -- returns the number of cycles until ready is asserted
+
+***********************************************************************************************/
+
+int tms5220_cycles_to_ready(void)
+{
+	int answer;
+
+
+	if (tms5220_ready_read())
+		answer = 0;
+	else
+	{
+		int val;
+
+		answer = 200-sample_count;
+
+		/* total number of bits available in current byte is (8 - fifo_bits_taken) */
+		/* if more than 4 are available, we need to check the energy */
+		if (fifo_bits_taken < 4)
+		{
+			/* read energy */
+			val = (fifo[fifo_head] >> fifo_bits_taken) & 0xf;
+			if (val == 0)
+				/* 0 -> silence frame: we will only read 4 bits, and we will
+				therefore need to read another frame before the FIFO is not
+				full any more */
+				answer += 200;
+			/* 15 -> stop frame, we will only read 4 bits, but the FIFO will
+			we cleared */
+			/* otherwise, we need to parse the repeat flag (1 bit) and the
+			pitch (6 bits), so everything will be OK. */
+		}
+	}
+
+	return answer;
+}
+
 
 /**********************************************************************************************
 
      tms5220_int_read -- returns the interrupt state of the TMS5220
 
@@ -229,29 +370,44 @@
     int i, interp_period;
 
 tryagain:
 
     /* if we're not speaking, parse commands */
-    while (!speak_external && fifo_count > 0)
-        process_command();
+	/*while (!speak_external && fifo_count > 0)
+		process_command();*/
 
     /* if we're empty and still not speaking, fill with nothingness */
-    if (!speak_external)
+	if ((!tms5220_speaking) && (!last_frame))
         goto empty;
 
     /* if we're to speak, but haven't started, wait for the 9th byte */
-    if (!talk_status)
+	if (!talk_status && speak_external)
     {
         if (fifo_count < 9)
            goto empty;
 
-        /* parse but don't remove the first frame, and set the status to 1 */
-        parse_frame(0);
         talk_status = 1;
-        buffer_empty = 0;
-    }
+		first_frame = 1;	/* will cause the first frame to be parsed */
+		buffer_empty = 0;
+	}
 
+#if 0
+	/* we are to speak, yet we fill with 0s until start of next frame */
+	if (first_frame)
+	{
+		while ((size > 0) && ((sample_count != 0) || (interp_count != 0)))
+		{
+			sample_count = (sample_count + 1) % 200;
+			interp_count = (interp_count + 1) % 25;
+			buffer[buf_count] = 0x00;	/* should be (-1 << 8) ??? (cf note in data sheet, p 10, table 4) */
+			buf_count++;
+			size--;
+		}
+	}
+#endif
+
+#if USE_OBSOLETE_HACK
     /* apply some delay before we actually consume data; Victory requires this */
     if (speak_delay_frames)
     {
     	if (size <= speak_delay_frames)
     	{
@@ -262,22 +418,24 @@
     	{
     		size -= speak_delay_frames;
     		speak_delay_frames = 0;
     	}
     }
+#endif
 
     /* loop until the buffer is full or we've stopped speaking */
-    while ((size > 0) && speak_external)
+	while ((size > 0) && talk_status)
     {
         int current_val;
 
         /* if we're ready for a new frame */
         if ((interp_count == 0) && (sample_count == 0))
         {
             /* Parse a new frame */
-            if (!parse_frame(1))
-                break;
+			if (!parse_frame(first_frame))
+				break;
+			first_frame = 0;
 
             /* Set old target as new start of frame */
             current_energy = old_energy;
             current_pitch = old_pitch;
             for (i = 0; i < 10; i++)
@@ -297,15 +455,23 @@
             else if (current_energy == (energytable[15] >> 6))
             {
                 /*printf("processing frame: stop frame\n");*/
                 current_energy = energytable[0] >> 6;
                 target_energy = current_energy;
-                speak_external = talk_status = 0;
-                interp_count = sample_count = pitch_count = 0;
-
-                /* generate an interrupt if necessary */
-                set_interrupt_state(1);
+				/*interp_count = sample_count =*/ pitch_count = 0;
+				last_frame = 0;
+				if (tms5220_speaking)
+					/* new speech command in progress */
+					first_frame = 1;
+				else
+				{
+					/* really stop speaking */
+					talk_status = 0;
+
+					/* generate an interrupt if necessary */
+					set_interrupt_state(1);
+				}
 
                 /* try to fetch commands again */
                 goto tryagain;
             }
             else
@@ -420,11 +586,13 @@
 
 empty:
 
     while (size > 0)
     {
-        buffer[buf_count] = 0x00;
+		sample_count = (sample_count + 1) % 200;
+		interp_count = (interp_count + 1) % 25;
+		buffer[buf_count] = 0x00;	/* should be (-1 << 8) ??? (cf note in data sheet, p 10, table 4) */
         buf_count++;
         size--;
     }
 }
 
@@ -439,36 +607,97 @@
 static void process_command(void)
 {
     unsigned char cmd;
 
     /* if there are stray bits, ignore them */
-    if (bits_taken)
-    {
-        bits_taken = 0;
+	if (fifo_bits_taken)
+	{
+		fifo_bits_taken = 0;
         fifo_count--;
         fifo_head = (fifo_head + 1) % FIFO_SIZE;
     }
 
     /* grab a full byte from the FIFO */
     if (fifo_count > 0)
     {
-        cmd = fifo[fifo_head] & 0x70;
-        fifo_count--;
-        fifo_head = (fifo_head + 1) % FIFO_SIZE;
+		cmd = fifo[fifo_head];
+		fifo_count--;
+		fifo_head = (fifo_head + 1) % FIFO_SIZE;
 
-        /* only real command we handle now is speak external */
-        if (cmd == 0x60)
-        {
-            speak_external = 1;
+		/* parse the command */
+		switch (cmd & 0x70)
+		{
+		case 0x10 : /* read byte */
+			if (schedule_dummy_read)
+			{
+				schedule_dummy_read = FALSE;
+				if (read_callback)
+					(*read_callback)(1);
+			}
+			if (read_callback)
+				data_register = (*read_callback)(8);	/* read one byte from speech ROM... */
+			RDB_flag = TRUE;
+			break;
+
+		case 0x30 : /* read and branch */
+			if (DEBUG_5220) logerror("read and branch command received\n");
+			RDB_flag = FALSE;
+			if (read_and_branch_callback)
+				(*read_and_branch_callback)();
+			break;
+
+		case 0x40 : /* load address */
+			/* tms5220 data sheet says that if we load only one 4-bit nibble, it won't work.
+			  This code does not care about this. */
+			if (load_address_callback)
+				(*load_address_callback)(cmd & 0x0f);
+			schedule_dummy_read = TRUE;
+			break;
+
+		case 0x50 : /* speak */
+			if (schedule_dummy_read)
+			{
+				schedule_dummy_read = FALSE;
+				if (read_callback)
+					(*read_callback)(1);
+			}
+			tms5220_speaking = 1;
+			speak_external = 0;
+			if (! last_frame)
+			{
+				first_frame = 1;
+			}
+			talk_status = 1;  /* start immediately */
+			break;
+
+		case 0x60 : /* speak external */
+			tms5220_speaking = speak_external = 1;
+#if USE_OBSOLETE_HACK
             speak_delay_frames = 10;
+#endif
+
+			RDB_flag = FALSE;
 
             /* according to the datasheet, this will cause an interrupt due to a BE condition */
             if (!buffer_empty)
             {
                 buffer_empty = 1;
                 set_interrupt_state(1);
             }
+
+			talk_status = 0;	/* wait to have 8 bytes in buffer before starting */
+			break;
+
+		case 0x70 : /* reset */
+			if (schedule_dummy_read)
+			{
+				schedule_dummy_read = FALSE;
+				if (read_callback)
+					(*read_callback)(1);
+			}
+			tms5220_reset();
+			break;
         }
     }
 
     /* update the buffer low state */
     check_buffer_low();
@@ -484,21 +713,32 @@
 
 static int extract_bits(int count)
 {
     int val = 0;
 
-    while (count--)
-    {
-        val = (val << 1) | ((fifo[fifo_head] >> bits_taken) & 1);
-        bits_taken++;
-        if (bits_taken >= 8)
-        {
-            fifo_count--;
-            fifo_head = (fifo_head + 1) % FIFO_SIZE;
-            bits_taken = 0;
-        }
+	if (speak_external)
+	{
+		/* extract from FIFO */
+    	while (count--)
+    	{
+        	val = (val << 1) | ((fifo[fifo_head] >> fifo_bits_taken) & 1);
+        	fifo_bits_taken++;
+        	if (fifo_bits_taken >= 8)
+        	{
+        	    fifo_count--;
+        	    fifo_head = (fifo_head + 1) % FIFO_SIZE;
+        	    fifo_bits_taken = 0;
+        	}
+    	}
     }
+	else
+	{
+		/* extract from speech ROM */
+		if (read_callback)
+			val = (* read_callback)(count);
+	}
+
     return val;
 }
 
 
 
@@ -506,46 +746,49 @@
 
      parse_frame -- parse a new frame's worth of data; returns 0 if not enough bits in buffer
 
 ***********************************************************************************************/
 
-static int parse_frame(int removeit)
+static int parse_frame(int the_first_frame)
 {
-    int old_head, old_taken, old_count;
-    int bits, indx, i, rep_flag;
+	int bits = 0;	/* number of bits in FIFO (speak external only) */
+	int indx, i, rep_flag;
 
+	if (! the_first_frame)
+	{
     /* remember previous frame */
     old_energy = new_energy;
     old_pitch = new_pitch;
     for (i = 0; i < 10; i++)
         old_k[i] = new_k[i];
+	}
 
     /* clear out the new frame */
     new_energy = 0;
     new_pitch = 0;
     for (i = 0; i < 10; i++)
         new_k[i] = 0;
 
     /* if the previous frame was a stop frame, don't do anything */
-    if (old_energy == (energytable[15] >> 6))
+	if ((! the_first_frame) && (old_energy == (energytable[15] >> 6)))
+		/*return 1;*/
 	{
 		buffer_empty = 1;
 		return 1;
 	}
 
-    /* remember the original FIFO counts, in case we don't have enough bits */
-    old_count = fifo_count;
-    old_head = fifo_head;
-    old_taken = bits_taken;
-
-    /* count the total number of bits available */
-    bits = fifo_count * 8 - bits_taken;
+	if (speak_external)
+    	/* count the total number of bits available */
+		bits = fifo_count * 8 - fifo_bits_taken;
 
     /* attempt to extract the energy index */
+	if (speak_external)
+	{
     bits -= 4;
     if (bits < 0)
         goto ranout;
+	}
     indx = extract_bits(4);
     new_energy = energytable[indx] >> 6;
 
 	/* if the index is 0 or 15, we're done */
 	if (indx == 0 || indx == 15)
@@ -553,26 +796,33 @@
 		if (DEBUG_5220) logerror("  (4-bit energy=%d frame)\n",new_energy);
 
 		/* clear fifo if stop frame encountered */
 		if (indx == 15)
 		{
-			fifo_head = fifo_tail = fifo_count = bits_taken = 0;
-			removeit = 1;
+			fifo_head = fifo_tail = fifo_count = fifo_bits_taken = 0;
+			speak_external = tms5220_speaking = 0;
+			last_frame = 1;
 		}
 		goto done;
 	}
 
     /* attempt to extract the repeat flag */
+	if (speak_external)
+	{
     bits -= 1;
     if (bits < 0)
         goto ranout;
+	}
     rep_flag = extract_bits(1);
 
     /* attempt to extract the pitch */
+	if (speak_external)
+	{
     bits -= 6;
     if (bits < 0)
         goto ranout;
+	}
     indx = extract_bits(6);
     new_pitch = pitchtable[indx] / 256;
 
     /* if this is a repeat frame, just copy the k's */
     if (rep_flag)
@@ -586,26 +836,32 @@
 
     /* if the pitch index was zero, we need 4 k's */
     if (indx == 0)
     {
         /* attempt to extract 4 K's */
+		if (speak_external)
+		{
         bits -= 18;
         if (bits < 0)
             goto ranout;
+		}
         new_k[0] = k1table[extract_bits(5)];
         new_k[1] = k2table[extract_bits(5)];
         new_k[2] = k3table[extract_bits(4)];
         new_k[3] = k4table[extract_bits(4)];
 
         if (DEBUG_5220) logerror("  (29-bit energy=%d pitch=%d rep=%d 4K frame)\n", new_energy, new_pitch, rep_flag);
         goto done;
     }
 
     /* else we need 10 K's */
+	if (speak_external)
+	{
     bits -= 39;
     if (bits < 0)
         goto ranout;
+	}
     new_k[0] = k1table[extract_bits(5)];
     new_k[1] = k2table[extract_bits(5)];
     new_k[2] = k3table[extract_bits(4)];
     new_k[3] = k4table[extract_bits(4)];
     new_k[4] = k5table[extract_bits(4)];
@@ -616,19 +872,25 @@
     new_k[9] = k10table[extract_bits(3)];
 
     if (DEBUG_5220) logerror("  (50-bit energy=%d pitch=%d rep=%d 10K frame)\n", new_energy, new_pitch, rep_flag);
 
 done:
+	if (DEBUG_5220)
+	{
+		if (speak_external)
+			logerror("Parsed a frame successfully in FIFO - %d bits remaining\n", bits);
+		else
+			logerror("Parsed a frame successfully in ROM\n");
+	}
 
-    if (DEBUG_5220) logerror("Parsed a frame successfully - %d bits remaining\n", bits);
-
-    /* if we're not to remove this one, restore the FIFO */
-    if (!removeit)
-    {
-        fifo_count = old_count;
-        fifo_head = old_head;
-        bits_taken = old_taken;
+	if (the_first_frame)
+	{
+		/* if this is the first frame, no previous frame to take as a starting point */
+		old_energy = new_energy;
+		old_pitch = new_pitch;
+		for (i = 0; i < 10; i++)
+			old_k[i] = new_k[i];
     }
 
     /* update the buffer_low status */
     check_buffer_low();
     return 1;
@@ -637,13 +899,15 @@
 
     if (DEBUG_5220) logerror("Ran out of bits on a parse!\n");
 
     /* this is an error condition; mark the buffer empty and turn off speaking */
     buffer_empty = 1;
-    talk_status = speak_external = 0;
+	talk_status = speak_external = tms5220_speaking = the_first_frame = last_frame = 0;
     fifo_count = fifo_head = fifo_tail = 0;
 
+	RDB_flag = FALSE;
+
     /* generate an interrupt if necessary */
     set_interrupt_state(1);
     return 0;
 }
 
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/sound/tms5220.h srcmess/sound/tms5220.h
--- srcmess.ori/sound/tms5220.h	2000-02-15 14:50:42.000000000 +0100
+++ srcmess/sound/tms5220.h	2003-01-20 16:20:30.000000000 +0100
@@ -5,11 +5,17 @@
 void tms5220_set_irq(void (*func)(int));
 
 void tms5220_data_write(int data);
 int tms5220_status_read(void);
 int tms5220_ready_read(void);
+int tms5220_cycles_to_ready(void);
 int tms5220_int_read(void);
 
 void tms5220_process(INT16 *buffer, unsigned int size);
 
+/* three variables added by R Nabet */
+void tms5220_set_read(int (*func)(int));
+void tms5220_set_load_address(void (*func)(int));
+void tms5220_set_read_and_branch(void (*func)(void));
+
 #endif
 
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/sound/tms5220.txt srcmess/sound/tms5220.txt
--- srcmess.ori/sound/tms5220.txt	1998-07-12 11:01:36.000000000 +0200
+++ srcmess/sound/tms5220.txt	2002-05-08 15:51:50.000000000 +0200
@@ -1,9 +1,10 @@
 *****************************
 
     TI TMS5220 Emulator
     (c) Frank Palazzolo
+    Updated by Raphael Nabet
 
 *****************************
 
 The TI TMS5220 Speech chip uses Linear-Predictive decoding scheme to produce
 speech from very compact data.  This scheme is very similar to the U.S.
@@ -27,11 +28,11 @@
 
 The TI speech chip contains a 128-bit parallel-in, serial-out FIFO, a
 10-pole digital lattice filter which models the vocal tract, and a D/A
 converter.  It was originally design to operate either with a microcomputer
 interface, or with a serial speech ROM.  The Speech ROM functionality is
-not emulated as no arcade games require it.
+now emulated, although no arcade games require it currently.
 
 The input data is writen a byte at a time into the chip, and it is
 decoded bitwise into variable length frames.
 
 Possible Frame Types are as follows:
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/ui_text.c srcmess/ui_text.c
--- srcmess.ori/ui_text.c	2002-11-20 21:54:00.000000000 +0100
+++ srcmess/ui_text.c	2003-02-12 02:11:49.000000000 +0100
@@ -54,10 +54,21 @@
 	"Gamma",
 	"Vector Flicker",
 	"Vector Intensity",
 	"Overclock",
 	"ALL CPUS",
+	"PALETTE",
+	"CLUT",
+	"GFXSET",
+	"COLOR",
+	"CODE",
+	"TILEMAP",
+	"V",
+	"H",
+	"pixel aspect ratio",
+	"colors",
+	"sound cmd",
 #ifndef MESS
 	"History not available",
 #else
 	"System Info not available",
 #endif
@@ -91,10 +102,17 @@
 	"There are working clones of this game. They are:",
 	"Type OK to continue",
 #ifdef MESS
 	"The emulated system is a computer: ",
 	"The keyboard emulation may not be 100% accurate.",
+	"Keyboard Emulation Status",
+	"-------------------------",
+	"Mode: PARTIAL Emulation",
+	"Mode: FULL Emulation",
+	"UI:   Enabled",
+	"UI:   Disabled",
+	"**Use ScrLock to toggle**",
 #endif
 
 	/* main menu */
 	"Input (general)",
 	"Dip Switches",
@@ -114,10 +132,38 @@
 	"Reset Machine",
 	"Return to Machine",
 	"Image Information",
 	"File Manager",
 	"Tape Control",
+
+	"recording",
+	"playing",
+	"(recording)",
+	"(playing)",
+	"stopped",
+	"Pause/Stop",
+	"Record",
+	"Play",
+	"Rewind",
+	"Fast Forward",
+	"Mount",
+	"Unmount",
+	"[empty slot]",
+	"Quit Fileselector",
+	"File Specification",	/* IMPORTANT: be careful to ensure that the following */
+	"Cartridge",		/* device list matches the order found in device.h    */
+	"Floppy Disk",		/* and is ALWAYS placed after "File Specification"    */
+	"Hard Disk",
+	"Cylinder",
+	"Cassette",
+	"Punched Card",
+	"Punched Tape",
+	"Printer",
+	"Serial Port",
+	"Parallel Port",
+	"Snapshot",
+	"Quickload",
 #endif
 	"Cheat",
 	"Memory Card",
 
 	/* input */
@@ -138,11 +184,11 @@
 	"Failed To Load Memory Card!",
 	"Load OK!",
 	"Memory Card Ejected!",
 	"Memory Card Created OK!",
 	"Failed To Create Memory Card!",
-	"(It already exists ?)",
+	"(It already exists?)",
 	"DAMN!! Internal Error!",
 
 	/* cheats */
 	"Enable/Disable a Cheat",
 	"Add/Edit a Cheat",
@@ -180,10 +226,18 @@
 
 	"Hex",
 	"Decimal",
 	"Binary",
 
+	/* save state */
+	"Select position to save to",
+	"Select position to load from",
+	"Save to position",
+	"Load from position",
+	"Save cancelled",
+	"Load cancelled",
+
 	/* searching */
 	"Lives (or another value)",
 	"Timers (+/- some value)",
 	"Energy (greater or less)",
 	"Status (bits or flags)",
@@ -202,10 +256,14 @@
 	"Restoration successful",
 	"Select a value",
 	"All values saved",
 	"One match found - added to list",
 
+	/* addendum */
+	"Center",
+	"Video",
+
 	NULL
 };
 
 int uistring_init (mame_file *langfile)
 {
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/ui_text.h srcmess/ui_text.h
--- srcmess.ori/ui_text.h	2002-11-21 06:42:00.000000000 +0100
+++ srcmess/ui_text.h	2003-02-12 02:11:49.000000000 +0100
@@ -39,10 +39,21 @@
 	UI_gamma,
 	UI_vectorflicker,
 	UI_vectorintensity,
 	UI_overclock,
 	UI_allcpus,
+	UI_palette,
+	UI_clut,
+	UI_gfxset,
+	UI_color,
+	UI_code_up,
+	UI_tilemap,
+	UI_orient_vert,
+	UI_orient_horz,
+	UI_pix_asp_rat,
+	UI_colors,
+	UI_sound_cmd,
 	UI_historymissing,
 
 	/* special characters */
 	UI_leftarrow,
 	UI_rightarrow,
@@ -64,10 +75,17 @@
 	UI_workingclones,
 	UI_typeok,
 #ifdef MESS
 	UI_comp1,
 	UI_comp2,
+	UI_keyb1,
+	UI_keyb2,
+	UI_keyb3,
+	UI_keyb4,
+	UI_keyb5,
+	UI_keyb6,
+	UI_keyb7,
 #endif
 
 	/* main menu */
 	UI_inputgeneral,
 	UI_dipswitches,
@@ -81,10 +99,37 @@
 	UI_returntogame,
 #ifdef MESS
 	UI_imageinfo,
 	UI_filemanager,
 	UI_tapecontrol,
+	UI_recording,
+	UI_playing,
+	UI_recording_inhibited,
+	UI_playing_inhibited,
+	UI_stopped,
+	UI_pauseorstop,
+	UI_record,
+	UI_play,
+	UI_rewind,
+	UI_fastforward,
+	UI_mount,
+	UI_unmount,
+	UI_emptyslot,
+	UI_quitfileselector,
+	UI_filespecification,	/* IMPORTANT: be careful to ensure that the following */
+	UI_cartridge,		/* device list matches the order found in device.h    */
+	UI_floppydisk,		/* and is ALWAYS placed after UI_filespecification    */
+	UI_harddisk,
+	UI_cylinder,
+	UI_cassette,
+	UI_punchcard,
+	UI_punchtape,
+	UI_printer,
+	UI_serial,
+	UI_parallel,
+	UI_snapshot,
+	UI_quickload,
 #endif
 	UI_cheat,
 	UI_memorycard,
 
 	/* input stuff */
@@ -147,10 +192,18 @@
 
 	UI_hex,
 	UI_decimal,
 	UI_binary,
 
+	/* save state stuff */
+	UI_select_save,
+	UI_select_load,
+	UI_save_to,
+	UI_load_from,
+	UI_save_canc,
+	UI_load_canc,
+
 	/* search stuff */
 	UI_search_lives,
 	UI_search_timers,
 	UI_search_energy,
 	UI_search_status,
@@ -169,10 +222,14 @@
 	UI_search_OK,
 	UI_search_select_value,
 	UI_search_all_values_saved,
 	UI_search_one_match_found_added,
 
+	/* addendum */
+	UI_center,
+	UI_osdmenu,
+
 	UI_last_entry
 };
 
 struct lang_struct
 {
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/usrintrf.c srcmess/usrintrf.c
--- srcmess.ori/usrintrf.c	2003-01-24 14:31:14.000000000 +0100
+++ srcmess/usrintrf.c	2003-02-12 02:11:49.000000000 +0100
@@ -77,12 +77,12 @@
 static int setup_selected;
 static int osd_selected;
 static int jukebox_selected;
 static int single_step;
 
-static int showfps;
-static int showfpstemp;
+int showfps;
+int showfpstemp;
 
 UINT8 ui_dirty;
 
 
 
@@ -843,12 +843,16 @@
 	while (items[i])
 	{
 		len = 3 + strlen(items[i]);
 		if (subitems && subitems[i])
 			len += 2 + strlen(subitems[i]);
-		if (len > maxlen && len <= highlen)
-			maxlen = len;
+		if (len > maxlen) {
+			if (len <= highlen)
+				maxlen = len;
+			else
+				maxlen = highlen;
+		}
 		i++;
 	}
 	count = i;
 
 	visible = uirotheight / (3 * uirotcharheight / 2) - 1;
@@ -916,15 +920,27 @@
 				dt[curr_dt].y = topoffs + (3*i+1)*uirotcharheight/2;
 				curr_dt++;
 			}
 			else
 			{
-				dt[curr_dt].text = items[item];
-				dt[curr_dt].color = UI_COLOR_NORMAL;
-				dt[curr_dt].x = (uirotwidth - uirotcharwidth * strlen(items[item])) / 2;
-				dt[curr_dt].y = topoffs + (3*i+1)*uirotcharheight/2;
-				curr_dt++;
+				unsigned y = topoffs + (3*i+1)*uirotcharheight/2;
+				int color = (flag && flag[item]) ? UI_COLOR_INVERSE : UI_COLOR_NORMAL;
+				len = strlen(items[item]);
+				if (len > maxlen - 3) {
+					unsigned x;
+					const char* dot = "...";
+					len = maxlen - 3;
+					x = (uirotwidth - uirotcharwidth * len) / 2;
+					ui_text_ex(bitmap,items[item],items[item] + len - 3,x,y,color);
+					ui_text_ex(bitmap,dot,dot+3,x + uirotcharwidth * (len - 3),y,color);
+				} else {
+					dt[curr_dt].text = items[item];
+					dt[curr_dt].color = color;
+					dt[curr_dt].x = (uirotwidth - uirotcharwidth * len) / 2;
+					dt[curr_dt].y = y;
+					curr_dt++;
+				}
 			}
 		}
 	}
 
 	i = selected - topitem;
@@ -2041,13 +2057,13 @@
 		in++;
 	}
 
 	if (total == 0) return 0;
 
-	/* Each analog control has 3 entries - key & joy delta, reverse, sensitivity */
+	/* Each analog control has 4 entries - key & joy delta, reverse, sensitivity */
 
-#define ENTRIES 3
+#define ENTRIES 4
 
 	total2 = total * ENTRIES;
 
 	menu_item[total2] = ui_getstring (UI_returntomain);
 	menu_item[total2 + 1] = 0;	/* terminate array */
@@ -2060,15 +2076,17 @@
 		{
 			char label[30][40];
 			char setting[30][40];
 			int sensitivity,delta;
 			int reverse;
+			int center;
 
 			strcpy (label[i], input_port_name(entry[i/ENTRIES]));
 			sensitivity = IP_GET_SENSITIVITY(entry[i/ENTRIES]);
 			delta = IP_GET_DELTA(entry[i/ENTRIES]);
 			reverse = (entry[i/ENTRIES]->type & IPF_REVERSE);
+			center = (entry[i/ENTRIES]->type & IPF_CENTER);
 
 			strcat (label[i], " ");
 			switch (i%ENTRIES)
 			{
 				case 0:
@@ -2087,10 +2105,18 @@
 				case 2:
 					strcat (label[i], ui_getstring (UI_sensitivity));
 					sprintf(setting[i],"%3d%%",sensitivity);
 					if (i == sel) arrowize = 3;
 					break;
+				case 3:
+					strcat (label[i], ui_getstring (UI_center));
+					if (center)
+						sprintf(setting[i],ui_getstring (UI_on));
+					else
+						sprintf(setting[i],ui_getstring (UI_off));
+					if (i == sel) arrowize = 3;
+					break;
 			}
 
 			menu_item[i] = label[i];
 			menu_subitem[i] = setting[i];
 
@@ -2138,10 +2164,21 @@
 
 				val --;
 				if (val < 1) val = 1;
 				IP_SET_SENSITIVITY(entry[sel/ENTRIES],val);
 			}
+			else if ((sel % ENTRIES) == 3)
+			/* center */
+			{
+				int center = entry[sel/ENTRIES]->type & IPF_CENTER;
+				if (center)
+					center=0;
+				else
+					center=IPF_CENTER;
+				entry[sel/ENTRIES]->type &= ~IPF_CENTER;
+				entry[sel/ENTRIES]->type |= center;
+			}
 		}
 	}
 
 	if (input_ui_pressed_repeat(IPT_UI_RIGHT,8))
 	{
@@ -2174,10 +2211,21 @@
 
 				val ++;
 				if (val > 255) val = 255;
 				IP_SET_SENSITIVITY(entry[sel/ENTRIES],val);
 			}
+			else if ((sel % ENTRIES) == 3)
+			/* center */
+			{
+				int center = entry[sel/ENTRIES]->type & IPF_CENTER;
+				if (center)
+					center=0;
+				else
+					center=IPF_CENTER;
+				entry[sel/ENTRIES]->type &= ~IPF_CENTER;
+				entry[sel/ENTRIES]->type |= center;
+			}
 		}
 	}
 
 	if (input_ui_pressed(IPT_UI_SELECT))
 	{
@@ -2823,11 +2871,15 @@
 		buf = malloc (200*1024);
 		#endif
 		if (buf)
 		{
 			/* try to load entry */
+			#ifndef MESS
+			if (load_driver_history (Machine->gamedrv, buf, 8192) == 0)
+			#else
 			if (load_driver_history (Machine->gamedrv, buf, 200*1024) == 0)
+			#endif
 			{
 				scroll = 0;
 				wordwrap_text_buffer (buf, maxcols);
 				strcat(buf,"\n\t");
 				strcat(buf,ui_getstring (UI_lefthilight));
@@ -3030,15 +3082,15 @@
 
 
 #ifndef MESS
 enum { UI_SWITCH = 0,UI_DEFCODE,UI_CODE,UI_ANALOG,UI_CALIBRATE,
 		UI_STATS,UI_GAMEINFO, UI_HISTORY,
-		UI_CHEAT,UI_RESET,UI_MEMCARD,UI_EXIT };
+		UI_CHEAT,UI_RESET,UI_MEMCARD,UI_EXIT,UI_OSD };
 #else
 enum { UI_SWITCH = 0,UI_DEFCODE,UI_CODE,UI_ANALOG,UI_CALIBRATE,
 		UI_GAMEINFO, UI_IMAGEINFO,UI_FILEMANAGER,UI_TAPECONTROL,
-		UI_HISTORY,UI_CHEAT,UI_RESET,UI_MEMCARD,UI_EXIT };
+		UI_HISTORY,UI_CHEAT,UI_RESET,UI_MEMCARD,UI_EXIT,UI_OSD };
 #endif
 
 
 #define MAX_SETUPMENU_ITEMS 20
 static const char *menu_item[MAX_SETUPMENU_ITEMS];
@@ -3087,11 +3139,13 @@
 	menu_item[menu_total] = ui_getstring (UI_gameinfo); menu_action[menu_total++] = UI_GAMEINFO;
 	menu_item[menu_total] = ui_getstring (UI_history); menu_action[menu_total++] = UI_HISTORY;
 #else
 	menu_item[menu_total] = ui_getstring (UI_imageinfo); menu_action[menu_total++] = UI_IMAGEINFO;
 	menu_item[menu_total] = ui_getstring (UI_filemanager); menu_action[menu_total++] = UI_FILEMANAGER;
+#if HAS_WAVE
 	menu_item[menu_total] = ui_getstring (UI_tapecontrol); menu_action[menu_total++] = UI_TAPECONTROL;
+#endif
 	menu_item[menu_total] = ui_getstring (UI_history); menu_action[menu_total++] = UI_HISTORY;
 #endif
 
 	if (options.cheat)
 	{
@@ -3111,10 +3165,11 @@
 #endif
 #endif
 #endif
 #endif
 
+	menu_item[menu_total] = ui_getstring (UI_osdmenu); menu_action[menu_total++] = UI_OSD;
 	menu_item[menu_total] = ui_getstring (UI_resetgame); menu_action[menu_total++] = UI_RESET;
 	menu_item[menu_total] = ui_getstring (UI_returntogame); menu_action[menu_total++] = UI_EXIT;
 	menu_item[menu_total] = 0; /* terminate array */
 }
 
@@ -3161,20 +3216,25 @@
 				res = displayimageinfo(bitmap, sel >> SEL_BITS);
 				break;
 			case UI_FILEMANAGER:
 				res = filemanager(bitmap, sel >> SEL_BITS);
 				break;
+#if HAS_WAVE
 			case UI_TAPECONTROL:
 				res = tapecontrol(bitmap, sel >> SEL_BITS);
 				break;
+#endif /* HAS_WAVE */
 #endif
 			case UI_HISTORY:
 				res = displayhistory(bitmap, sel >> SEL_BITS);
 				break;
 			case UI_CHEAT:
 				res = cheat_menu(bitmap, sel >> SEL_BITS);
 				break;
+			case UI_OSD :
+				res = osd_menu(bitmap, sel >> SEL_BITS);
+				break;
 #ifndef MESS
 #ifndef TINY_COMPILE
 #ifndef CPSMAME
 #ifndef MMSND
 			case UI_MEMCARD:
@@ -3225,10 +3285,11 @@
 			case UI_TAPECONTROL:
 			#endif
 			case UI_HISTORY:
 			case UI_CHEAT:
 			case UI_MEMCARD:
+			case UI_OSD :
 				sel |= 1 << SEL_BITS;
 				schedule_full_refresh();
 				break;
 
 			case UI_RESET:
@@ -3666,10 +3727,63 @@
 	vsprintf(messagetext,text,arg);
 	va_end(arg);
 	messagecounter = seconds * Machine->drv->frames_per_second;
 }
 
+int on_exit_menu(struct mame_bitmap* bitmap, int selected)
+{
+	const char * exit_menu_item[8];
+	char flag[8];
+
+	int sel;
+	int total;
+
+	sel = selected - 1;
+
+	total = 0;
+
+	exit_menu_item[total] = "Continue";
+	flag[total] = 0;
+	++total;
+
+	exit_menu_item[total] = "Exit";
+	flag[total] = 0;
+	++total;
+
+	exit_menu_item[total] = 0;
+	flag[total] = 0;
+
+	ui_displaymenu(bitmap,exit_menu_item,0,flag,sel,0);
+
+	if (input_ui_pressed_repeat(IPT_UI_DOWN,8)) {
+		sel = (sel + 1) % total;
+	}
+
+	if (input_ui_pressed_repeat(IPT_UI_UP,8)) {
+		sel = (sel + total - 1) % total;
+	}
+
+	if (input_ui_pressed(IPT_UI_SELECT)) {
+		if (sel == 1)
+			sel = -2;
+		if (sel == 0)
+			sel = -1;
+	}
+
+	if (input_ui_pressed(IPT_UI_CANCEL)) {
+		sel = -1;
+	}
+
+	if (sel == -1 || sel == -2)
+	{
+		/* tell updatescreen() to clean after us */
+		schedule_full_refresh();
+	}
+
+	return sel + 1;
+}
+
 void do_loadsave(struct mame_bitmap *bitmap, int request_loadsave)
 {
 	int file = 0;
 
 	mame_pause(1);
@@ -3727,11 +3841,11 @@
 	if (!showfps)
 		showfpstemp = (int)(seconds * Machine->drv->frames_per_second);
 }
 
 
-static void display_fps(struct mame_bitmap *bitmap)
+void display_fps(struct mame_bitmap *bitmap)
 {
 	const char *text, *end;
 	char textbuf[256];
 	int done = 0;
 	int y = 0;
@@ -3773,91 +3887,54 @@
 			schedule_full_refresh();
 	}
 }
 
 
+int show_profiler;
 
 int handle_user_interface(struct mame_bitmap *bitmap)
 {
-	static int show_profiler;
-
 #ifdef MESS
-if (Machine->gamedrv->flags & GAME_COMPUTER)
-{
-	static int ui_active = 0, ui_toggle_key = 0;
-	static int ui_display_count = 4 * 60;
-
-	if( input_ui_pressed(IPT_UI_TOGGLE_UI) )
-	{
-		if( !ui_toggle_key )
-		{
-			ui_toggle_key = 1;
-			ui_active = !ui_active;
-			ui_display_count = 4 * 60;
-			schedule_full_refresh();
-		 }
-	}
-	else
-	{
-		ui_toggle_key = 0;
-	}
-
-	if( ui_active )
-	{
-		if( ui_display_count > 0 )
-		{
-			char text[] = "KBD: UI  (ScrLock)";
-			int x, x0 = uirotwidth - sizeof(text) * Machine->uifont->width - 2;
-			int y0 = uirotbounds.min_y + uirotheight - Machine->uifont->height - 2;
-			for( x = 0; text[x]; x++ )
-			{
-				artwork_mark_ui_dirty(x0 + x * Machine->uifont->width, y0,
-						x0 + x * Machine->uifont->width + uirotcharwidth - 1, y0 + uirotcharheight - 1);
-				drawgfx(bitmap,
-					Machine->uifont,text[x],0,0,0,
-					x0+x*Machine->uifont->width,
-					y0,0,TRANSPARENCY_NONE,0);
-			}
-			if( --ui_display_count == 0 )
-				schedule_full_refresh();
-		}
-	}
-	else
-	{
-		if( ui_display_count > 0 )
-		{
-			char text[] = "KBD: EMU (ScrLock)";
-			int x, x0 = uirotwidth - sizeof(text) * Machine->uifont->width - 2;
-			int y0 = uirotbounds.min_y + uirotheight - Machine->uifont->height - 2;
-			for( x = 0; text[x]; x++ )
-			{
-				artwork_mark_ui_dirty(x0 + x * Machine->uifont->width, y0,
-						x0 + x * Machine->uifont->width + uirotcharwidth - 1, y0 + uirotcharheight - 1);
-				drawgfx(bitmap,
-					Machine->uifont,text[x],0,0,0,
-					x0+x*Machine->uifont->width,
-					y0,0,TRANSPARENCY_NONE,0);
-			}
-			if( --ui_display_count == 0 )
-				schedule_full_refresh();
-		}
-		return 0;
-	}
-}
+	extern int mess_pause_for_ui;
 #endif
 
 	/* if the user pressed F12, save the screen to a file */
 	if (input_ui_pressed(IPT_UI_SNAPSHOT))
 		artwork_save_snapshot(bitmap);
 
+	/* save the sound to a file */
+	if (input_ui_pressed(IPT_UI_RECORD_START))
+		osd_record_start();
+	if (input_ui_pressed(IPT_UI_RECORD_STOP))
+		osd_record_stop();
+
 	/* This call is for the cheat, it must be called once a frame */
 	if (options.cheat) DoCheat(bitmap);
 
 	/* if the user pressed ESC, stop the emulation */
 	/* but don't quit if the setup menu is on screen */
-	if (setup_selected == 0 && input_ui_pressed(IPT_UI_CANCEL))
-		return 1;
+	if (setup_selected == 0) {
+		int res = osd_input_exit_filter(input_ui_pressed(IPT_UI_CANCEL));
+		if (res > 1)
+			return 1;
+		if (res != 0) {
+			osd_sound_enable(0);
+			osd_pause(1);
+
+			res = 1;
+			while (res > 0) {
+				res = on_exit_menu(bitmap,res);
+				update_video_and_audio();
+			}
+
+			osd_pause(0);
+			osd_sound_enable(1);
+
+			if (res < 0)
+				return 1;
+		}
+	}
 
 	if (setup_selected == 0 && input_ui_pressed(IPT_UI_CONFIGURE))
 	{
 		setup_selected = -1;
 		if (osd_selected != 0)
@@ -3935,12 +4012,20 @@
 		do_loadsave(bitmap, LOADSAVE_SAVE);
 
 	if (input_ui_pressed(IPT_UI_LOAD_STATE))
 		do_loadsave(bitmap, LOADSAVE_LOAD);
 
+#ifndef MESS
 	if (single_step || input_ui_pressed(IPT_UI_PAUSE)) /* pause the game */
 	{
+#else
+	if (setup_selected)
+		mess_pause_for_ui = 1;
+
+	if (single_step || input_ui_pressed(IPT_UI_PAUSE) || mess_pause_for_ui) /* pause the game */
+	{
+#endif
 /*		osd_selected = 0;	   disable on screen display, since we are going   */
 							/* to change parameters affected by it */
 
 		if (single_step == 0)
 			mame_pause(1);
@@ -3960,10 +4045,14 @@
 			profiler_mark(PROFILER_END);
 
 			if (input_ui_pressed(IPT_UI_SNAPSHOT))
 				artwork_save_snapshot(bitmap);
 
+			if (input_ui_pressed(IPT_UI_RECORD_START))
+				osd_record_start();
+			if (input_ui_pressed(IPT_UI_RECORD_STOP))
+				osd_record_stop();
 
 			if (input_ui_pressed(IPT_UI_SAVE_STATE))
 				do_loadsave(bitmap, LOADSAVE_SAVE);
 
 			if (input_ui_pressed(IPT_UI_LOAD_STATE))
@@ -3972,11 +4061,11 @@
 			/* if the user pressed F4, show the character set */
 			if (input_ui_pressed(IPT_UI_SHOW_GFX))
 				showcharset(bitmap);
 
 			if (setup_selected == 0 && input_ui_pressed(IPT_UI_CANCEL))
-				return 1;
+				break;
 
 			if (setup_selected == 0 && input_ui_pressed(IPT_UI_CONFIGURE))
 			{
 				setup_selected = -1;
 				if (osd_selected != 0)
@@ -4009,10 +4098,18 @@
 					schedule_full_refresh();
 			}
 
 			update_video_and_audio();
 			reset_partial_updates();
+
+#ifdef MESS
+			if (!setup_selected && mess_pause_for_ui)
+			{
+				mess_pause_for_ui = 0;
+				break;
+			}
+#endif
 		}
 
 		if (code_pressed(KEYCODE_LSHIFT) || code_pressed(KEYCODE_RSHIFT))
 			single_step = 1;
 		else
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui srcmess.ori/usrintrf.h srcmess/usrintrf.h
--- srcmess.ori/usrintrf.h	2002-12-08 12:08:17.000000000 +0100
+++ srcmess/usrintrf.h	2003-01-24 15:45:00.000000000 +0100
@@ -52,16 +52,26 @@
 void switch_ui_orientation(struct mame_bitmap *bitmap);
 void switch_debugger_orientation(struct mame_bitmap *bitmap);
 void switch_true_orientation(struct mame_bitmap *bitmap);
 
 #ifdef __GNUC__
+#ifndef printf
 void CLIB_DECL usrintf_showmessage(const char *text,...)
       __attribute__ ((format (printf, 1, 2)));
 
 void CLIB_DECL usrintf_showmessage_secs(int seconds, const char *text,...)
       __attribute__ ((format (printf, 2, 3)));
 #else
+#undef printf
+void CLIB_DECL usrintf_showmessage(const char *text,...)
+      __attribute__ ((format (printf, 1, 2)));
+
+void CLIB_DECL usrintf_showmessage_secs(int seconds, const char *text,...)
+      __attribute__ ((format (printf, 2, 3)));
+#define printf printf_substitute
+#endif
+#else
 void CLIB_DECL usrintf_showmessage(const char *text,...);
 void CLIB_DECL usrintf_showmessage_secs(int seconds, const char *text,...);
 #endif
 
 #endif
