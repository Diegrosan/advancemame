diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui -x --linux-.--- srcpac.ori/common.c srcpac/common.c
--- srcpac.ori/common.c	Sun Apr 21 20:12:28 2002
+++ srcpac/common.c	Sun Apr 21 20:13:07 2002
@@ -430,17 +430,11 @@
 	coin_counter_w - sets input for coin counter
 -------------------------------------------------*/
 
 void coin_counter_w(int num,int on)
 {
-	if (num >= COIN_COUNTERS) return;
-	/* Count it only if the data has changed from 0 to non-zero */
-	if (on && (lastcoin[num] == 0))
-	{
-		coins[num]++;
-	}
-	lastcoin[num] = on;
+	/* moved in update_input_ports */
 }
 
 
 /*-------------------------------------------------
 	coin_lockout_w - locks out one coin input
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui -x --linux-.--- srcpac.ori/core.mak srcpac/core.mak
--- srcpac.ori/core.mak	Sun Apr 21 20:12:28 2002
+++ srcpac/core.mak	Sun Apr 21 20:39:43 2002
@@ -9,15 +9,14 @@
 	$(OBJ)/state.o $(OBJ)/datafile.o $(OBJ)/hiscore.o \
 	$(sort $(CPUOBJS)) \
 	$(OBJ)/sndintrf.o \
 	$(OBJ)/sound/streams.o $(OBJ)/sound/mixer.o $(OBJ)/sound/filter.o \
 	$(sort $(SOUNDOBJS)) \
-	$(OBJ)/sound/votrax.o \
 	$(OBJ)/machine/z80fmly.o $(OBJ)/machine/6821pia.o \
 	$(OBJ)/machine/8255ppi.o $(OBJ)/machine/7474.o \
-	$(OBJ)/vidhrdw/generic.o $(OBJ)/vidhrdw/vector.o \
-	$(OBJ)/vidhrdw/avgdvg.o $(OBJ)/machine/mathbox.o \
+	$(OBJ)/vidhrdw/generic.o \
+	$(OBJ)/machine/mathbox.o \
 	$(OBJ)/machine/ticket.o $(OBJ)/machine/eeprom.o \
 	$(OBJ)/machine/6522via.o \
 	$(OBJ)/machine/mb87078.o \
 	$(OBJ)/mamedbg.o $(OBJ)/window.o \
 	$(OBJ)/profiler.o \
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui -x --linux-.--- srcpac.ori/cpu/z80/z80.c srcpac/cpu/z80/z80.c
--- srcpac.ori/cpu/z80/z80.c	Sun Apr 21 20:12:30 2002
+++ srcpac/cpu/z80/z80.c	Sun Apr 21 20:13:06 2002
@@ -80,10 +80,16 @@
 
 #ifdef Z80_MSX
 #include "z80_msx.h"
 #endif
 
+#if defined(__GNUC__) && __GNUC__ >= 3
+/* Disable all the asm macro and the big switch */
+#undef X86_ASM
+#define BIG_SWITCH 0
+#endif
+
 #define VERBOSE 0
 
 #if VERBOSE
 #define LOG(x)	logerror x
 #else
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui -x --linux-.--- srcpac.ori/cpuexec.c srcpac/cpuexec.c
--- srcpac.ori/cpuexec.c	Sun Apr 21 20:12:30 2002
+++ srcpac/cpuexec.c	Sun Apr 21 20:13:07 2002
@@ -232,10 +232,13 @@
 	cpu_inittimers();
 	watchdog_counter = -1;
 
 	/* reset sound chips */
 	sound_reset();
+	
+	/* reset the osd level */
+	osd_reset();
 
 	/* first pass over CPUs */
 	for (cpunum = 0; cpunum < cpu_gettotalcpu(); cpunum++)
 	{
 		/* enable all CPUs (except for audio CPUs if the sound is off) */
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui -x --linux-.--- srcpac.ori/inptport.c srcpac/inptport.c
--- srcpac.ori/inptport.c	Sun Apr 21 20:12:30 2002
+++ srcpac/inptport.c	Sun Apr 21 20:13:08 2002
@@ -140,10 +140,13 @@
 	{ IPT_UI_SHOW_PROFILER,     "Show Profiler",		SEQ_DEF_2(KEYCODE_F11, KEYCODE_LSHIFT) },
 #ifdef MESS
 	{ IPT_UI_TOGGLE_UI,         "UI Toggle",			SEQ_DEF_1(KEYCODE_SCRLOCK) },
 #endif
 	{ IPT_UI_SNAPSHOT,          "Save Snapshot",		SEQ_DEF_1(KEYCODE_F12) },
+	{ IPT_UI_RECORD_START,      "Record Start", SEQ_DEF_2(KEYCODE_ENTER,KEYCODE_LCONTROL) },
+	{ IPT_UI_RECORD_STOP,       "Record Stop", SEQ_DEF_3(KEYCODE_ENTER,CODE_NOT,KEYCODE_LCONTROL) },
+	{ IPT_UI_TURBO,             "Turbo", SEQ_DEF_1(KEYCODE_ASTERISK) },
 	{ IPT_UI_TOGGLE_CHEAT,      "Toggle Cheat",			SEQ_DEF_1(KEYCODE_F6) },
 	{ IPT_UI_UP,                "UI Up",				SEQ_DEF_3(KEYCODE_UP, CODE_OR, JOYCODE_1_UP) },
 	{ IPT_UI_DOWN,              "UI Down",				SEQ_DEF_3(KEYCODE_DOWN, CODE_OR, JOYCODE_1_DOWN) },
 	{ IPT_UI_LEFT,              "UI Left",				SEQ_DEF_3(KEYCODE_LEFT, CODE_OR, JOYCODE_1_LEFT) },
 	{ IPT_UI_RIGHT,             "UI Right",				SEQ_DEF_3(KEYCODE_RIGHT, CODE_OR, JOYCODE_1_RIGHT) },
@@ -151,10 +154,12 @@
 	{ IPT_UI_CANCEL,            "UI Cancel",			SEQ_DEF_1(KEYCODE_ESC) },
 	{ IPT_UI_PAN_UP,            "Pan Up",				SEQ_DEF_3(KEYCODE_PGUP, CODE_NOT, KEYCODE_LSHIFT) },
 	{ IPT_UI_PAN_DOWN,          "Pan Down",				SEQ_DEF_3(KEYCODE_PGDN, CODE_NOT, KEYCODE_LSHIFT) },
 	{ IPT_UI_PAN_LEFT,          "Pan Left",				SEQ_DEF_2(KEYCODE_PGUP, KEYCODE_LSHIFT) },
 	{ IPT_UI_PAN_RIGHT,         "Pan Right",			SEQ_DEF_2(KEYCODE_PGDN, KEYCODE_LSHIFT) },
+	{ IPT_UI_MODE_NEXT,         "Mode Next",         SEQ_DEF_1(KEYCODE_STOP) },
+	{ IPT_UI_MODE_PRED,         "Mode Pred",         SEQ_DEF_1(KEYCODE_COMMA) },	
 	{ IPT_UI_TOGGLE_DEBUG,      "Toggle Debugger",		SEQ_DEF_1(KEYCODE_F5) },
 	{ IPT_UI_SAVE_STATE,        "Save State",			SEQ_DEF_2(KEYCODE_F7, KEYCODE_LSHIFT) },
 	{ IPT_UI_LOAD_STATE,        "Load State",			SEQ_DEF_3(KEYCODE_F7, CODE_NOT, KEYCODE_LSHIFT) },
 	{ IPT_UI_ADD_CHEAT,			"Add Cheat",			SEQ_DEF_1(KEYCODE_A) },
 	{ IPT_UI_DELETE_CHEAT,		"Delete Cheat",			SEQ_DEF_1(KEYCODE_D) },
@@ -1182,14 +1187,16 @@
 		int new, prev;
 
 		/* center stick */
 		if ((delta == 0) && (in->type & IPF_CENTER))
 		{
-			if (current > default_value)
-			delta = -100 / sensitivity;
-			if (current < default_value)
-			delta = 100 / sensitivity;
+			/* return backward at middle speed */
+			delta = default_value - current;
+			if (delta < -(keydelta+1)/2)
+				delta = -(keydelta+1)/2;
+			if (delta > (keydelta+1)/2)
+				delta = (keydelta+1)/2;
 		}
 
 		/* An analog joystick which is not at zero position (or has just */
 		/* moved there) takes precedence over all other computations */
 		/* analog_x/y holds values from -128 to 128 (yes, 128, not 127) */
@@ -1439,16 +1446,23 @@
 #define MAX_INPUT_BITS 1024
 	static int impulsecount[MAX_INPUT_BITS];
 	static int waspressed[MAX_INPUT_BITS];
 	static int pbwaspressed[MAX_INPUT_BITS];
 
+	unsigned newcoin[COIN_COUNTERS];
+	unsigned coin;
+
 #ifdef MAME_NET
 	int player;
 #endif /* MAME_NET */
 
 
 profiler_mark(PROFILER_INPUT);
+	
+	/* clear the new coin status */
+	for(coin=0;coin<4;++coin)
+		newcoin[coin] = 0;
 
 	/* clear all the values before proceeding */
 	for (port = 0;port < MAX_INPUT_PORTS;port++)
 	{
 		input_port_value[port] = 0;
@@ -1536,18 +1550,20 @@
 				}
 				else
 				{
 					InputSeq* seq;
 					seq = input_port_seq(in);
-					if (seq_pressed(seq))
+
+					if (osd_input_port_filter(seq_pressed(seq), in->type & (IPF_PLAYERMASK | ~IPF_MASK)))
 					{
-						/* skip if coin input and it's locked out */
-						if ((in->type & ~IPF_MASK) >= IPT_COIN1 &&
-							(in->type & ~IPF_MASK) <= IPT_COIN4 &&
-                            coinlockedout[(in->type & ~IPF_MASK) - IPT_COIN1])
-						{
-							continue;
+						if ((in->type & ~IPF_MASK) >= IPT_COIN1 && (in->type & ~IPF_MASK) <= IPT_COIN4) {
+							unsigned ncoin = (in->type & ~IPF_MASK) - IPT_COIN1;
+							if (coinlockedout[ncoin])
+								continue;
+							if (!lastcoin[ncoin])
+								++coins[ncoin];
+							newcoin[ncoin] = 1;
 						}
 
 						/* if IPF_RESET set, reset the first CPU */
 						if ((in->type & IPF_RESETCPU) && waspressed[ib] == 0 && !playback)
 						{
@@ -1675,10 +1691,14 @@
 #ifdef MAME_NET
 	if ( net_active() && (default_player != NET_SPECTATOR) )
 		net_input_sync((unsigned char *) input_port_value, (unsigned char *) input_port_defaults, MAX_INPUT_PORTS);
 #endif /* MAME_NET */
 
+	/* set the last coin status */
+	for(coin=0;coin<4;++coin)
+		lastcoin[coin] = newcoin[coin];
+	
 profiler_mark(PROFILER_END);
 }
 
 
 
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui -x --linux-.--- srcpac.ori/inptport.h srcpac/inptport.h
--- srcpac.ori/inptport.h	Sun Apr 21 20:12:30 2002
+++ srcpac/inptport.h	Sun Apr 21 20:13:09 2002
@@ -80,10 +80,15 @@
 	IPT_OSD_4,
 	IPT_EXTENSION,	/* this is an extension on the previous InputPort, not a real inputport. */
 					/* It is used to store additional parameters for analog inputs */
 
 	/* the following are special codes for user interface handling - not to be used by drivers! */
+	IPT_UI_MODE_NEXT,
+	IPT_UI_MODE_PRED,
+	IPT_UI_RECORD_START,
+	IPT_UI_RECORD_STOP,
+	IPT_UI_TURBO,
 	IPT_UI_CONFIGURE,
 	IPT_UI_ON_SCREEN_DISPLAY,
 	IPT_UI_PAUSE,
 	IPT_UI_RESET_MACHINE,
 	IPT_UI_SHOW_GFX,
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui -x --linux-.--- srcpac.ori/input.c srcpac/input.c
--- srcpac.ori/input.c	Sun Apr 21 20:12:30 2002
+++ srcpac/input.c	Sun Apr 21 20:13:09 2002
@@ -793,11 +793,11 @@
 {
 	int pressed;
 
 	profiler_mark(PROFILER_INPUT);
 
-	pressed = seq_pressed(input_port_type_seq(code));
+	pressed = osd_input_ui_filter(seq_pressed(input_port_type_seq(code)),code);
 
 	if (pressed)
 	{
 		if (ui_map[code].memory == 0)
 		{
@@ -817,11 +817,11 @@
 	static int counter,inputdelay;
 	int pressed;
 
 	profiler_mark(PROFILER_INPUT);
 
-	pressed = seq_pressed(input_port_type_seq(code));
+	pressed = osd_input_ui_filter(seq_pressed(input_port_type_seq(code)),code);
 
 	if (pressed)
 	{
 		if (ui_map[code].memory == 0)
 		{
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui -x --linux-.--- srcpac.ori/mame.c srcpac/mame.c
--- srcpac.ori/mame.c	Sun Apr 21 20:12:30 2002
+++ srcpac/mame.c	Sun Apr 21 20:13:09 2002
@@ -794,32 +794,20 @@
 
 
 /* Scale the vector games to a given resolution */
 static void scale_vectorgames(int gfx_width,int gfx_height,int *width,int *height)
 {
-	double x_scale, y_scale, scale;
-
 	if (Machine->orientation & ORIENTATION_SWAP_XY)
 	{
-		x_scale=(double)gfx_width/(double)(*height);
-		y_scale=(double)gfx_height/(double)(*width);
+		*width = gfx_height;
+		*height = gfx_width*9/16;
 	}
 	else
 	{
-		x_scale=(double)gfx_width/(double)(*width);
-		y_scale=(double)gfx_height/(double)(*height);
+		*width = gfx_width;
+		*height = gfx_height;
 	}
-	if (x_scale<y_scale)
-		scale=x_scale;
-	else
-		scale=y_scale;
-	*width=(int)((double)*width*scale);
-	*height=(int)((double)*height*scale);
-
-	/* Padding to an dword value */
-	*width-=*width % 4;
-	*height-=*height % 4;
 }
 
 
 static int vh_open(void)
 {
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui -x --linux-.--- srcpac.ori/neomame.mak srcpac/neomame.mak
--- srcpac.ori/neomame.mak	Sun Apr 21 20:12:32 2002
+++ srcpac/neomame.mak	Sun Apr 21 20:13:09 2002
@@ -8,17 +8,19 @@
 EMULATOR_EXE = neomame.exe
 
 # CPUs
 CPUS+=Z80@
 CPUS+=M68000@
+CPUS+=M68020@
 
 # SOUNDs
 SOUNDS+=AY8910@
 SOUNDS+=YM2610@
 
 DRVLIBS = $(OBJ)/neogeo.a
 
 $(OBJ)/neogeo.a: \
 	$(OBJ)/machine/neogeo.o $(OBJ)/machine/pd4990a.o $(OBJ)/vidhrdw/neogeo.o $(OBJ)/drivers/neogeo.o \
+	$(OBJ)/machine/neocrypt.o
 
 # MAME specific core objs
 COREOBJS += $(OBJ)/driver.o $(OBJ)/cheat.o
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui -x --linux-.--- srcpac.ori/osdepend.h srcpac/osdepend.h
--- srcpac.ori/osdepend.h	Sun Apr 21 20:12:32 2002
+++ srcpac/osdepend.h	Sun Apr 21 20:13:09 2002
@@ -198,10 +198,15 @@
 
 /* direct access to the Sound Blaster OPL chip */
 void osd_opl_control(int chip,int reg);
 void osd_opl_write(int chip,int data);
 
+/*
+  Start and stop the video/sound recording.
+*/
+void osd_record_start(void);
+void osd_record_stop(void);
 
 /******************************************************************************
 
   Keyboard
 
@@ -380,11 +385,27 @@
 /* things like changing the title bar or darkening the display. */
 /* Note that the OS dependant code must NOT stop processing input, since the user */
 /* interface is still active while the game is paused. */
 void osd_pause(int paused);
 
+/* called then the game is reset */
+void osd_reset(void);
+
+/* execute the specified menu (0,1,...) */
+int osd_menu(struct mame_bitmap *bitmap, int sel);
+
+/* return the CPU cycles counter value */
+unsigned int osd_cycles(void);
+
+/* filter the user interface input state */
+int osd_input_ui_filter(int result, int type);
+
+/* filter the main exit request */
+int osd_input_exit_filter(int result);
 
+/* filter the input port state */
+int osd_input_port_filter(int result, int type);
 
 #ifdef MAME_NET
 /* network */
 int osd_net_init(void);
 int osd_net_send(int player, unsigned char buf[], int *size);
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui -x --linux-.--- srcpac.ori/pac.mak srcpac/pac.mak
--- srcpac.ori/pac.mak	Thu Jan  1 01:00:00 1970
+++ srcpac/pac.mak	Sun Apr 21 20:43:12 2002
@@ -0,0 +1,183 @@
+# uncomment the following lines to include a CPU core
+CPUS+=Z80@
+#CPUS+=Z180@
+#CPUS+=8080@
+#CPUS+=8085A@
+CPUS+=M6502@
+#CPUS+=M65C02@
+#CPUS+=M65SC02@
+#CPUS+=M65CE02@
+#CPUS+=M6509@
+#CPUS+=M6510@
+#CPUS+=M6510T@
+#CPUS+=M7501@
+#CPUS+=M8502@
+#CPUS+=M4510@
+#CPUS+=N2A03@
+#CPUS+=H6280@
+#CPUS+=I86@
+#CPUS+=I88@
+#CPUS+=I186@
+#CPUS+=I188@
+#CPUS+=I286@
+#CPUS+=V20@
+#CPUS+=V30@
+#CPUS+=V33@
+#CPUS+=V60@
+#CPUS+=I8035@
+#CPUS+=I8039@
+#CPUS+=I8048@
+#CPUS+=N7751@
+#CPUS+=I8X41@
+CPUS+=M6800@
+CPUS+=M6801@
+CPUS+=M6802@
+CPUS+=M6803@
+CPUS+=M6808@
+CPUS+=HD63701@
+#CPUS+=NSC8105@
+CPUS+=M6805@
+CPUS+=M68705@
+CPUS+=HD63705@
+#CPUS+=HD6309@
+CPUS+=M6809@
+#CPUS+=KONAMI@
+CPUS+=M68000@
+#CPUS+=M68010@
+CPUS+=M68EC020@
+#CPUS+=M68020@
+#CPUS+=T11@
+CPUS+=S2650@
+#CPUS+=TMS34010@
+#CPUS+=TMS34020@
+#CPUS+=TMS9900@
+#CPUS+=TMS9940@
+#CPUS+=TMS9980@
+#CPUS+=TMS9985@
+#CPUS+=TMS9989@
+#CPUS+=TMS9995@
+#CPUS+=TMS99105A@
+#CPUS+=TMS99110A@
+#CPUS+=Z8000@
+#CPUS+=TMS320C10@
+CPUS+=CCPU@
+#CPUS+=ADSP2100@
+#CPUS+=ADSP2105@
+#CPUS+=PSXCPU@
+#CPUS+=ASAP@
+#CPUS+=UPD7810@
+#CPUS+=ARM@
+
+# uncomment the following lines to include a sound core
+SOUNDS+=CUSTOM@
+SOUNDS+=SAMPLES@
+SOUNDS+=DAC@
+#SOUNDS+=DISCRETE@
+SOUNDS+=AY8910@
+#SOUNDS+=YM2203@
+# enable only one of the following two
+#SOUNDS+=YM2151@
+SOUNDS+=YM2151_ALT@
+#SOUNDS+=YM2608@
+#SOUNDS+=YM2610@
+#SOUNDS+=YM2610B@
+#SOUNDS+=YM2612@
+#SOUNDS+=YM3438@
+#SOUNDS+=YM2413@
+#SOUNDS+=YM3812@
+#SOUNDS+=YMZ280B@
+#SOUNDS+=YM3526@
+#SOUNDS+=Y8950@
+#SOUNDS+=SN76477@
+SOUNDS+=SN76496@
+#SOUNDS+=POKEY@
+#SOUNDS+=NES@
+SOUNDS+=ASTROCADE@
+SOUNDS+=NAMCO@
+#SOUNDS+=TMS36XX@
+#SOUNDS+=TMS5110@
+#SOUNDS+=TMS5220@
+#SOUNDS+=VLM5030@
+#SOUNDS+=ADPCM@
+#SOUNDS+=OKIM6295@
+#SOUNDS+=MSM5205@
+#SOUNDS+=MSM5232@
+#SOUNDS+=UPD7759@
+#SOUNDS+=HC55516@
+#SOUNDS+=K005289@
+SOUNDS+=K007232@
+#SOUNDS+=K051649@
+#SOUNDS+=K053260@
+#SOUNDS+=K054539@
+#SOUNDS+=SEGAPCM@
+#SOUNDS+=RF5C68@
+#SOUNDS+=CEM3394@
+#SOUNDS+=C140@
+#SOUNDS+=QSOUND@
+#SOUNDS+=SAA1099@
+#SOUNDS+=IREMGA20@
+#SOUNDS+=ES5505@
+#SOUNDS+=ES5506@
+#SOUNDS+=BSMT2000@
+
+DRVLIBS = \
+	$(OBJ)/pac.a
+
+$(OBJ)/pac.a: \
+	$(OBJ)/drivers/astrocde.o \
+	$(OBJ)/drivers/btime.o \
+	$(OBJ)/drivers/galaxian.o \
+	$(OBJ)/drivers/jrpacman.o \
+	$(OBJ)/drivers/namconb1.o \
+	$(OBJ)/drivers/namcond1.o \
+	$(OBJ)/drivers/namcos1.o \
+	$(OBJ)/drivers/pacland.o \
+	$(OBJ)/drivers/pacman.o \
+	$(OBJ)/drivers/pacmanx.o \
+	$(OBJ)/drivers/superpac.o \
+	$(OBJ)/vidhrdw/astrocde.o \
+	$(OBJ)/vidhrdw/btime.o \
+	$(OBJ)/vidhrdw/galaxian.o \
+	$(OBJ)/vidhrdw/generic.o \
+	$(OBJ)/vidhrdw/jrpacman.o \
+	$(OBJ)/vidhrdw/namcona1.o \
+	$(OBJ)/vidhrdw/namconb1.o \
+	$(OBJ)/vidhrdw/namcos1.o \
+	$(OBJ)/vidhrdw/pacland.o \
+	$(OBJ)/vidhrdw/pacmanx.o \
+	$(OBJ)/vidhrdw/pengo.o \
+	$(OBJ)/vidhrdw/segar.o \
+	$(OBJ)/vidhrdw/superpac.o \
+	$(OBJ)/vidhrdw/ygv608.o \
+	$(OBJ)/sndhrdw/astrocde.o \
+	$(OBJ)/sndhrdw/cclimber.o \
+	$(OBJ)/sndhrdw/galaxian.o \
+	$(OBJ)/sndhrdw/gorf.o \
+	$(OBJ)/sndhrdw/scramble.o \
+	$(OBJ)/machine/6522via.o \
+	$(OBJ)/machine/6821pia.o \
+	$(OBJ)/machine/7474.o \
+	$(OBJ)/machine/8255ppi.o \
+	$(OBJ)/machine/astrocde.o \
+	$(OBJ)/machine/btime.o \
+	$(OBJ)/machine/eeprom.o \
+	$(OBJ)/machine/mathbox.o \
+	$(OBJ)/machine/mb87078.o \
+	$(OBJ)/machine/mspacman.o \
+	$(OBJ)/machine/namcond1.o \
+	$(OBJ)/machine/namcos1.o \
+	$(OBJ)/machine/pacplus.o \
+	$(OBJ)/machine/plusfast.o \
+	$(OBJ)/machine/superpac.o \
+	$(OBJ)/machine/theglobp.o \
+	$(OBJ)/machine/ticket.o \
+	$(OBJ)/machine/z80fmly.o
+
+COREOBJS += $(OBJ)/driver.o $(OBJ)/cheat.o
+
+# generated text files
+TEXTS += gamelist.txt
+
+gamelist.txt: $(EMULATOR)
+	@echo Generating $@...
+	@$(CURPATH)$(EMULATOR) -gamelist -noclones -sortname > gamelist.txt
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui -x --linux-.--- srcpac.ori/rules.mak srcpac/rules.mak
--- srcpac.ori/rules.mak	Sun Apr 21 20:12:32 2002
+++ srcpac/rules.mak	Sun Apr 21 20:38:35 2002
@@ -706,11 +706,11 @@
 
 CPU=$(strip $(findstring CCPU@,$(CPUS)))
 ifneq ($(CPU),)
 OBJDIRS += $(OBJ)/cpu/ccpu
 CPUDEFS += -DHAS_CCPU=1
-CPUOBJS += $(OBJ)/cpu/ccpu/ccpu.o $(OBJ)/vidhrdw/cinemat.o
+CPUOBJS += $(OBJ)/cpu/ccpu/ccpu.o
 DBGOBJS += $(OBJ)/cpu/ccpu/ccpudasm.o
 $(OBJ)/cpu/ccpu/ccpu.o: ccpu.c ccpu.h ccputabl.c
 else
 CPUDEFS += -DHAS_CCPU=0
 endif
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui -x --linux-.--- srcpac.ori/sound/fm.c srcpac/sound/fm.c
--- srcpac.ori/sound/fm.c	Sun Apr 21 20:12:32 2002
+++ srcpac/sound/fm.c	Sun Apr 21 20:13:08 2002
@@ -160,11 +160,11 @@
 #define LFO_RATE 0x10000
 #define PMS_RATE 0x400
 /* LFO runtime work */
 static UINT32 lfo_amd;
 static INT32 lfo_pmd;
-#if BUILD_YM2610B
+#if BUILD_YM2610B || BUILD_OPNB
 static UINT32 LFOCnt,LFOIncr;	/* LFO Phase Generator */
 #endif
 /* OPN LFO waveform table */
 static INT32 OPN_LFO_wave[LFO_ENT];
 
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui -x --linux-.--- srcpac.ori/ui_text.c srcpac/ui_text.c
--- srcpac.ori/ui_text.c	Sun Apr 21 20:12:32 2002
+++ srcpac/ui_text.c	Sun Apr 21 20:13:09 2002
@@ -202,10 +202,14 @@
 	"Restoration successful",
 	"Select a value",
 	"All values saved",
 	"One match found - added to list",
 
+	/* addendum */
+	"Center",
+	"Video",
+
 	NULL
 };
 
 int uistring_init (void *langfile)
 {
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui -x --linux-.--- srcpac.ori/ui_text.h srcpac/ui_text.h
--- srcpac.ori/ui_text.h	Sun Apr 21 20:12:32 2002
+++ srcpac/ui_text.h	Sun Apr 21 20:13:09 2002
@@ -169,10 +169,14 @@
 	UI_search_OK,
 	UI_search_select_value,
 	UI_search_all_values_saved,
 	UI_search_one_match_found_added,
 
+	/* addendum */
+	UI_center,
+	UI_osdmenu,
+
 	UI_last_entry
 };
 
 struct lang_struct
 {
diff -U 5 --new-file --recursive -x msdos -x unix -x windows -x windowsui -x --linux-.--- srcpac.ori/usrintrf.c srcpac/usrintrf.c
--- srcpac.ori/usrintrf.c	Sun Apr 21 20:12:32 2002
+++ srcpac/usrintrf.c	Sun Apr 21 20:15:16 2002
@@ -708,12 +708,16 @@
 	while (items[i])
 	{
 		len = 3 + strlen(items[i]);
 		if (subitems && subitems[i])
 			len += 2 + strlen(subitems[i]);
-		if (len > maxlen && len <= highlen)
-			maxlen = len;
+		if (len > maxlen) {
+			if (len <= highlen)
+				maxlen = len;
+			else
+				maxlen = highlen;
+		}
 		i++;
 	}
 	count = i;
 
 	visible = Machine->uiheight / (3 * Machine->uifontheight / 2) - 1;
@@ -781,15 +785,27 @@
 				dt[curr_dt].y = topoffs + (3*i+1)*Machine->uifontheight/2;
 				curr_dt++;
 			}
 			else
 			{
-				dt[curr_dt].text = items[item];
-				dt[curr_dt].color = UI_COLOR_NORMAL;
-				dt[curr_dt].x = (Machine->uiwidth - Machine->uifontwidth * strlen(items[item])) / 2;
-				dt[curr_dt].y = topoffs + (3*i+1)*Machine->uifontheight/2;
-				curr_dt++;
+				unsigned y = topoffs + (3*i+1)*Machine->uifontheight/2;
+				int color = (flag && flag[item]) ? UI_COLOR_INVERSE : UI_COLOR_NORMAL;
+				len = strlen(items[item]);
+				if (len	> maxlen - 3) {
+					unsigned x;
+					const char* dot = "...";
+					len = maxlen - 3;
+					x = (Machine->uiwidth - Machine->uifontwidth * len) / 2;
+					ui_text_ex(bitmap,items[item],items[item] + len - 3,x,y,color);
+					ui_text_ex(bitmap,dot,dot+3,x + Machine->uifontwidth * (len - 3),y,color);
+				} else {
+					dt[curr_dt].text = items[item];
+					dt[curr_dt].color = color;
+					dt[curr_dt].x = (Machine->uiwidth - Machine->uifontwidth * len) / 2;
+					dt[curr_dt].y = y;
+					curr_dt++;
+				}
 			}
 		}
 	}
 
 	i = selected - topitem;
@@ -1898,13 +1914,13 @@
 		in++;
 	}
 
 	if (total == 0) return 0;
 
-	/* Each analog control has 3 entries - key & joy delta, reverse, sensitivity */
+	/* Each analog control has 4 entries - key & joy delta, reverse, sensitivity, center */
 
-#define ENTRIES 3
+#define ENTRIES 4
 
 	total2 = total * ENTRIES;
 
 	menu_item[total2] = ui_getstring (UI_returntomain);
 	menu_item[total2 + 1] = 0;	/* terminate array */
@@ -1917,15 +1933,17 @@
 		{
 			char label[30][40];
 			char setting[30][40];
 			int sensitivity,delta;
 			int reverse;
+			int center;
 
 			strcpy (label[i], input_port_name(entry[i/ENTRIES]));
 			sensitivity = IP_GET_SENSITIVITY(entry[i/ENTRIES]);
 			delta = IP_GET_DELTA(entry[i/ENTRIES]);
 			reverse = (entry[i/ENTRIES]->type & IPF_REVERSE);
+			center = (entry[i/ENTRIES]->type & IPF_CENTER);
 
 			strcat (label[i], " ");
 			switch (i%ENTRIES)
 			{
 				case 0:
@@ -1944,10 +1962,18 @@
 				case 2:
 					strcat (label[i], ui_getstring (UI_sensitivity));
 					sprintf(setting[i],"%3d%%",sensitivity);
 					if (i == sel) arrowize = 3;
 					break;
+				case 3:
+					strcat (label[i], ui_getstring (UI_center));
+					if (center)
+						sprintf(setting[i],ui_getstring (UI_on));
+					else
+						sprintf(setting[i],ui_getstring (UI_off));
+					if (i == sel) arrowize = 3;
+					break;
 			}
 
 			menu_item[i] = label[i];
 			menu_subitem[i] = setting[i];
 
@@ -1993,10 +2019,21 @@
 
 			val --;
 			if (val < 1) val = 1;
 			IP_SET_SENSITIVITY(entry[sel/ENTRIES],val);
 		}
+		else if ((sel % ENTRIES) == 3)
+		/* center */
+		{
+			int center = entry[sel/ENTRIES]->type & IPF_CENTER;
+			if (center)
+				center=0;
+			else
+				center=IPF_CENTER;
+			entry[sel/ENTRIES]->type &= ~IPF_CENTER;
+			entry[sel/ENTRIES]->type |= center;
+		}
 	}
 
 	if (input_ui_pressed_repeat(IPT_UI_RIGHT,8))
 	{
 		if ((sel % ENTRIES) == 0)
@@ -2026,10 +2063,21 @@
 
 			val ++;
 			if (val > 255) val = 255;
 			IP_SET_SENSITIVITY(entry[sel/ENTRIES],val);
 		}
+		else if ((sel % ENTRIES) == 3)
+		/* center */
+		{
+			int center = entry[sel/ENTRIES]->type & IPF_CENTER;
+			if (center)
+				center=0;
+			else
+				center=IPF_CENTER;
+			entry[sel/ENTRIES]->type &= ~IPF_CENTER;
+			entry[sel/ENTRIES]->type |= center;
+		}
 	}
 
 	if (input_ui_pressed(IPT_UI_SELECT))
 	{
 		if (sel == total2 - 1) sel = -1;
@@ -2875,15 +2923,15 @@
 */
 
 #ifndef MESS
 enum { UI_SWITCH = 0,UI_DEFCODE,UI_CODE,UI_ANALOG,UI_CALIBRATE,
 		UI_STATS,UI_GAMEINFO, UI_HISTORY,
-		UI_CHEAT,UI_RESET,UI_MEMCARD,UI_EXIT };
+		UI_CHEAT,UI_RESET,UI_MEMCARD,UI_EXIT,UI_OSD };
 #else
 enum { UI_SWITCH = 0,UI_DEFCODE,UI_CODE,UI_ANALOG,UI_CALIBRATE,
 		UI_GAMEINFO, UI_IMAGEINFO,UI_FILEMANAGER,UI_TAPECONTROL,
-		UI_HISTORY,UI_CHEAT,UI_RESET,UI_MEMCARD,UI_EXIT };
+		UI_HISTORY,UI_CHEAT,UI_RESET,UI_MEMCARD,UI_EXIT,UI_OSD };
 #endif
 
 
 #define MAX_SETUPMENU_ITEMS 20
 static const char *menu_item[MAX_SETUPMENU_ITEMS];
@@ -2954,10 +3002,11 @@
 	}
 #endif
 #endif
 #endif
 */
+	menu_item[menu_total] = ui_getstring (UI_osdmenu); menu_action[menu_total++] = UI_OSD;
 	menu_item[menu_total] = ui_getstring (UI_resetgame); menu_action[menu_total++] = UI_RESET;
 	menu_item[menu_total] = ui_getstring (UI_returntogame); menu_action[menu_total++] = UI_EXIT;
 	menu_item[menu_total] = 0; /* terminate array */
 }
 
@@ -3014,10 +3063,13 @@
 				res = displayhistory(bitmap, sel >> SEL_BITS);
 				break;
 			case UI_CHEAT:
 				res = cheat_menu(bitmap, sel >> SEL_BITS);
 				break;
+			case UI_OSD :
+				res = osd_menu(bitmap, sel >> SEL_BITS);
+				break;
 /*
 #ifndef MESS
 #ifndef TINY_COMPILE
 #ifndef CPSMAME
 			case UI_MEMCARD:
@@ -3068,10 +3120,11 @@
 			case UI_TAPECONTROL:
 			#endif
 			case UI_HISTORY:
 			case UI_CHEAT:
 			case UI_MEMCARD:
+			case UI_OSD :
 				sel |= 1 << SEL_BITS;
 				schedule_full_refresh();
 				break;
 
 			case UI_RESET:
@@ -3509,10 +3562,63 @@
 	vsprintf(messagetext,text,arg);
 	va_end(arg);
 	messagecounter = seconds * Machine->drv->frames_per_second;
 }
 
+int on_exit_menu(struct mame_bitmap* bitmap, int selected)
+{
+	const char * exit_menu_item[8];
+	char flag[8];
+
+	int sel;
+	int total;
+
+	sel = selected - 1;
+
+	total = 0;
+
+	exit_menu_item[total] = "Continue";
+	flag[total] = 0;
+	++total;
+
+	exit_menu_item[total] = "Exit";
+	flag[total] = 0;
+	++total;
+
+	exit_menu_item[total] = 0;
+	flag[total] = 0;
+
+	ui_displaymenu(bitmap,exit_menu_item,0,flag,sel,0);
+
+	if (input_ui_pressed_repeat(IPT_UI_DOWN,8)) {
+		sel = (sel + 1) % total;
+	}
+
+	if (input_ui_pressed_repeat(IPT_UI_UP,8)) {
+		sel = (sel + total - 1) % total;
+	}
+
+	if (input_ui_pressed(IPT_UI_SELECT)) {
+		if (sel == 1)
+			sel = -2;
+		if (sel == 0)
+			sel = -1;
+	}
+
+	if (input_ui_pressed(IPT_UI_CANCEL)) {
+		sel = -1;
+	}
+
+	if (sel == -1 || sel == -2)
+	{
+		/* tell updatescreen() to clean after us */
+		schedule_full_refresh();
+	}
+
+	return sel + 1;
+}
+
 int handle_user_interface(struct mame_bitmap *bitmap)
 {
 	static int show_profiler;
 	int request_loadsave = LOADSAVE_NONE;
 
@@ -3579,17 +3685,42 @@
 
 	/* if the user pressed F12, save the screen to a file */
 	if (input_ui_pressed(IPT_UI_SNAPSHOT))
 		osd_save_snapshot(bitmap);
 
+	/* save the sound to a file */
+	if (input_ui_pressed(IPT_UI_RECORD_START))
+		osd_record_start();
+	if (input_ui_pressed(IPT_UI_RECORD_STOP))
+		osd_record_stop();
+
 	/* This call is for the cheat, it must be called once a frame */
 	if (options.cheat) DoCheat(bitmap);
 
 	/* if the user pressed ESC, stop the emulation */
 	/* but don't quit if the setup menu is on screen */
-	if (setup_selected == 0 && input_ui_pressed(IPT_UI_CANCEL))
-		return 1;
+	if (setup_selected == 0) {
+		int res = osd_input_exit_filter(input_ui_pressed(IPT_UI_CANCEL));
+		if (res > 1)
+			return 1;
+		if (res != 0) {
+			osd_sound_enable(0);
+			osd_pause(1);
+
+			res = 1;
+			while (res > 0) {
+				res = on_exit_menu(bitmap,res);
+				update_video_and_audio();
+			}
+
+			osd_pause(0);
+			osd_sound_enable(1);
+
+			if (res < 0)
+				return 1;
+		}
+	}
 
 	if (setup_selected == 0 && input_ui_pressed(IPT_UI_CONFIGURE))
 	{
 		setup_selected = -1;
 		if (osd_selected != 0)
@@ -3750,11 +3881,11 @@
 
 			if (input_ui_pressed(IPT_UI_SNAPSHOT))
 				osd_save_snapshot(bitmap);
 
 			if (setup_selected == 0 && input_ui_pressed(IPT_UI_CANCEL))
-				return 1;
+				break;
 
 			if (setup_selected == 0 && input_ui_pressed(IPT_UI_CONFIGURE))
 			{
 				setup_selected = -1;
 				if (osd_selected != 0)
